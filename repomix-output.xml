<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
/target
Cargo.lock
.env
.DS_Store
*.swp
*.swo
tools/

# Cursor build artifacts
build_cursor.exe
cursor_data.txt
broom.cur
screen-goated-toolbox-*.exe

# Patched dependencies (cloned by scripts/setup-egui-snarl.ps1)
libs/egui-snarl/

# PromptDJ artifacts
src/overlay/prompt_dj/dist/

# Agent specific files
.agent/
</file>

<file path="app.rc">
id ICON "assets/app.ico"

1 VERSIONINFO
FILEVERSION 3,5,1,0
PRODUCTVERSION 3,5,1,0
BEGIN
  BLOCK "StringFileInfo"
  BEGIN
    BLOCK "040904E4"
    BEGIN
      VALUE "CompanyName", "nganlinh4 - Open Source Developer"
      VALUE "FileDescription", "Screen Goated Toolbox - AI-powered screen capture and productivity tool. Open source on GitHub."
      VALUE "FileVersion", "3.5.1.0"
      VALUE "InternalName", "screen-goated-toolbox"
      VALUE "LegalCopyright", "Copyright (c) 2024-2025 nganlinh4. MIT License. https://github.com/nganlinh4/screen-goated-toolbox"
      VALUE "OriginalFilename", "ScreenGoatedToolbox.exe"
      VALUE "ProductName", "Screen Goated Toolbox (SGT)"
      VALUE "ProductVersion", "3.5.1.0"
    END
  END
  BLOCK "VarFileInfo"
  BEGIN
    VALUE "Translation", 0x409, 1252
  END
END
</file>

<file path="build.rs">
use std::fs;
⋮----
use std::path::Path;
fn main() {
let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
println!("cargo::rustc-check-cfg=cfg(nopack)");
let assets_dir = Path::new(&manifest_dir).join("assets");
⋮----
.join("assets")
.join("tray-icon.png");
if tray_source.exists() {
let tray_icon_path = assets_dir.join("tray_icon.png");
⋮----
let resized = img.resize(32, 32, image::imageops::FilterType::Lanczos3);
let _ = resized.save_with_format(&tray_icon_path, image::ImageFormat::Png);
⋮----
let app_icon_path = assets_dir.join("app-icon-small.png");
let app_icon_small_path = assets_dir.join("app-icon-small.png");
if app_icon_path.exists() {
⋮----
let resized = img.resize(256, 256, image::imageops::FilterType::Lanczos3);
let _ = resized.save(&app_icon_small_path);
⋮----
if app_icon_small_path.exists() {
let ico_path = assets_dir.join("app.ico");
create_multi_size_ico(&app_icon_small_path, &ico_path);
⋮----
let ico_path = Path::new(&manifest_dir).join("assets").join("app.ico");
let rc_path = Path::new(&manifest_dir).join("app.rc");
if ico_path.exists() && rc_path.exists() {
let out_dir = std::env::var("OUT_DIR").unwrap();
let res_path = Path::new(&out_dir).join("resources.o");
⋮----
.arg(&rc_path)
.arg("-o")
.arg(&res_path)
.status();
⋮----
Ok(s) if s.success() => {
println!("cargo:rustc-link-arg={}", res_path.display());
⋮----
panic!("windres failed with exit code: {}", s);
⋮----
panic!("Failed to execute windres: {}", e);
⋮----
println!("cargo:rerun-if-changed=assets/app-icon-small.png");
println!("cargo:rerun-if-changed=icon.png");
println!("cargo:rerun-if-changed=app.rc");
println!("cargo:rerun-if-changed=build.rs");
⋮----
fn create_multi_size_ico(png_path: &Path, ico_path: &Path) {
let img = image::open(png_path).expect("Failed to open PNG");
let mut file = fs::File::create(ico_path).expect("Failed to create ICO");
⋮----
let num_images = sizes.len() as u16;
file.write_all(&[0, 0]).unwrap();
file.write_all(&[1, 0]).unwrap();
file.write_all(&num_images.to_le_bytes()).unwrap();
⋮----
let resized = img.resize(size, size, image::imageops::FilterType::Lanczos3);
⋮----
.write_to(&mut buffer, image::ImageFormat::Png)
.unwrap();
data = buffer.into_inner();
⋮----
let rgba = resized.to_rgba8();
data.extend_from_slice(&40u32.to_le_bytes());
data.extend_from_slice(&(size as i32).to_le_bytes());
data.extend_from_slice(&(size as i32 * 2).to_le_bytes());
data.extend_from_slice(&[1, 0]);
data.extend_from_slice(&[32, 0]);
data.extend_from_slice(&[0, 0, 0, 0]);
⋮----
for row in (0..rgba.height()).rev() {
for col in 0..rgba.width() {
let pixel = rgba.get_pixel(col, row);
data.push(pixel[2]);
data.push(pixel[1]);
data.push(pixel[0]);
data.push(pixel[3]);
⋮----
data.push(0);
⋮----
images_data.push(data);
⋮----
for (i, size) in sizes.iter().enumerate() {
⋮----
let data_size = images_data[i].len() as u32;
file.write_all(&[width]).unwrap();
file.write_all(&[height]).unwrap();
file.write_all(&[0]).unwrap();
⋮----
file.write_all(&[32, 0]).unwrap();
file.write_all(&data_size.to_le_bytes()).unwrap();
file.write_all(&offset.to_le_bytes()).unwrap();
⋮----
file.write_all(&data).unwrap();
</file>

<file path="docs/WEBVIEW2_INITIALIZATION.md">
# WebView2 Initialization on Windows - Critical Notes

## The Problem

WebView2 (`wry` crate) creation can hang indefinitely on Windows when:
1. Called from deeply nested spawned threads
2. Called without proper warmup of the WebView2 infrastructure

## Root Cause

WebView2 requires the first `WebViewBuilder::build_as_child()` call to happen in a specific context:
- Thread spawned **directly from the main thread** 
- With a proper message loop running
- Window styles matching: `WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED` (NO `WS_EX_NOACTIVATE`)
- Base style: `WS_POPUP` (NO `WS_CLIPCHILDREN`)

When the first WebView is created from a thread that was spawned several levels deep in the call stack (e.g., hotkey handler → capture thread → process thread → result window thread), the WebView2 controller initialization hangs at `CreateCoreWebView2Controller`.

## The Solution: Warmup Pattern

Follow the same pattern as `text_input.rs`:

1. **Call warmup at app startup** (in `main.rs`):
```rust
overlay::result::markdown_view::warmup();
```

2. **Warmup spawns a dedicated thread** from the main thread context:
```rust
pub fn warmup() {
    std::thread::spawn(|| {
        warmup_internal();
    });
}
```

3. **Create a hidden window with WebView** in that thread:
```rust
fn warmup_internal() {
    // Create hidden window
    let hwnd = CreateWindowExW(
        WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_LAYERED,
        class_name,
        w!("MarkdownWarmup"),
        WS_POPUP,
        0, 0, 100, 100,
        None, None, instance, None
    );
    
    // Make transparent
    SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
    
    // Create WebView - this "warms up" the WebView2 infrastructure
    let result = WebViewBuilder::new()
        .with_bounds(...)
        .with_html("<html><body>Warmup</body></html>")
        .with_transparent(false)
        .build_as_child(&wrapper);
    
    // Run message loop forever to keep thread alive
    while GetMessageW(&mut msg, None, 0, 0).into() {
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }
}
```

4. **After warmup succeeds**, all subsequent WebView2 creations work - even from deeply nested threads!

## Why This Works

The first WebView2 creation initializes the shared WebView2 runtime infrastructure. Once initialized from a "good" thread context (spawned directly from main), all other threads can successfully create WebViews.

## Window Style Requirements for WebView2

| Style | Required for WebView2 |
|-------|----------------------|
| `WS_EX_NOACTIVATE` | ❌ AVOID - blocks initialization |
| `WS_CLIPCHILDREN` | ❌ AVOID - can interfere |
| `WS_EX_LAYERED` | ✅ OK |
| `WS_EX_TOOLWINDOW` | ✅ OK |
| `WS_EX_TOPMOST` | ✅ OK |
| `WS_POPUP` | ✅ Use as base style |

## Debug Tips

If WebView creation hangs:
1. Check if `[WARMUP] WebView created successfully!` appears at startup
2. If not, the warmup itself is failing
3. Add `eprintln!` at each step to find where it hangs
4. The typical hang point is Step 6 (`build_as_child()`)

## Related Files

- `src/overlay/result/markdown_view.rs` - Contains `warmup()` function
- `src/overlay/text_input.rs` - Reference implementation that works
- `src/main.rs` - Where warmup is called

---
*This issue was debugged in December 2024. The fix involved extensive investigation of thread spawning hierarchies, window styles, and COM initialization.*
</file>

<file path="installer.nsi">
; Screen Goated Toolbox Installer
!include "MUI2.nsh"
!include "x64.nsh"

; Basic Settings
Name "Screen Goated Toolbox"
OutFile "target\release\screen-goated-toolbox-installer.exe"
InstallDir "$PROGRAMFILES\ScreenGoatedToolbox"
RequestExecutionLevel admin
Icon ".\assets\app.ico"

; MUI Settings
!insertmacro MUI_PAGE_WELCOME
!insertmacro MUI_PAGE_DIRECTORY
!insertmacro MUI_PAGE_INSTFILES
!insertmacro MUI_PAGE_FINISH

!insertmacro MUI_LANGUAGE "English"

; Installer Sections
Section "Install Application"
  SetOutPath "$INSTDIR"
  
  ; Copy main executable
  File "target\release\screen-goated-toolbox.exe"
  
  ; Copy Visual C++ Runtime and install it
  File "vc_redist.x64.exe"
  DetailPrint "Installing Visual C++ Runtime..."
  ExecWait "$INSTDIR\vc_redist.x64.exe /quiet /norestart" $0
  Delete "$INSTDIR\vc_redist.x64.exe"
  
  ; Create Start Menu shortcut
  CreateDirectory "$SMPROGRAMS\Screen Goated Toolbox"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  CreateShortcut "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk" "$INSTDIR\uninstall.exe"
  
  ; Create Desktop shortcut (optional, uncomment if desired)
  ; CreateShortcut "$DESKTOP\Screen Goated Toolbox.lnk" "$INSTDIR\screen-goated-toolbox.exe"
  
  ; Write uninstaller
  WriteUninstaller "$INSTDIR\uninstall.exe"
  
  ; Write registry entry for Add/Remove Programs
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayName" "Screen Goated Toolbox"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "UninstallString" "$INSTDIR\uninstall.exe"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "InstallLocation" "$INSTDIR"
  WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox" "DisplayVersion" "1.6"
SectionEnd

; Uninstaller Section
Section "Uninstall"
  Delete "$INSTDIR\screen-goated-toolbox.exe"
  Delete "$INSTDIR\uninstall.exe"
  RMDir "$INSTDIR"
  
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Screen Goated Toolbox.lnk"
  Delete "$SMPROGRAMS\Screen Goated Toolbox\Uninstall.lnk"
  RMDir "$SMPROGRAMS\Screen Goated Toolbox"
  
  Delete "$DESKTOP\Screen Goated Toolbox.lnk"
  
  DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\ScreenGoatedToolbox"
SectionEnd
</file>

<file path="promptdj-midi/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="promptdj-midi/components/OnboardingPopup.ts">
import { css, html, LitElement } from 'lit';
import { customElement, state, property } from 'lit/decorators.js';
import { LOCALES, Lang } from '../utils/Locales';
⋮----
export class OnboardingPopup extends LitElement
⋮----
connectedCallback()
private dismiss()
render()
</file>

<file path="promptdj-midi/components/PlayPauseButton.ts">
import { svg, css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import type { PlaybackState } from '../types';
⋮----
export class PlayPauseButton extends LitElement
⋮----
private renderSvg()
private renderPause()
private renderPlay()
private renderLoading()
private renderIcon()
override render()
⋮----
interface HTMLElementTagNameMap {
    'play-pause-button': PlayPauseButton
  }
</file>

<file path="promptdj-midi/components/PlayPauseMorphWrapper.tsx">
import { createRoot, Root } from 'react-dom/client';
import PlayPauseMorphType4 from './react/PlayPauseMorphType4.jsx';
import LoadingIndicator from './react/LoadingIndicator.jsx';
⋮----
static get observedAttributes()
connectedCallback()
attributeChangedCallback(name: string, _oldVal: string | null, newVal: string | null)
disconnectedCallback()
</file>

<file path="promptdj-midi/components/PromptController.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property, query, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
⋮----
import type { WeightKnob } from './WeightKnob';
import type { MidiDispatcher } from '../utils/MidiDispatcher';
import type { Prompt, ControlChange } from '../types';
import { LOCALES, Lang } from '../utils/Locales';
⋮----
export class PromptController extends LitElement
⋮----
@property({ type: Number }) channel = 0; // Not currently used
⋮----
override connectedCallback()
override firstUpdated()
⋮----
this.textInput.setAttribute('dir', 'ltr'); // Ensure LTR direction to avoid RTL heuristics
⋮----
override update(changedProperties: Map<string, unknown>)
⋮----
// Avoid resetting the contenteditable while the user is typing, which can move the caret
⋮----
private dispatchPromptChange()
private onKeyDown(e: KeyboardEvent)
private onInlineInput()
⋮----
// Live-update arc text while typing (span is invisible, arc shows)
⋮----
// Do not commit lastValidText until stopEditing; but propagate for live behavior
⋮----
private resetText()
private async stopEditing()
private onFocus()
⋮----
range.collapse(false); // place caret at end
⋮----
private startEditing()
private updateWeight()
private toggleLearnMode()
override render()
⋮----
interface HTMLElementTagNameMap {
    'prompt-controller': PromptController;
  }
</file>

<file path="promptdj-midi/components/PromptDjMidi.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property, state, query } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
import { throttle } from '../utils/throttle';
⋮----
import type { PlaybackState, Prompt } from '../types';
import { MidiDispatcher } from '../utils/MidiDispatcher';
import { LOCALES, Lang } from '../utils/Locales';
⋮----
export class PromptDjMidi extends LitElement
⋮----
// Recording playback state
⋮----
@state() private optimisticPlaying: boolean | null = null; // null = follow real state
⋮----
private clickCooldownUntil: number = 0; // epoch ms; during this window, ignore extra toggles
// Background drift control
@state() private driftStrength: number = 0; // 0 = at base, 1 = full drift
⋮----
// Left add-column activation state (4 slots)
⋮----
// Track which base grid slots are removed (to render add buttons in-grid)
⋮----
constructor(
    initialPrompts: Map<string, Prompt>,
)
⋮----
// Deep-copy base prompts
⋮----
// Start with defaults, BUT leave the last 2 (Custom) as empty slots
// There are 24 slots total. We want 22 active, 2 empty.
⋮----
// Load saved state and MERGE it
⋮----
// Only update if it corresponds to a valid base prompt or a known extra
// (For now, we trust the defaults structure more for the base grid)
⋮----
// Restore USER state (text, weight, color) but keep structure valid
⋮----
// Restore extra slots
⋮----
// Only respect removal of keys that actually exist in our base order
⋮----
public showRecording(blob: Blob)
private closeModal()
private downloadRecording()
private renderModal()
private saveState()
private handlePromptChanged(e: CustomEvent<Prompt>)
/** Generates radial gradients for each prompt based on weight and color, with gentle drift while playing. */
⋮----
const clamp01 = (v: number)
⋮----
const t = performance.now() * 0.0006; // time base for gentle drift
⋮----
// Stable alpha and size based on weight (no level-based pulsing)
⋮----
// Base grid position
⋮----
// Gentle, eased drift per prompt scaled by driftStrength
const phase = i * 1.37; // unique-ish per index
const driftAmp = 4 * (this.driftStrength || 0); // percent units
⋮----
30, // don't re-render more than once every XXms
⋮----
public async setShowMidi(show: boolean)
⋮----
// Notify listeners (iframe bridge) that inputs are available/updated
⋮----
// Public API used by parent (main app) via postMessage bridge
public getShowMidi(): boolean
public async refreshMidiInputs(): Promise<void>
public getMidiInputs(): string[]
public getActiveMidiInputId(): string | null
public setActiveMidiInputId(id: string)
// Localized placeholder text
private trPlaceholder(): string
private playPause(e: Event)
⋮----
// Prevent the bubbling play-pause event from also reaching outer listeners
⋮----
// Debounce rapid clicks to avoid double toggles
⋮----
// If currently playing or loading: this click means STOP
⋮----
this.optimisticPlaying = false; // pause -> play morph immediately
this.optimisticLoading = false; // ensure spinner is off
⋮----
this.dispatchEvent(new CustomEvent('pause', { bubbles: true })); // explicit pause/stop
⋮----
// If paused/stopped: this click means PLAY
⋮----
this.optimisticLoading = true; // show spinner immediately
this.optimisticPlaying = null; // follow real state for icon
⋮----
public addFilteredPrompt(prompt: string)
public setPromptLabels(labels: string[])
public getPrompts(): Map<string, Prompt>
private addExtraSlot(idx: number)
private addBaseSlot(idx: number)
⋮----
// Always use placeholder text when adding (user deleted the original intentionally)
⋮----
private clearPrompt(promptId: string)
⋮----
// Remove extra prompt and deactivate slot
⋮----
// Remove built-in prompt and mark slot as removed to render add button in-grid
⋮----
public resetAll()
⋮----
// Reset to original base prompts
// BUT maintain the "22 active, 2 empty" rule
⋮----
private formatDuration(sec: number)
private toggleRecording()
⋮----
// Sensitivity threshold bumped to 0.02
⋮----
private toggleMidiPanel()
⋮----
// Reset MIDI state when toggling on to allow retry after denial
⋮----
private handleVolumeChange(e: Event)
⋮----
// 1. IPC to native
⋮----
// 2. Global variable for hooks
⋮----
// 3. Audio tags
⋮----
// 4. Captured AudioContext Gains (from mod.rs hook)
⋮----
// smooth transition
⋮----
protected updated(changedProps: Map<string, any>)
⋮----
// Set drift target based on state and ensure the animation loop is running
⋮----
private ensureDriftLoop()
⋮----
const tick = () =>
⋮----
const dt = Math.max(0, now - this.lastDriftTick) / 1000; // seconds
⋮----
// Approach driftTarget smoothly (exponential smoothing)
const speed = 3.0; // higher = faster return/engage
⋮----
// Force a re-render so gradients animate (uses performance.now in makeBackground)
⋮----
// If we're returning to base and very close, stop the loop; otherwise keep running
⋮----
override render()
private renderPromptWithClear(promptId: string)
private renderPrompts()
⋮----
// Render in base grid order, allowing removed slots to show an add button
</file>

<file path="promptdj-midi/components/react/LoadingIndicator.css">
.loading-indicator {
.loading-indicator-canvas {
</file>

<file path="promptdj-midi/components/react/LoadingIndicator.jsx">
const LoadingIndicator = ({
⋮----
const canvasRef = useRef(null);
const animationRef = useRef(null);
const [isLoaded, setIsLoaded] = useState(false);
// Colors from Figma design - all 4 variants
⋮----
// Container colors
⋮----
const animationState = useRef({
⋮----
const getShapeColor = useCallback(() => {
⋮----
const drawMaterial3Container = useCallback((ctx) => {
⋮----
const canvasSize = Math.round(size * scaleFactor);
⋮----
const radius = Math.min(canvasSize, canvasSize) * 0.45;
ctx.save();
ctx.translate(centerX, centerY);
ctx.beginPath();
ctx.arc(0, 0, radius, 0, 2 * Math.PI);
⋮----
ctx.fill();
ctx.restore();
⋮----
const applyMaterial3ExpressiveEffects = useCallback((ctx) => {
⋮----
const bounce = Math.sin(bouncePhase * Math.PI * 2.5);
⋮----
ctx.rotate((state.rotationAngle * Math.PI) / 180);
⋮----
scaleVariation = 0.015 + Math.sin(state.animationTime * 4) * 0.005;
⋮----
scaleVariation = 0.015 + Math.sin(bouncePhase * Math.PI) * 0.025;
⋮----
syncedScale = baseScale + Math.sin(state.animationTime * 1.2) * 0.05;
⋮----
ctx.scale(syncedScale, syncedScale);
⋮----
state.pulseValue = 0.7 + Math.sin(state.animationTime * 3) * 0.2;
⋮----
const drawPolygonWithEffects = useCallback((polygon, ctx) => {
const color = getShapeColor();
drawPolygon(polygon, color, ctx);
⋮----
const drawCubicsWithEffects = useCallback((cubics, ctx) => {
⋮----
drawCubics(cubics, color, ctx);
⋮----
const drawCurrentShape = useCallback((ctx) => {
⋮----
ctx.clearRect(0, 0, canvasSize, canvasSize);
⋮----
drawMaterial3Container(ctx);
⋮----
ctx.translate(canvasSize / 2, canvasSize / 2);
applyMaterial3ExpressiveEffects(ctx);
⋮----
drawPolygonWithEffects(shape, ctx);
⋮----
const drawMorphedShape = useCallback((ctx) => {
⋮----
const morphedCubics = state.currentMorph.asCubics(state.morphProgress);
drawCubicsWithEffects(morphedCubics, ctx);
⋮----
const drawPolygon = useCallback((polygon, color, ctx) => {
⋮----
drawCubics(polygon.cubics, color, ctx);
⋮----
const drawCubics = useCallback((cubics, color, ctx) => {
⋮----
ctx.moveTo(firstCubic.anchor0X, firstCubic.anchor0Y);
⋮----
ctx.bezierCurveTo(
⋮----
ctx.closePath();
⋮----
const generateRandomShapeOrder = useCallback((shapeCount) => {
const indices = Array.from({ length: shapeCount }, (_, i) => i);
⋮----
const j = Math.floor(Math.random() * (i + 1));
⋮----
const startAnimation = useCallback((ctx, Morph) => {
⋮----
state.shapeOrder = generateRandomShapeOrder(state.morphShapes.length);
⋮----
const animate = () => {
⋮----
state.currentMorph = new Morph(startShape, endShape);
⋮----
morphIncrement = Math.max(morphIncrement, 0.001);
⋮----
drawMorphedShape(ctx);
⋮----
drawCurrentShape(ctx);
⋮----
animationRef.current = requestAnimationFrame(animate);
⋮----
animate();
⋮----
const initializeAnimation = useCallback(async (ctx) => {
⋮----
const [, , { RoundedPolygon }, { Morph }] = await Promise.all([
⋮----
shapes.push(createFallbackShape(i, RoundedPolygon));
⋮----
setIsLoaded(true);
startAnimation(ctx, Morph);
⋮----
console.error('❌ Failed to load REAL animation modules:', error);
setIsLoaded(false);
⋮----
const createFallbackShape = (index, RoundedPolygon) => {
⋮----
case 0: return new RoundedPolygon(new Float32Array([0, -20, 17, 10, -17, 10]), 6);
case 1: return new RoundedPolygon(new Float32Array([-15, -15, 15, -15, 15, 15, -15, 15]), 8);
case 2: return new RoundedPolygon(new Float32Array([0, -17, 16, -5, 10, 14, -10, 14, -16, -5]), 5);
case 3: return createStarPolygon(15, 5, RoundedPolygon);
case 4: return new RoundedPolygon(new Float32Array([20, 0, 10, 17, -10, 17, -20, 0, -10, -17, 10, -17]), 4);
case 5: return createCirclePolygon(15, 8, RoundedPolygon);
case 6: return createStarPolygon(18, 6, RoundedPolygon);
case 7: return createDiamondShape(18, RoundedPolygon);
case 8: return createCrossShape(16, RoundedPolygon);
case 9: return createArrowShape(18, RoundedPolygon);
case 10: return createStarPolygon(14, 4, RoundedPolygon);
case 11: return createOvalShape(18, 12, RoundedPolygon);
case 12: return createTearDropShape(16, RoundedPolygon);
case 13: return createMoonShape(16, RoundedPolygon);
case 14: return createFlowerShape(15, RoundedPolygon);
case 15: return createHouseShape(16, RoundedPolygon);
case 16: return createSpadeShape(16, RoundedPolygon);
case 17: return createInfinityShape(18, RoundedPolygon);
case 18: return createGearShape(16, RoundedPolygon);
case 19: return createSunShape(17, RoundedPolygon);
case 20: return createBoltShape(18, RoundedPolygon);
case 21: return createWaveShape(20, RoundedPolygon);
case 22: return createRingShape(16, RoundedPolygon);
case 23: return createPillShape(18, RoundedPolygon);
case 24: return createBoneShape(18, RoundedPolygon);
case 25: return createMountainShape(14, RoundedPolygon);
case 26: return createFishShape(18, RoundedPolygon);
case 27: return createTreeShape(17, RoundedPolygon);
case 28: return createCactusShape(15, RoundedPolygon);
case 29: return createCupShape(15, RoundedPolygon);
case 30: return createBottleShape(14, RoundedPolygon);
case 31: return createBookShape(16, RoundedPolygon);
case 32: return createPhoneShape(14, RoundedPolygon);
case 33: return createCameraShape(16, RoundedPolygon);
case 34: return createPuzzlePieceShape(16, RoundedPolygon);
case 35: return createAnchorShape(16, RoundedPolygon);
case 36: return createCrownShape(17, RoundedPolygon);
case 37: return createStarPolygon(12, 8, RoundedPolygon);
default: return createCirclePolygon(15, 8, RoundedPolygon);
⋮----
const createCirclePolygon = (radius, sides, RoundedPolygon) => {
const vertices = new Float32Array(sides * 2);
⋮----
vertices[i * 2] = Math.cos(angle) * radius;
vertices[i * 2 + 1] = Math.sin(angle) * radius;
⋮----
return new RoundedPolygon(vertices, 3);
⋮----
const createStarPolygon = (radius, points, RoundedPolygon) => {
const vertices = new Float32Array(points * 4);
⋮----
vertices[vertexIndex++] = Math.cos(outerAngle) * radius;
vertices[vertexIndex++] = Math.sin(outerAngle) * radius;
⋮----
vertices[vertexIndex++] = Math.cos(innerAngle) * innerRadius;
vertices[vertexIndex++] = Math.sin(innerAngle) * innerRadius;
⋮----
return new RoundedPolygon(vertices, 2);
⋮----
const createDiamondShape = (size, RoundedPolygon) => {
const vertices = new Float32Array([0, -size, size, 0, 0, size, -size, 0]);
return new RoundedPolygon(vertices, 4);
⋮----
const createCrossShape = (size, RoundedPolygon) => {
⋮----
const vertices = new Float32Array([
⋮----
const createArrowShape = (size, RoundedPolygon) => {
⋮----
const createOvalShape = (width, height, RoundedPolygon) => {
⋮----
vertices[i * 2] = Math.cos(angle) * width;
vertices[i * 2 + 1] = Math.sin(angle) * height;
⋮----
return new RoundedPolygon(vertices, 1);
⋮----
const createTearDropShape = (size, RoundedPolygon) => {
⋮----
return new RoundedPolygon(vertices, 6);
⋮----
const createMoonShape = (size, RoundedPolygon) => {
⋮----
return new RoundedPolygon(vertices, 5);
⋮----
const createFlowerShape = (size, RoundedPolygon) => {
⋮----
const vertices = new Float32Array(petals * 4);
⋮----
const petalTipX = Math.cos(angle) * size;
const petalTipY = Math.sin(angle) * size;
const petalBaseX = Math.cos(angle) * size * 0.3;
const petalBaseY = Math.sin(angle) * size * 0.3;
⋮----
const createHouseShape = (size, RoundedPolygon) => {
⋮----
const createSpadeShape = (size, RoundedPolygon) => {
⋮----
const createInfinityShape = (size, RoundedPolygon) => {
⋮----
return new RoundedPolygon(vertices, 8);
⋮----
const createGearShape = (size, RoundedPolygon) => {
⋮----
const vertices = new Float32Array(teeth * 4);
⋮----
vertices[vertexIndex++] = Math.cos(baseAngle) * innerRadius;
vertices[vertexIndex++] = Math.sin(baseAngle) * innerRadius;
vertices[vertexIndex++] = Math.cos(toothAngle) * outerRadius;
vertices[vertexIndex++] = Math.sin(toothAngle) * outerRadius;
⋮----
const createSunShape = (size, RoundedPolygon) => {
⋮----
const vertices = new Float32Array(rays * 4);
⋮----
vertices[vertexIndex++] = Math.cos(rayAngle) * outerRadius;
vertices[vertexIndex++] = Math.sin(rayAngle) * outerRadius;
⋮----
const createBoltShape = (size, RoundedPolygon) => {
⋮----
const createLeafShape = (size, RoundedPolygon) => {
⋮----
const createEyeShape = (size, RoundedPolygon) => {
⋮----
const createWaveShape = (size, RoundedPolygon) => {
⋮----
return new RoundedPolygon(vertices, 7);
⋮----
const createRingShape = (size, RoundedPolygon) => {
⋮----
const vertices = new Float32Array((outerSides + innerSides) * 2);
⋮----
vertices[vertexIndex++] = Math.cos(angle) * outerRadius;
vertices[vertexIndex++] = Math.sin(angle) * outerRadius;
⋮----
vertices[vertexIndex++] = Math.cos(angle) * innerRadius;
vertices[vertexIndex++] = Math.sin(angle) * innerRadius;
⋮----
const createCrescentShape = (size, RoundedPolygon) => {
⋮----
const createPillShape = (size, RoundedPolygon) => {
⋮----
const createBoneShape = (size, RoundedPolygon) => {
⋮----
const createKeyShape = (size, RoundedPolygon) => {
⋮----
const createLockShape = (size, RoundedPolygon) => {
⋮----
const createMountainShape = (size, RoundedPolygon) => {
⋮----
const createFishShape = (size, RoundedPolygon) => {
⋮----
const createBirdShape = (size, RoundedPolygon) => {
⋮----
const createTreeShape = (size, RoundedPolygon) => {
⋮----
const createCactusShape = (size, RoundedPolygon) => {
⋮----
const createCupShape = (size, RoundedPolygon) => {
⋮----
const createBottleShape = (size, RoundedPolygon) => {
⋮----
const createBookShape = (size, RoundedPolygon) => {
⋮----
const createPhoneShape = (size, RoundedPolygon) => {
⋮----
const createCameraShape = (size, RoundedPolygon) => {
⋮----
const createPuzzlePieceShape = (size, RoundedPolygon) => {
⋮----
const createRocketShape = (size, RoundedPolygon) => {
⋮----
const createAnchorShape = (size, RoundedPolygon) => {
⋮----
const createCrownShape = (size, RoundedPolygon) => {
⋮----
useEffect(() => {
⋮----
const ctx = canvas.getContext('2d');
⋮----
ctx.scale(dpr, dpr);
initializeAnimation(ctx);
⋮----
cancelAnimationFrame(animationRef.current);
⋮----
const ctx = canvasRef.current.getContext('2d');
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/cubic.js">
export class Cubic {
⋮----
constructor(points = new Float32Array(8), anchor0Y, control0X, control0Y, control1X, control1Y, anchor1X, anchor1Y) {
⋮----
this.points = new Float32Array([
⋮----
throw new Error("Points array size should be 8");
⋮----
this.points = points instanceof Float32Array ? points : new Float32Array(points);
⋮----
get anchor0X() { return this.points[0]; }
get anchor0Y() { return this.points[1]; }
get control0X() { return this.points[2]; }
get control0Y() { return this.points[3]; }
get control1X() { return this.points[4]; }
get control1Y() { return this.points[5]; }
get anchor1X() { return this.points[6]; }
get anchor1Y() { return this.points[7]; }
pointOnCurve(t) {
⋮----
return new Point(
⋮----
zeroLength() {
return Math.abs(this.anchor0X - this.anchor1X) < DistanceEpsilon &&
Math.abs(this.anchor0Y - this.anchor1Y) < DistanceEpsilon;
⋮----
convexTo(next) {
const prevVertex = new Point(this.anchor0X, this.anchor0Y);
const currVertex = new Point(this.anchor1X, this.anchor1Y);
const nextVertex = new Point(next.anchor1X, next.anchor1Y);
return convex(prevVertex, currVertex, nextVertex);
⋮----
zeroIsh(value) {
return Math.abs(value) < DistanceEpsilon;
⋮----
calculateBounds(bounds = new Float32Array(4), approximate = false) {
if (this.zeroLength()) {
⋮----
let minX = Math.min(this.anchor0X, this.anchor1X);
let minY = Math.min(this.anchor0Y, this.anchor1Y);
let maxX = Math.max(this.anchor0X, this.anchor1X);
let maxY = Math.max(this.anchor0Y, this.anchor1Y);
⋮----
bounds[0] = Math.min(minX, this.control0X, this.control1X);
bounds[1] = Math.min(minY, this.control0Y, this.control1Y);
bounds[2] = Math.max(maxX, this.control0X, this.control1X);
bounds[3] = Math.max(maxY, this.control0Y, this.control1Y);
⋮----
if (this.zeroIsh(xa)) {
⋮----
const x = this.pointOnCurve(t).x;
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
⋮----
const sqrtXs = Math.sqrt(xs);
⋮----
const x = this.pointOnCurve(t1).x;
⋮----
const x = this.pointOnCurve(t2).x;
⋮----
if (this.zeroIsh(ya)) {
⋮----
const y = this.pointOnCurve(t).y;
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
⋮----
const sqrtYs = Math.sqrt(ys);
⋮----
const y = this.pointOnCurve(t1).y;
⋮----
const y = this.pointOnCurve(t2).y;
⋮----
split(t) {
⋮----
const p = this.pointOnCurve(t);
const c1 = createCubic(
⋮----
const c2 = createCubic(
⋮----
reverse() {
return createCubic(
⋮----
plus(o) { return new Cubic(this.points.map((p, i) => p + o.points[i])); }
times(x) { return new Cubic(this.points.map(p => p * x)); }
div(x) { return this.times(1 / x); }
toString() {
⋮----
equals(other) {
⋮----
transformed(f) {
const newCubic = new MutableCubic();
newCubic.points.set(this.points);
newCubic.transform(f);
return new Cubic(newCubic.points);
⋮----
static straightLine(x0, y0, x1, y1) {
⋮----
interpolate(x0, x1, 1 / 3), interpolate(y0, y1, 1 / 3),
interpolate(x0, x1, 2 / 3), interpolate(y0, y1, 2 / 3),
⋮----
static circularArc(centerX, centerY, x0, y0, x1, y1) {
const p0d = directionVector(x0 - centerX, y0 - centerY);
const p1d = directionVector(x1 - centerX, y1 - centerY);
const rotatedP0 = p0d.rotate90();
const rotatedP1 = p1d.rotate90();
const clockwise = rotatedP0.dotProduct(x1 - centerX, y1 - centerY) >= 0;
const cosa = p0d.dotProduct(p1d);
if (cosa > 0.999) return Cubic.straightLine(x0, y0, x1, y1);
const k = math_distance(x0 - centerX, y0 - centerY) * 4 / 3 *
(Math.sqrt(2 * (1 - cosa)) - Math.sqrt(1 - cosa * cosa)) / (1 - cosa) *
⋮----
static empty(x0, y0) {
return createCubic(x0, y0, x0, y0, x0, y0, x0, y0);
⋮----
export function createCubic(
⋮----
return new Cubic(new Float32Array([
⋮----
export class MutableCubic extends Cubic {
transformOnePoint(f, ix) {
const result = f.transform(this.points[ix], this.points[ix + 1]);
⋮----
transform(f) {
this.transformOnePoint(f, 0);
this.transformOnePoint(f, 2);
this.transformOnePoint(f, 4);
this.transformOnePoint(f, 6);
⋮----
interpolate(c1, c2, progress) {
⋮----
this.points[i] = interpolate(c1.points[i], c2.points[i], progress);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/featureMapper.js">
export class ProgressableFeature {
⋮----
class DistanceVertex {
⋮----
export function featureMapper(features1, features2) {
⋮----
filteredFeatures1.push(f);
⋮----
filteredFeatures2.push(f);
⋮----
const featureProgressMapping = doMapping(filteredFeatures1, filteredFeatures2);
⋮----
debugLog(LOG_TAG, featureProgressMapping.map(p => `${p.first} -> ${p.second}`).join(', '));
⋮----
const dm = new DoubleMapper(...featureProgressMapping);
⋮----
const toFixed = (n) => n.toFixed(3);
const mapValues = Array.from({ length: N + 1 }, (_, i) => toFixed(dm.map(i / N))).join(', ');
const mapBackValues = Array.from({ length: N + 1 }, (_, i) => toFixed(dm.mapBack(i / N))).join(', ');
debugLog(LOG_TAG, `Map: ${mapValues}\nMb : ${mapBackValues}`);
⋮----
function doMapping(features1, features2) {
⋮----
debugLog(LOG_TAG, `Shape1 progresses: ${features1.map(f => f.progress).join(', ')}`);
debugLog(LOG_TAG, `Shape2 progresses: ${features2.map(f => f.progress).join(', ')}`);
⋮----
const d = featureDistSquared(f1.feature, f2.feature);
⋮----
distanceVertexList.push(new DistanceVertex(d, f1, f2));
⋮----
distanceVertexList.sort((a, b) => a.distance - b.distance);
⋮----
const helper = new MappingHelper();
distanceVertexList.forEach(vertex => helper.addMapping(vertex.f1, vertex.f2));
⋮----
function binarySearchBy(sortedArray, key, selector) {
⋮----
const mid = Math.floor((low + high) / 2);
const midVal = selector(sortedArray[mid]);
⋮----
function progressDistance(p1, p2) {
const d = Math.abs(p1 - p2);
return Math.min(d, 1 - d);
⋮----
function progressInRange(p, start, end) {
⋮----
class MappingHelper {
⋮----
this.usedF1 = new Set();
this.usedF2 = new Set();
⋮----
addMapping(f1, f2) {
if (this.usedF1.has(f1) || this.usedF2.has(f2)) return;
const index = binarySearchBy(this.mapping, f1.progress, item => item.first);
⋮----
progressDistance(f1.progress, before.first) < DistanceEpsilon ||
progressDistance(f1.progress, after.first) < DistanceEpsilon ||
progressDistance(f2.progress, before.second) < DistanceEpsilon ||
progressDistance(f2.progress, after.second) < DistanceEpsilon
⋮----
if (n > 1 && !progressInRange(f2.progress, before.second, after.second)) {
⋮----
this.mapping.splice(insertionIndex, 0, { first: f1.progress, second: f2.progress });
this.usedF1.add(f1);
this.usedF2.add(f2);
⋮----
function featureDistSquared(f1, f2) {
⋮----
if (DEBUG) debugLog(LOG_TAG, "*** Feature distance ∞ for convex-vs-concave corners");
⋮----
const p1 = featureRepresentativePoint(f1);
const p2 = featureRepresentativePoint(f2);
⋮----
function featureRepresentativePoint(feature) {
⋮----
return new Point(x, y);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/floatMapping.js">
export function progressInRange(progress, progressFrom, progressTo) {
⋮----
export function linearMap(xValues, yValues, x) {
if (isNaN(x) || !xValues || !yValues || xValues.length === 0 || yValues.length === 0) {
console.error(`❌ linearMap: Invalid input - x=${x}, xValues=${xValues}, yValues=${yValues}`);
⋮----
if (xValues.some(isNaN) || yValues.some(isNaN)) {
console.error(`❌ linearMap: NaN values in arrays - xValues=${xValues}, yValues=${yValues}`);
⋮----
throw new Error(`Invalid progress: ${x}`);
⋮----
x = Math.max(0, Math.min(1, x));
⋮----
if (progressInRange(x, xValues[i], xValues[(i + 1) % xValues.length])) {
⋮----
const dist = progressDistance(x, xValues[i]);
⋮----
const segmentSizeX = positiveModulo(xValues[segmentEndIndex] - xValues[segmentStartIndex], 1);
const segmentSizeY = positiveModulo(yValues[segmentEndIndex] - yValues[segmentStartIndex], 1);
⋮----
positiveModulo(x - xValues[segmentStartIndex], 1) / segmentSizeX;
return positiveModulo(yValues[segmentStartIndex] + segmentSizeY * positionInSegment, 1);
⋮----
export class DoubleMapper {
⋮----
this.#sourceValues = new Array(mappings.length);
this.#targetValues = new Array(mappings.length);
⋮----
validateProgress(this.#sourceValues);
validateProgress(this.#targetValues);
⋮----
map(x) {
return linearMap(this.#sourceValues, this.#targetValues, x);
⋮----
mapBack(x) {
return linearMap(this.#targetValues, this.#sourceValues, x);
⋮----
static Identity = new DoubleMapper({
⋮----
export function validateProgress(p) {
⋮----
throw new Error(`FloatMapping - Progress outside of range: ${p.join(', ')}`);
⋮----
if (progressDistance(curr, prev) <= DistanceEpsilon) {
throw new Error(`FloatMapping - Progress repeats a value: ${p.join(', ')}`);
⋮----
throw new Error(`FloatMapping - Progress wraps more than once: ${p.join(', ')}`);
⋮----
export function progressDistance(p1, p2) {
const d = Math.abs(p1 - p2);
return Math.min(d, 1 - d);
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/measuredPolygon.js">
export class MeasuredCubic {
⋮----
throw new Error(
⋮----
this.measuredSize = this.#measurer.measureCubic(cubic);
⋮----
updateProgressRange(
⋮----
throw new Error("endOutlineProgress is expected to be equal or greater than startOutlineProgress");
⋮----
cutAtProgress(cutOutlineProgress) {
const boundedCutOutlineProgress = Math.max(
⋮----
Math.min(cutOutlineProgress, this.endOutlineProgress)
⋮----
const t = this.#measurer.findCubicCutPoint(this.cubic, relativeProgress * this.measuredSize);
⋮----
throw new Error(`Cubic cut point ${t} is expected to be between 0 and 1`);
⋮----
debugLog(LOG_TAG,
⋮----
const [c1, c2] = this.cubic.split(t);
⋮----
new MeasuredCubic(c1, this.startOutlineProgress, boundedCutOutlineProgress, this.#measurer),
new MeasuredCubic(c2, boundedCutOutlineProgress, this.endOutlineProgress, this.#measurer)
⋮----
toString() {
⋮----
export class MeasuredPolygon {
⋮----
throw new Error("Outline progress size is expected to be the cubics size + 1");
⋮----
throw new Error("First outline progress value is expected to be zero");
⋮----
if (Math.abs(outlineProgress[outlineProgress.length - 1] - 1.0) > DistanceEpsilon) {
throw new Error("Last outline progress value is expected to be one");
⋮----
debugLog(LOG_TAG, `CTOR: cubics = ${cubics.join(", ")}\nCTOR: op = ${outlineProgress.join(", ")}`);
⋮----
measuredCubics.push(
new MeasuredCubic(
⋮----
measuredCubics[measuredCubics.length - 1].updateProgressRange(undefined, 1.0);
⋮----
cutAndShift(cuttingPoint) {
⋮----
throw new Error("Cutting point is expected to be between 0 and 1");
⋮----
const targetIndex = this.#cubics.findIndex(it =>
⋮----
if (Math.abs(cuttingPoint - 1.0) < DistanceEpsilon) {
⋮----
throw new Error(`Cutting point ${cuttingPoint} not found in any cubic range.`);
⋮----
this.#cubics.forEach((cubic, index) => debugLog(LOG_TAG, `cut&Shift | cubic #${index} : ${cubic} `));
debugLog(LOG_TAG, `cut&Shift, cuttingPoint = ${cuttingPoint}, target = (${targetIndex}) ${target}`);
⋮----
const [b1, b2] = target.cutAtProgress(cuttingPoint);
if (DEBUG) debugLog(LOG_TAG, `Split | ${target} -> ${b1} & ${b2}`);
⋮----
retCubics.push(this.#cubics[(i + targetIndex) % this.#cubics.length].cubic);
⋮----
retCubics.push(b1.cubic);
⋮----
retOutlineProgress.push(
positiveModulo(this.#cubics[cubicIndex].endOutlineProgress - cuttingPoint, 1.0)
⋮----
retOutlineProgress.push(1.0);
const newFeatures = this.features.map(f =>
new ProgressableFeature(
positiveModulo(f.progress - cuttingPoint, 1.0),
⋮----
return new MeasuredPolygon(this.#measurer, newFeatures, retCubics, retOutlineProgress);
⋮----
get size() { return this.#cubics.length; }
get(index) { return this.#cubics[index]; }
⋮----
static measurePolygon(measurer, polygon) {
⋮----
if (feature.isCorner && cubicIndex === Math.floor(feature.cubics.length / 2)) {
featureToCubic.push({ feature, index: cubics.length });
⋮----
cubics.push(feature.cubics[cubicIndex]);
⋮----
const measure = measurer.measureCubic(cubic);
⋮----
throw new Error("Measured cubic is expected to be greater or equal to zero");
⋮----
measures.push(totalMeasure);
⋮----
const outlineProgress = measures.map(m => totalMeasure === 0 ? 0 : m / totalMeasure);
⋮----
if (DEBUG) debugLog(LOG_TAG, `Total size: ${totalMeasure}`);
const features = featureToCubic.map(({ feature, index }) => {
const progress = positiveModulo(
⋮----
return new ProgressableFeature(progress, feature);
⋮----
return new MeasuredPolygon(measurer, features, cubics, outlineProgress);
⋮----
export class Measurer {
measureCubic(c) {
throw new Error("Not implemented");
⋮----
findCubicCutPoint(c, m) {
⋮----
export class LengthMeasurer extends Measurer {
⋮----
let prev = new Point(cubic.anchor0X, cubic.anchor0Y);
⋮----
const point = cubic.pointOnCurve(progress);
const segment = point.minus(prev).getDistance();
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/morph-fixed.js">
export class Morph {
⋮----
this.#morphMatch = Morph.match(start, end);
⋮----
get morphMatch() {
⋮----
bounds(progress) {
⋮----
const points = new Float32Array(8);
⋮----
points[j] = interpolate(pair.first.points[j], pair.second.points[j], progress);
⋮----
minX = Math.min(minX, x);
maxX = Math.max(maxX, x);
minY = Math.min(minY, y);
maxY = Math.max(maxY, y);
⋮----
bounds[3] = Math.max(maxY, bounds[3]);
⋮----
asCubics(progress) {
⋮----
const cubic = new Cubic(points);
⋮----
result.push(lastCubic);
⋮----
result.push(
createCubic(
⋮----
forEachCubic(progress, callback, mutableCubic = new MutableCubic()) {
⋮----
mutableCubic.interpolate(pair.first, pair.second, progress);
callback(mutableCubic);
⋮----
static match(p1, p2) {
const measuredPolygon1 = MeasuredPolygon.measurePolygon(new LengthMeasurer(), p1);
const measuredPolygon2 = MeasuredPolygon.measurePolygon(new LengthMeasurer(), p2);
⋮----
const doubleMapper = featureMapper(features1, features2);
const polygon2CutPoint = doubleMapper.map(0);
if (DEBUG) debugLog(LOG_TAG, `polygon2CutPoint = ${polygon2CutPoint}`);
⋮----
const bs2 = measuredPolygon2.cutAndShift(polygon2CutPoint);
⋮----
const b1 = bs1.get(index);
debugLog(LOG_TAG, `bs1[${index}] = ${b1.startOutlineProgress} .. ${b1.endOutlineProgress}`);
⋮----
const b2 = bs2.get(index);
debugLog(LOG_TAG, `bs2[${index}] = ${b2.startOutlineProgress} .. ${b2.endOutlineProgress}`);
⋮----
let b1 = bs1.get(i1++);
let b2 = bs2.get(i2++);
⋮----
doubleMapper.mapBack(
positiveModulo(b2.endOutlineProgress + polygon2CutPoint, 1.0)
⋮----
const minb = Math.min(b1a, b2a);
if (DEBUG) debugLog(LOG_TAG, `${b1a} ${b2a} | ${minb}`);
⋮----
if (DEBUG) debugLog(LOG_TAG, "Cut 1");
[seg1, newb1] = b1.cutAtProgress(minb);
⋮----
newb1 = bs1.get(i1++);
⋮----
if (DEBUG) debugLog(LOG_TAG, "Cut 2");
[seg2, newb2] = b2.cutAtProgress(
positiveModulo(doubleMapper.map(minb) - polygon2CutPoint, 1.0)
⋮----
newb2 = bs2.get(i2++);
⋮----
ret.push({ first: seg1.cubic, second: seg2.cubic });
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/roundedPolygon.js">
export class Feature {
⋮----
transformed(f) {
throw new Error("Not implemented");
⋮----
Feature.Corner = class Corner extends Feature {
⋮----
return new Feature.Corner(this.cubics.map(c => c.transformed(f)), this.convex);
⋮----
Feature.Edge = class Edge extends Feature {
⋮----
return new Feature.Edge(this.cubics.map(c => c.transformed(f)));
⋮----
export class RoundedPolygon {
⋮----
get centerX() { return this.center.x; }
get centerY() { return this.center.y; }
⋮----
const vertices = verticesFromNumVerts(arg1, radius, centerX, centerY);
⋮----
computeFeaturesFromVertices(vertices, rounding, perVertexRounding, centerX, centerY));
} else if (Array.isArray(arg1) && (arg1.length === 0 || arg1[0] instanceof Feature)) {
⋮----
if (features.length < 2 && features.length > 0) throw new Error("Polygons must have at least 2 features");
⋮----
vertices.push(cubic.anchor0X, cubic.anchor0Y);
⋮----
const calculatedCenter = calculateCenter(vertices);
const cX = !isNaN(centerX) ? centerX : calculatedCenter.x;
const cY = !isNaN(centerY) ? centerY : calculatedCenter.y;
center = new Point(cX, cY);
} else if (arg1 instanceof Float32Array || Array.isArray(arg1)) {
⋮----
computeFeaturesFromVertices(arg1, rounding, perVertexRounding, centerX, centerY));
⋮----
throw new Error("Invalid arguments for RoundedPolygon constructor");
⋮----
cubics.push(new Cubic(new Float32Array([
⋮----
if (!cubic.zeroLength()) {
if (lastCubic) cubics.push(lastCubic);
⋮----
const newPoints = lastCubic.points.slice();
⋮----
lastCubic = new Cubic(newPoints);
⋮----
if (Math.abs(cubic.anchor0X - prevCubic.anchor1X) > DistanceEpsilon ||
Math.abs(cubic.anchor0Y - prevCubic.anchor1Y) > DistanceEpsilon) {
throw new Error(
⋮----
const newCenter = f.transform(this.center.x, this.center.y);
const newFeatures = this.features.map(feat => feat.transformed(f));
return new RoundedPolygon(newFeatures, newCenter.first, newCenter.second);
⋮----
normalized() {
const bounds = this.calculateBounds();
⋮----
const side = Math.max(width, height);
⋮----
return this.transformed((x, y) => ({
⋮----
calculateMaxBounds(bounds = new Float32Array(4)) {
if (bounds.length < 4) throw new Error("Required bounds size of 4");
⋮----
const anchorDistance = distanceSquared(cubic.anchor0X - this.centerX, cubic.anchor0Y - this.centerY);
const middlePoint = cubic.pointOnCurve(0.5);
const middleDistance = distanceSquared(middlePoint.x - this.centerX, middlePoint.y - this.centerY);
maxDistSquared = Math.max(maxDistSquared, anchorDistance, middleDistance);
⋮----
const dist = Math.sqrt(maxDistSquared);
⋮----
calculateBounds(bounds = new Float32Array(4), approximate = true) {
⋮----
const tempBounds = new Float32Array(4);
⋮----
cubic.calculateBounds(tempBounds, approximate);
minX = Math.min(minX, tempBounds[0]);
minY = Math.min(minY, tempBounds[1]);
maxX = Math.max(maxX, tempBounds[2]);
maxY = Math.max(maxY, tempBounds[3]);
⋮----
equals(other) {
⋮----
return JSON.stringify(this.features) === JSON.stringify(other.features);
⋮----
function calculateCenter(vertices) {
⋮----
return new Point(
⋮----
function verticesFromNumVerts(numVertices, radius, centerX, centerY) {
const result = new Float32Array(numVertices * 2);
const centerPoint = new Point(centerX, centerY);
⋮----
const vertex = radialToCartesian(radius, angle).plus(centerPoint);
⋮----
function computeFeaturesFromVertices(vertices, rounding, perVertexRounding, centerX, centerY) {
if (vertices.length < 6) throw new Error("Polygons must have at least 3 vertices");
if (vertices.length % 2 !== 0) throw new Error("The vertices array should have even size");
⋮----
throw new Error("perVertexRounding list size must match the number of vertices");
⋮----
roundedCorners.push(
new RoundedCorner(
new Point(vertices[prevI * 2], vertices[prevI * 2 + 1]),
new Point(vertices[i * 2], vertices[i * 2 + 1]),
new Point(vertices[nextI * 2], vertices[nextI * 2 + 1]),
⋮----
const cutAdjusts = roundedCorners.map((rc, i) => {
⋮----
const sideSize = distance(
⋮----
allowedCuts.push(
⋮----
corners.push(roundedCorners[i].getCubics(allowedCuts[0], allowedCuts[1]));
⋮----
const currVertex = new Point(vertices[i * 2], vertices[i * 2 + 1]);
const prevVertex = new Point(vertices[prevI * 2], vertices[prevI * 2 + 1]);
const nextVertex = new Point(vertices[nextI * 2], vertices[nextI * 2 + 1]);
const isConvex = convex(prevVertex, currVertex, nextVertex);
tempFeatures.push(new Feature.Corner(corners[i], isConvex));
⋮----
tempFeatures.push(new Feature.Edge([
Cubic.straightLine(
⋮----
const center = (isNaN(centerX) || isNaN(centerY)) ?
calculateCenter(vertices) :
new Point(centerX, centerY);
⋮----
class RoundedCorner {
⋮----
const v01 = p0.minus(p1);
const v21 = p2.minus(p1);
const d01 = v01.getDistance();
const d21 = v21.getDistance();
⋮----
this.d1 = v01.times(1 / d01);
this.d2 = v21.times(1 / d21);
⋮----
this.cosAngle = this.d1.dotProduct(this.d2);
this.sinAngle = Math.sqrt(1 - square(this.cosAngle));
⋮----
get expectedCut() {
⋮----
getCubics(allowedCut0, allowedCut1) {
const allowedCut = Math.min(allowedCut0, allowedCut1);
⋮----
return [Cubic.empty(this.p1.x, this.p1.y)];
⋮----
const actualRoundCut = Math.min(allowedCut, this.expectedRoundCut);
⋮----
const centerDistance = Math.sqrt(square(actualR) + square(actualRoundCut));
const center = this.p1.plus(this.d1.plus(this.d2).times(0.5).getDirection().times(centerDistance));
const circleIntersection0 = this.p1.plus(this.d1.times(actualRoundCut));
const circleIntersection2 = this.p1.plus(this.d2.times(actualRoundCut));
⋮----
).reverse();
⋮----
Cubic.circularArc(
⋮----
const sideDirection = sideStart.minus(corner).getDirection();
const curveStart = corner.plus(sideDirection.times(actualRoundCut * (1 + actualSmoothingValue)));
const p = circleSegmentIntersection.times(1 - actualSmoothingValue).plus(
circleSegmentIntersection.plus(otherCircleSegmentIntersection).times(0.5 * actualSmoothingValue)
⋮----
const curveEnd = circleCenter.plus(
directionVector(p.x - circleCenter.x, p.y - circleCenter.y).times(actualR)
⋮----
const circleTangent = curveEnd.minus(circleCenter).rotate90();
const anchorEnd = lineIntersection(sideStart, sideDirection, curveEnd, circleTangent) ||
⋮----
const anchorStart = curveStart.plus(anchorEnd.times(2)).times(1 / 3);
return new Cubic(new Float32Array([
⋮----
function lineIntersection(p0, d0, p1, d1) {
const rotatedD1 = d1.rotate90();
const den = d0.dotProduct(rotatedD1);
if (Math.abs(den) < DistanceEpsilon) return null;
const num = p1.minus(p0).dotProduct(rotatedD1);
if (Math.abs(den) < DistanceEpsilon * Math.abs(num)) return null;
⋮----
return p0.plus(d0.times(k));
</file>

<file path="promptdj-midi/components/react/LoadingIndicator/utils.js">
export class Point {
⋮----
rotate90() {
return new Point(-this.y, this.x);
⋮----
dotProduct(otherX, otherY) {
⋮----
getDistance() {
return Math.sqrt(this.x * this.x + this.y * this.y);
⋮----
plus(other) {
return new Point(this.x + other.x, this.y + other.y);
⋮----
minus(other) {
return new Point(this.x - other.x, this.y - other.y);
⋮----
times(scalar) {
return new Point(this.x * scalar, this.y * scalar);
⋮----
clockwise(other) {
⋮----
add(other) { return this.plus(other); }
subtract(other) { return this.minus(other); }
scale(factor) { return this.times(factor); }
getDirection() {
const d = this.getDistance();
return d > DistanceEpsilon ? this.scale(1 / d) : new Point(0, 0);
⋮----
transformed(f) {
const result = f(this.x, this.y);
return new Point(result.x, result.y);
⋮----
equals(other) {
⋮----
return Math.abs(this.x - other.x) < DistanceEpsilon && Math.abs(this.y - other.y) < DistanceEpsilon;
⋮----
export function distance(x, y) {
return Math.sqrt(x * x + y * y);
⋮----
export function distanceSquared(x, y) {
⋮----
export function directionVector(x, y) {
⋮----
const d = distance(x, y);
⋮----
throw new Error("Required distance greater than zero");
⋮----
return new Point(x / d, y / d);
⋮----
return new Point(Math.cos(angleRadians), Math.sin(angleRadians));
⋮----
export const Zero = new Point(0, 0);
export function radialToCartesian(radius, angleRadians, center = Zero) {
return directionVector(angleRadians).times(radius).plus(center);
⋮----
export function square(x) {
⋮----
export function interpolate(start, stop, fraction) {
⋮----
export function positiveModulo(num, mod) {
⋮----
export function collinearIsh(aX, aY, bX, bY, cX, cY, tolerance = DistanceEpsilon) {
const ab = new Point(bX - aX, bY - aY).rotate90();
const ac = new Point(cX - aX, cY - aY);
const dotProduct = Math.abs(ab.dotProduct(ac));
const relativeTolerance = tolerance * ab.getDistance() * ac.getDistance();
⋮----
export function convex(previous, current, next) {
return current.minus(previous).clockwise(next.minus(current));
⋮----
export function findMinimum(v0, v1, tolerance = 1e-3, f) {
⋮----
if (f(c1) < f(c2)) {
⋮----
export function debugLog(tag, messageFactory) {
⋮----
console.log(`${tag}: ${messageFactory()}`);
</file>

<file path="promptdj-midi/components/react/material-switch.css">
md-switch {
.material-switch-container {
.material-switch-container:has(md-switch[disabled]) {
.material-switch-label {
.material-switch-container:has(md-switch[disabled]) .material-switch-label {
md-switch:focus-visible {
md-switch[icons]:focus-visible svg[slot="on-icon"] {
md-switch[icons]:focus-visible svg[slot="off-icon"] {
md-switch[icons]:focus-visible[selected] svg[slot="on-icon"] {
md-switch[icons]:focus-visible:not([selected]) svg[slot="off-icon"] {
⋮----
.material-switch-compact md-switch {
.material-switch-large md-switch {
md-switch[icons] svg[slot="on-icon"],
md-switch[icons] svg[slot="on-icon"] {
md-switch[icons] svg[slot="off-icon"] {
</file>

<file path="promptdj-midi/components/react/PlayPauseMorphType4.jsx">
function lerpPoints(a, b, t) {
⋮----
const n = Math.min(a.length, b.length);
const out = new Array(n);
⋮----
function splitByLargestJump(points) {
⋮----
const a = points.slice(0, idx);
const b = points.slice(idx);
⋮----
function resamplePoints(points, count) {
⋮----
const res = new Array(count);
⋮----
const i0 = Math.floor(t);
const i1 = Math.min(points.length - 1, i0 + 1);
⋮----
function useSampledPoints(playD, pauseD, samples) {
const playRef = useRef(null);
const pauseRef = useRef(null);
const [playPts, setPlayPts] = useState(null);
const [pausePts, setPausePts] = useState(null);
⋮----
useLayoutEffect(() => {
⋮----
const sample = (pathEl) => {
⋮----
try { len = pathEl.getTotalLength(); } catch { len = 0; }
if (!len || !isFinite(len)) len = 1;
⋮----
const { x, y } = pathEl.getPointAtLength(t);
pts.push([+x, +y]);
⋮----
const pPts = sample(p1);
const qPts = sample(p2);
setPlayPts(pPts);
setPausePts(qPts);
⋮----
function normalizePolygon(points) {
⋮----
const pts = points.slice().map(([x, y]) => ({ x, y, a: Math.atan2(y - cy, x - cx) }));
pts.sort((p, q) => p.a - q.a);
return pts.map(p => [p.x, p.y]);
⋮----
function toCssPolygon(points) {
⋮----
const norm = normalizePolygon(points);
const coords = norm.map(([px, py]) => {
⋮----
return `${x.toFixed(2)}% ${y.toFixed(2)}%`;
⋮----
return `polygon(${coords.join(', ')})`;
⋮----
export default function PlayPauseMorphType4({
⋮----
const [uncontrolledPlaying, setUncontrolledPlaying] = useState(false);
⋮----
const cfg = useMemo(() => ({ ...TYPE4_DEFAULTS, ...(config || {}) }), [config]);
const { hidden, playPts, pausePts } = useSampledPoints(PLAY_D, PAUSE_D, cfg.samples);
const split = useMemo(() => {
⋮----
const qSplit = splitByLargestJump(pausePts);
⋮----
const avgX = (pts) => pts.reduce((sum, p) => sum + p[0], 0) / pts.length;
if (avgX(qA_raw) > avgX(qB_raw)) {
⋮----
playPts.forEach(([x]) => {
⋮----
const pA_raw = playPts.filter(([x]) => x < centerX + overlapWidth);
const pB_raw = playPts.filter(([x]) => x > centerX - overlapWidth);
const perPart = Math.max(20, Math.floor(cfg.samples / 2));
⋮----
playA: resamplePoints(pA_raw, perPart),
playB: resamplePoints(pB_raw, perPart),
pauseA: resamplePoints(qA_raw, perPart),
pauseB: resamplePoints(qB_raw, perPart),
⋮----
const containerRef = useRef(null);
const boxRef1 = useRef(null);
const boxRef2 = useRef(null);
const [ready, setReady] = useState(false);
const animTokenRef = useRef(0);
useEffect(() => { setReady(!!(playPts && pausePts)); }, [playPts, pausePts]);
const handleClick = useCallback(() => {
⋮----
try { onToggle.length > 0 ? onToggle(next) : onToggle(); } catch { onToggle(); }
⋮----
if (!isControlled) setUncontrolledPlaying(next);
⋮----
const pulseAnim = useMemo(() => 'ppm4_pulse_' + Math.random().toString(36).slice(2), []);
useEffect(() => {
const el = document.createElement('style');
el.setAttribute('data-ppm4', pulseAnim);
⋮----
document.head.appendChild(el);
return () => { try { document.head.removeChild(el); } catch(_){} };
⋮----
const anim1Ref = useRef(null);
const anim2Ref = useRef(null);
const animContainerRef = useRef(null);
⋮----
try { animContainerRef.current.cancel(); } catch {}
⋮----
const validParts = parts.filter(p => p.el && typeof p.el.animate === 'function');
⋮----
const startPaths = new Map();
validParts.forEach(({ el, fromPts, lastClipRef }) => {
const cs = getComputedStyle(el);
⋮----
currentClip = lastClipRef.current || toCssPolygon(fromPts);
⋮----
startPaths.set(el, currentClip);
⋮----
validParts.forEach(({ el, animRef }) => {
el.getAnimations?.().forEach(a => a.cancel());
⋮----
try { animRef.current.cancel(); } catch {}
⋮----
animContainerRef.current = containerEl.animate(
⋮----
{ duration: Math.max(250, Math.min(1600, cfg.duration)), easing: cfg.easing, fill: 'forwards' }
⋮----
validParts.forEach(({ fromPts, toPts, el, animRef, lastClipRef }) => {
const fromPath = startPaths.get(el);
const toPath = toCssPolygon(toPts);
⋮----
const overshoot = Math.max(0, Math.min(0.35, cfg.morphOvershoot || 0));
const midOffset = Math.max(0.05, Math.min(0.95, cfg.morphMidOffset || 0.7));
⋮----
frames.push({ clipPath: fromPath, offset: 0 });
⋮----
const midPts = lerpPoints(fromPts, toPts, 1 + overshoot);
const midPath = toCssPolygon(midPts);
⋮----
if (Array.isArray(cfg.keyframeEasings) && cfg.keyframeEasings[0]) midFrame.easing = cfg.keyframeEasings[0];
frames.push(midFrame);
⋮----
if (Array.isArray(cfg.keyframeEasings)) {
⋮----
frames.push(endFrame);
⋮----
const anim = el.animate(frames, { duration: Math.max(250, Math.min(1600, cfg.duration)), easing: cfg.easing, fill: 'forwards' });
⋮----
anim.onfinish = () => {
⋮----
const lastClip1Ref = useRef(null);
const lastClip2Ref = useRef(null);
const defaultStart = useMemo(() => {
⋮----
toCssPolygon(playing ? split.playA : split.pauseA),
toCssPolygon(playing ? split.playB : split.pauseB),
⋮----
return [toCssPolygon(playing ? playPts : pausePts)];
</file>

<file path="promptdj-midi/components/ToastMessage.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
⋮----
export class ToastMessage extends LitElement
⋮----
private renderMessageWithLinks()
override render()
⋮----
show(message: string, duration: number = 4000)
hide()
⋮----
interface HTMLElementTagNameMap {
    'toast-message': ToastMessage
  }
</file>

<file path="promptdj-midi/components/WeightKnob.ts">
import { css, html, LitElement } from 'lit';
import { customElement, property } from 'lit/decorators.js';
import { styleMap } from 'lit/directives/style-map.js';
⋮----
export class WeightKnob extends LitElement
⋮----
constructor()
connectedCallback(): void
disconnectedCallback(): void
private setupDragListeners()
private teardownDragListeners()
private handlePointerDown(e: PointerEvent)
private handlePointerMove(e: PointerEvent)
private endDrag()
private handlePointerUp()
private handlePointerCancel()
private onLostPointerCapture()
private onWindowBlur()
private handleWheel(e: WheelEvent)
private describeArc(
    centerX: number,
    centerY: number,
    startAngle: number,
    endAngle: number,
    radius: number,
): string
override render()
private renderStaticSvg()
⋮----
interface HTMLElementTagNameMap {
    'weight-knob': WeightKnob;
  }
</file>

<file path="promptdj-midi/index.css">
html,
body {
body.dragging {
body.dragging * {
</file>

<file path="promptdj-midi/index.html">
<!doctype html>
<html>
<head>
  <link rel="stylesheet" href="/index.css">
  <link rel="stylesheet"
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
  <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/genai@^1.0.0",
          "lit/": "https://esm.sh/lit@^3.3.0/",
          "lit": "https://esm.sh/lit@^3.3.0"
        }
      }
    </script>
</head>
<body>
  <script type="module" src="/index.tsx"></script>
</body>
</html>
</file>

<file path="promptdj-midi/index.tsx">
import type { PlaybackState, Prompt } from './types';
import { GoogleGenAI, LiveMusicFilteredPrompt } from '@google/genai';
import { PromptDjMidi } from './components/PromptDjMidi';
import { ToastMessage } from './components/ToastMessage';
import { LiveMusicHelper } from './utils/LiveMusicHelper';
import { AudioAnalyser } from './utils/AudioAnalyser';
import { processAudioBlob } from './utils/AudioProcessing';
import { LOCALES, Lang } from './utils/Locales';
⋮----
function main()
⋮----
const attachHelperListeners = () =>
const attachAnalyserListener = () =>
function initWithApiKey(apiKey: string)
function startRecording()
function stopRecording()
function normalizeLang(lang: string | undefined): 'en' | 'ko' | 'vi'
⋮----
function buildInitialPrompts()
</file>

<file path="promptdj-midi/metadata.json">
{
  "name": "PromptDJ MIDI",
  "description": "Control real time music with a MIDI controller.",
  "requestFramePermissions": [],
  "prompt": ""
}
</file>

<file path="promptdj-midi/package.json">
{
  "name": "promptdj-midi",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@google/genai": "^1.0.0",
    "lit": "^3.3.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1"
  },
  "devDependencies": {
    "@types/node": "^22.14.0",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "typescript": "~5.8.2",
    "vite": "^5.4.0"
  }
}
</file>

<file path="promptdj-midi/README.md">
<div align="center">
<img width="1200" height="475" alt="GHBanner" src="https://github.com/user-attachments/assets/0aa67016-6eaf-458a-adb2-6e31a0763ed6" />
</div>

# Run and deploy your AI Studio app

This contains everything you need to run your app locally.

View your app in AI Studio: https://ai.studio/apps/bundled/promptdj-midi

## Run Locally

**Prerequisites:**  Node.js


1. Install dependencies:
   `npm install`
2. Set the `GEMINI_API_KEY` in [.env.local](.env.local) to your Gemini API key
3. Run the app:
   `npm run dev`
</file>

<file path="promptdj-midi/styles/material-tokens.css">
:root {
[data-theme="dark"] {
.md-display-large {
.md-display-medium {
.md-display-small {
.md-headline-large {
.md-headline-medium {
.md-headline-small {
.md-title-large {
.md-title-medium {
.md-title-small {
.md-body-large {
.md-body-medium {
.md-body-small {
.md-label-large {
.md-label-medium {
.md-label-small {
.md-fade-in {
.md-slide-in {
.md-slide-up {
⋮----
.md-button {
.md-button:disabled {
.md-filled-button {
.md-filled-button:hover:not(:disabled) {
.md-filled-button:active:not(:disabled) {
.md-outlined-button {
.md-outlined-button:hover:not(:disabled) {
.md-outlined-button:active:not(:disabled) {
.md-text-button {
.md-text-button:hover:not(:disabled) {
.md-text-button:active:not(:disabled) {
.md-elevated-button {
.md-elevated-button:hover:not(:disabled) {
.md-elevated-button:active:not(:disabled) {
.md-tonal-button {
.md-tonal-button:hover:not(:disabled) {
.md-tonal-button:active:not(:disabled) {
.md-card {
.md-elevated-card {
.md-elevated-card:hover {
.md-filled-card {
.md-outlined-card {
.md-text-field {
.md-text-field-input {
.md-text-field-input:focus {
.md-text-field-input:disabled {
.md-text-field-label {
.md-text-field-error {
</file>

<file path="promptdj-midi/tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "experimentalDecorators": true,
    "useDefineForClassFields": false,
    "module": "ESNext",
    "lib": [
      "ES2022",
      "DOM",
      "DOM.Iterable"
    ],
    "skipLibCheck": true,
    "types": [
      "node"
    ],
    "moduleResolution": "bundler",
    "isolatedModules": true,
    "moduleDetection": "force",
    "allowJs": true,
    "jsx": "react-jsx",
    "paths": {
      "@/*": [
        "./*"
      ]
    },
    "allowImportingTsExtensions": true,
    "noEmit": true
  }
}
</file>

<file path="promptdj-midi/types.ts">
export interface Prompt {
  readonly promptId: string;
  text: string;
  weight: number;
  cc: number;
  color: string;
}
export interface ControlChange {
  channel: number;
  cc: number;
  value: number;
}
export type PlaybackState = 'stopped' | 'playing' | 'loading' | 'paused';
</file>

<file path="promptdj-midi/utils/audio.ts">
import {Blob} from '@google/genai';
function encode(bytes: Uint8Array)
function decode(base64: string)
function createBlob(data: Float32Array): Blob
⋮----
// convert float32 -1 to 1 to int16 -32768 to 32767
⋮----
async function decodeAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number,
  numChannels: number,
): Promise<AudioBuffer>
</file>

<file path="promptdj-midi/utils/AudioAnalyser.ts">
export class AudioAnalyser extends EventTarget
⋮----
constructor(context: AudioContext)
getCurrentLevel()
loop()
⋮----
stop()
</file>

<file path="promptdj-midi/utils/AudioProcessing.ts">
function writeString(view: DataView, offset: number, string: string)
export function audioBufferToWav(buffer: AudioBuffer): Blob
export function trimSilence(buffer: AudioBuffer, threshold = 0.02): AudioBuffer
export async function processAudioBlob(blob: Blob, context: AudioContext): Promise<Blob>
</file>

<file path="promptdj-midi/utils/LiveMusicHelper.ts">
import type { PlaybackState, Prompt } from '../types';
import type { AudioChunk, GoogleGenAI, LiveMusicFilteredPrompt, LiveMusicServerMessage, LiveMusicSession } from '@google/genai';
import { decode, decodeAudioData } from './audio';
import { throttle } from './throttle';
export class LiveMusicHelper extends EventTarget
⋮----
constructor(ai: GoogleGenAI, model: string)
private debug(...args: any[])
private getSession(): Promise<LiveMusicSession>
private async connect(): Promise<LiveMusicSession>
private setPlaybackState(state: PlaybackState)
private async processAudioChunks(audioChunks: AudioChunk[])
public get activePrompts()
⋮----
public async play(resetRetries = true)
public pause()
public stop()
public async playPause()
</file>

<file path="promptdj-midi/utils/Locales.ts">
export type Lang = keyof typeof LOCALES;
</file>

<file path="promptdj-midi/utils/MidiDispatcher.ts">
import type { ControlChange } from '../types';
export class MidiDispatcher extends EventTarget
⋮----
reset()
async getMidiAccess(): Promise<string[]>
getDeviceName(id: string): string | null
</file>

<file path="promptdj-midi/utils/throttle.ts">
export function throttle<T extends (...args: Parameters<T>) => ReturnType<T>>(
  func: T,
  delay: number,
): (...args: Parameters<T>) => ReturnType<T>
</file>

<file path="promptdj-midi/vite.config.ts">
import path from 'path';
import { defineConfig, loadEnv } from 'vite';
</file>

<file path="README.md">
# Screen Goated Toolbox (SGT)

**The Ultimate AI Productivity Automation Tool for Windows.**

Screen Goated Toolbox (SGT) is a native Windows utility that bridges your screen, system audio, and microphone with the world's most powerful AI models. It allows you to create custom AI workflows using a visual node graph to automate tasks like OCR, translation, meeting transcription, generative audio, and text analysis.

## Key Features

### 🧠 Multi-Modal AI Support

* **Cloud Providers:** Native integration with **Groq** (Llama 3, Whisper), **Google Gemini** (Flash, Pro, Gemma), and **OpenRouter** (Claude, GPT-4, DeepSeek).
* **Local AI:** Full support for **Ollama** to run private, local vision and text models without internet.

### ⛓️ Node Graph Workflow

Create complex presets using a visual editor. Connect blocks to define logic:

* **Input:** Screen Region (Snipping), Microphone, System Audio Loopback, Text Selection, or File Drag-and-Drop.
* **Process:** Chain multiple models (e.g., *Speech to Text* -> *Translate* -> *Summarize*).
* **Output:** Streaming Overlay, Markdown View, Text-to-Speech, or Clipboard.

### 🎙️ Audio Intelligence

* **Real-time "Cabin" Mode:** Live, low-latency transcription and translation overlay. Works with **System Audio** (Zoom/Youtube/Games) or **Microphone**.
* **Per-App Capture:** Target audio from specific running applications.
* **PromptDJ:** A dedicated MIDI-controlled interface for generative music and audio control.

### 🛠️ Productivity Tools

* **Smart Overlays:**
  * **Result Overlay:** Interactive window with streaming text, markdown rendering, and "Refine" chat.
  * **Preset Wheel:** A circular menu (`Win+Shift+S` style) to quickly select tools at cursor position.
  * **Favorite Bubble:** A floating dock for instant access to common presets.
* **Text-to-Speech:** High-quality reading using Edge TTS, Gemini Live, or Google Translate.
* **History Gallery:** Auto-saves captures, transcriptions, and generated audio in a searchable database.

## Installation

### Option 1: Download Release

Download the latest `.exe` from the [Releases](https://github.com/nganlinh4/screen-goated-toolbox/releases) page.

* **Standard:** `ScreenGoatedToolbox_v4.0.0.exe` (Compressed, smaller).
* **NoPack:** `..._nopack.exe` (Use this if Windows Defender triggers a false positive).

### Option 2: Build from Source

**Prerequisites:**

* [Rust](https://www.rust-lang.org/) (Nightly toolchain required).
* [Node.js](https://nodejs.org/) (Required for building the PromptDJ frontend).
* **Visual Studio Build Tools 2022** with "Desktop development with C++" workload.

```bash
git clone https://github.com/nganlinh4/screen-goated-toolbox
cd screen-goated-toolbox

# 1. Setup dependencies and patch libraries
powershell -ExecutionPolicy Bypass -File scripts/setup-egui-snarl.ps1

# 2. Build the application (Script handles Frontend build + Rust build + UPX)
powershell -ExecutionPolicy Bypass -File build.ps1
```

The executable will be located in `target/release/`.

### Quick Development Build

To rebuild and run during development (builds PromptDJ frontend, then runs the app):

```powershell
cd promptdj-midi; npm install; npm run build; cd ..; New-Item -ItemType Directory -Path src\overlay\prompt_dj\dist -Force | Out-Null; Copy-Item promptdj-midi\dist\* -Destination src\overlay\prompt_dj\dist -Recurse -Force; cargo run
```

## Getting Started

1. **Launch SGT:** Run the executable.
2. **Global Settings:**
    * Click the **Settings** icon in the sidebar.
    * Enter API Keys for the providers you wish to use (Groq, Gemini, OpenRouter).
    * *(Optional)* Enable **Ollama** if you have it installed locally.
3. **Select a Preset:**
    * Use the sidebar to choose a built-in preset (e.g., "Translate Region", "Transcribe Speech").
    * Assign a **Global Hotkey** (e.g., `Alt+Q`) to the preset.
4. **Usage:**
    * Press your hotkey.
    * **For Image Presets:** Drag to select a screen area.
    * **For Audio Presets:** Recording starts automatically (or opens the Realtime overlay).

## Advanced Configuration

### The Node Graph

SGT v4 uses a node-based system for Presets.

1. **Create Preset:** Click `+` in the sidebar.
2. **Input Node:** Choose "Image", "Audio", or "Text".
3. **Process Node:** Select your AI Model and enter a System Prompt (e.g., "Translate this to Vietnamese").
4. **Connect:** Drag wires between nodes to define the data flow.
5. **Variables:** Use `{language1}` in your prompt to allow dynamic language selection via the UI.

### Real-time Translation (Cabin Mode)

1. Select/Create an **Audio** preset.
2. Set **Processing Mode** to **Realtime (Live)**.
3. Set **Source** to **Device** (System Audio) or **Mic**.
4. Launch the preset. A minimalist overlay will appear showing live subtitles.
5. *Tip:* You can toggle Transcription, Translation, and TTS directly from the overlay.

### Using Local AI (Ollama)

1. Install [Ollama](https://ollama.com/).
2. Pull models: `ollama pull llama3` (text) or `ollama pull moondream` (vision).
3. In SGT **Global Settings**, enable Ollama and set the URL (default: `http://localhost:11434`).
4. In your Preset's **Process Node**, select the model from the "Local" section.

## Troubleshooting

**"NO_API_KEY" Error**

* Go to Global Settings and ensure you have pasted a valid key for the model provider selected in your preset (Groq vs Google vs OpenRouter).

**WebView2 / Blank UI**

* SGT uses Microsoft Edge WebView2 for complex rendering (Markdown, Charts, PromptDJ). Ensure the [WebView2 Runtime](https://developer.microsoft.com/en-us/microsoft-edge/webview2/) is installed on your Windows machine.

**Audio Recording is Silent**

* **Device Audio:** Ensure audio is actually playing through your default output device.
* **Permissions:** Check Windows Privacy settings to ensure the app has access to the Microphone.

**PromptDJ / MIDI Not Working**

* Ensure your MIDI controller is connected *before* launching SGT.
* Click "Refresh Devices" inside the PromptDJ interface.

## License

MIT License — See [LICENSE](LICENSE) file.

## Credits

Developed by **nganlinh4**.

* **UI Framework:** [egui](https://github.com/emilk/egui) & [wry](https://github.com/tauri-apps/wry).
* **Audio:** [cpal](https://github.com/RustAudio/cpal) & [symphonia](https://github.com/pdeljanov/Symphonia).
* **AI Providers:** Groq, Google DeepMind, OpenRouter.
</file>

<file path="scripts/setup-egui-snarl.ps1">
# Setup script for patched egui-snarl
# This clones egui-snarl and patches it for scroll-to-zoom support

$snarlDir = Join-Path $PSScriptRoot "..\libs\egui-snarl"
$patchFile = Join-Path $PSScriptRoot "egui-snarl-scroll-zoom.patch"

# Check if already set up
if (Test-Path $snarlDir) {
    Write-Host "egui-snarl already exists at $snarlDir"
    Write-Host "To re-patch, delete the folder and run this script again."
    exit 0
}

# Clone egui-snarl (latest version)
Write-Host "Cloning egui-snarl..."
git clone --depth 1 https://github.com/zakarumych/egui-snarl.git $snarlDir

if (-not (Test-Path $snarlDir)) {
    Write-Error "Failed to clone egui-snarl"
    exit 1
}

# Apply the patch
Write-Host "Applying scroll-to-zoom patch..."

# Read the ui.rs file
$uiRsPath = Join-Path $snarlDir "src\ui.rs"
$content = Get-Content $uiRsPath -Raw

# The original code we're replacing (Scene::register_pan_and_zoom)
$originalCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    Scene::new()
        .zoom_range(min_scale..=max_scale)
        .register_pan_and_zoom(&ui, &mut snarl_resp, &mut to_global);

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# The patched code (scroll-to-zoom without Ctrl + double-click reset + external reset trigger)
$patchedCode = @"
    clamp_scale(&mut to_global, min_scale, max_scale, ui_rect);

    let mut snarl_resp = ui.response();
    
    // CUSTOM SCROLL-TO-ZOOM: Instead of using Scene::register_pan_and_zoom which uses Ctrl+scroll for zoom,
    // we manually handle scroll as zoom directly (no Ctrl required)
    
    // Disable native double-click centering to prevent it from overriding our custom reset logic
    style.centering = Some(false);

    {
        let scroll_delta = ui.ctx().input(|i| i.raw_scroll_delta);
        let zoom_delta = ui.ctx().input(|i| i.zoom_delta());
        let pointer_in_canvas = ui.ctx().input(|i| {
            i.pointer.hover_pos().map(|pos| ui_rect.contains(pos)).unwrap_or(false)
        });
        
        // Check for external reset request (set by application code via egui context data)
        let reset_id = egui::Id::new("snarl_reset_view");
        let should_reset = ui.ctx().data_mut(|d| {
            let reset = d.get_temp::<bool>(reset_id).unwrap_or(false);
            if reset {
                d.insert_temp(reset_id, false); // Clear the flag
            }
            reset
        });
        
        // Reset view on double-click OR external reset request
        let double_clicked = snarl_resp.double_clicked();
        if (double_clicked && pointer_in_canvas) || should_reset {
            to_global.scaling = 1.0;
            
            // "Fit View" - Center the nodes in the viewport
            let mut min_pos = egui::pos2(f32::INFINITY, f32::INFINITY);
            let mut max_pos = egui::pos2(f32::NEG_INFINITY, f32::NEG_INFINITY);
            let mut has_nodes = false;
            
            for (pos, _) in snarl.nodes_pos() {
                has_nodes = true;
                if pos.x < min_pos.x { min_pos.x = pos.x; }
                if pos.y < min_pos.y { min_pos.y = pos.y; }
                
                // Assume generic node size approx 200x150 for centering
                let right = pos.x + 200.0;
                let bottom = pos.y + 150.0;
                
                if right > max_pos.x { max_pos.x = right; }
                if bottom > max_pos.y { max_pos.y = bottom; }
            }
            
            if has_nodes {
                 let graph_center = min_pos.lerp(max_pos, 0.5);
                 // Center the graph content
                 to_global.translation = ui_rect.center().to_vec2() - graph_center.to_vec2();
            } else {
                 // Fallback if no nodes (center origin logic)
                 to_global.translation = ui_rect.center().to_vec2();
            }
            
            snarl_resp.mark_changed();
        }
        
        // Check if any popup is open (ComboBox dropdowns, context menus, etc.)
        // If a popup is open, we should NOT capture scroll, let the popup handle it
        let any_popup_open = egui::Popup::is_any_open(ui.ctx());
        
        // Check if pointer is over a higher layer (Modal windows, Panels, etc.)
        // Only capture scroll if the pointer is on the Background layer (the canvas itself)
        let pointer_on_foreground = if let Some(pos) = ui.ctx().input(|i| i.pointer.hover_pos()) {
            if let Some(layer_id) = ui.ctx().layer_id_at(pos) {
                // Background order is 0, anything higher means a window/panel/modal is above
                layer_id.order != egui::Order::Background && layer_id.order != egui::Order::Middle
            } else {
                false
            }
        } else {
            false
        };
        
        // Handle scroll wheel as zoom (not pan) - works anywhere in the canvas, including over nodes
        // BUT skip if a popup is open OR pointer is over a modal/window so they can scroll properly
        if scroll_delta.y.abs() > 0.1 && pointer_in_canvas && !any_popup_open && !pointer_on_foreground {
            let zoom_factor = if scroll_delta.y > 0.0 { 1.1 } else { 0.9 };
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            
            // Apply zoom centered on pointer position
            let new_scale = (to_global.scaling * zoom_factor).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                // Zoom towards the pointer: adjust translation so pointer stays at same graph position
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Also handle pinch zoom gestures (zoom_delta from touch)
        if zoom_delta != 1.0 && pointer_in_canvas {
            let pointer_pos = ui.ctx().input(|i| i.pointer.hover_pos()).unwrap_or(ui_rect.center());
            let new_scale = (to_global.scaling * zoom_delta).clamp(min_scale, max_scale);
            if new_scale != to_global.scaling {
                let scale_ratio = new_scale / to_global.scaling;
                to_global.translation = pointer_pos.to_vec2() + (to_global.translation - pointer_pos.to_vec2()) * scale_ratio;
                to_global.scaling = new_scale;
                snarl_resp.mark_changed();
            }
        }
        
        // Handle drag for panning (left mouse button, middle mouse button, or right mouse button)
        if snarl_resp.dragged_by(PointerButton::Primary) || snarl_resp.dragged_by(PointerButton::Middle) || snarl_resp.dragged_by(PointerButton::Secondary) {
            to_global.translation += snarl_resp.drag_delta();
            snarl_resp.mark_changed();
        }
    }

    if snarl_resp.changed() {
        ui.ctx().request_repaint();
    }
"@

# Replace the code
$newContent = $content -replace [regex]::Escape($originalCode), $patchedCode

if ($newContent -eq $content) {
    Write-Warning "Could not find the exact code to patch. egui-snarl may have updated."
    Write-Warning "Please check libs/egui-snarl/src/ui.rs manually around line 989."
    exit 1
}

# Also remove unused Scene import to avoid warning
$newContent = $newContent -replace "Pos2, Rect, Scene, Sense,", "Pos2, Rect, Sense,"

# Write the patched file
Set-Content -Path $uiRsPath -Value $newContent -NoNewline

Write-Host "Patch applied successfully!"
Write-Host "egui-snarl is ready at: $snarlDir"
</file>

<file path="src/api/client.rs">
use lazy_static::lazy_static;
use std::time::Duration;
lazy_static! {
</file>

<file path="src/api/gemini_live/mod.rs">
pub mod manager;
pub mod types;
pub mod websocket;
pub mod worker;
use std::sync::Arc;
pub use manager::GeminiLiveManager;
⋮----
pub fn init_gemini_live() {
⋮----
let manager = GEMINI_LIVE_MANAGER.clone();
⋮----
pub fn gemini_live_generate<F>(
⋮----
(Some((img, mime)), _) => format!("TextWithImage ({}bytes, {})", img.len(), mime),
(None, Some(audio)) => format!("TextWithAudio ({}bytes)", audio.len()),
(None, None) => format!("Text ({}chars)", text.len()),
⋮----
println!("[GeminiLive] gemini_live_generate called: {}", content_type);
println!(
⋮----
if text.trim().is_empty() {
⋮----
let (id, rx) = GEMINI_LIVE_MANAGER.request(content, instruction, show_thinking);
println!("[GeminiLive] Request queued with ID: {}", id);
⋮----
match rx.recv() {
⋮----
println!("[GeminiLive] Event {}: Thinking", event_count);
⋮----
on_chunk(locale.model_thinking);
⋮----
full_content.push_str(&chunk);
let wipe_content = format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
on_chunk(&wipe_content);
⋮----
on_chunk(&chunk);
⋮----
if !streaming_enabled && !full_content.is_empty() {
on_chunk(&full_content);
⋮----
println!("[GeminiLive] Event {}: Error - {}", event_count, e);
if e.contains("NO_API_KEY") {
return Err(anyhow::anyhow!("{}", e));
⋮----
return Err(anyhow::anyhow!("Gemini Live error: {}", e));
⋮----
println!("[GeminiLive] Channel error: {:?}", e);
⋮----
Ok(full_content)
</file>

<file path="src/api/gemini_live/websocket.rs">
use anyhow::Result;
⋮----
use native_tls::TlsStream;
use std::net::TcpStream;
use std::time::Duration;
use tungstenite::WebSocket;
⋮----
pub fn connect_live_websocket(api_key: &str) -> Result<WebSocket<TlsStream<TcpStream>>> {
let ws_url = format!(
⋮----
.host_str()
.ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
⋮----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
⋮----
let tls_stream = connector.connect(host, tcp_stream)?;
⋮----
Ok(socket)
⋮----
pub fn send_live_setup(
⋮----
let final_instruction = if instruction.trim().is_empty() {
speed_instruction.to_string()
⋮----
format!("{} {}", instruction, speed_instruction)
⋮----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str.into()))?;
socket.flush()?;
Ok(())
⋮----
pub fn send_live_content(
⋮----
let b64_image = general_purpose::STANDARD.encode(image_data);
⋮----
let b64_audio = general_purpose::STANDARD.encode(audio_data);
⋮----
socket.write(tungstenite::Message::Text(msg.to_string().into()))?;
⋮----
pub fn parse_live_response(msg: &str) -> (Option<String>, bool, bool) {
⋮----
if let Some(server_content) = json.get("serverContent") {
if let Some(tc) = server_content.get("turnComplete") {
if tc.as_bool().unwrap_or(false) {
⋮----
if let Some(gc) = server_content.get("generationComplete") {
if gc.as_bool().unwrap_or(false) {
⋮----
if let Some(transcription) = server_content.get("outputTranscription") {
if let Some(text) = transcription.get("text").and_then(|t| t.as_str()) {
if !text.chars().all(char::is_whitespace) {
text_chunk = Some(text.to_string());
⋮----
if text_chunk.is_none() {
if let Some(model_turn) = server_content.get("modelTurn") {
if let Some(parts) = model_turn.get("parts").and_then(|p| p.as_array()) {
⋮----
if let Some(text) = part.get("text").and_then(|t| t.as_str()) {
if !text.is_empty() {
⋮----
pub fn is_setup_complete(msg: &str) -> bool {
msg.contains("setupComplete")
⋮----
pub fn parse_error(msg: &str) -> Option<String> {
⋮----
if let Some(error) = json.get("error") {
if let Some(message) = error.get("message").and_then(|m| m.as_str()) {
return Some(message.to_string());
⋮----
return Some(error.to_string());
</file>

<file path="src/api/gemini_live/worker.rs">
use std::sync::atomic::Ordering;
use std::sync::Arc;
⋮----
use tungstenite::Message;
use super::manager::GeminiLiveManager;
use super::types::LiveEvent;
⋮----
use crate::APP;
pub fn run_live_worker(manager: Arc<GeminiLiveManager>) {
⋮----
if manager.shutdown.load(Ordering::SeqCst) {
⋮----
let mut queue = manager.work_queue.lock().unwrap();
while queue.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.work_signal.wait(queue).unwrap();
⋮----
queue.pop_front()
⋮----
if !manager.is_generation_valid(request.generation) {
⋮----
.send(LiveEvent::Error("Request cancelled".to_string()));
⋮----
let api_key = match APP.lock() {
Ok(app) => app.config.gemini_api_key.clone(),
⋮----
.send(LiveEvent::Error("Failed to get config".to_string()));
⋮----
if api_key.trim().is_empty() {
⋮----
.send(LiveEvent::Error("NO_API_KEY:gemini".to_string()));
⋮----
let socket_result = connect_live_websocket(&api_key);
⋮----
.send(LiveEvent::Error(format!("Connection failed: {}", e)));
⋮----
let instruction = if request.req.instruction.trim().is_empty() {
⋮----
Some(request.req.instruction.as_str())
⋮----
if let Err(e) = send_live_setup(&mut socket, instruction, request.req.show_thinking) {
⋮----
.send(LiveEvent::Error(format!("Setup failed: {}", e)));
let _ = socket.close(None);
⋮----
if !manager.is_generation_valid(request.generation)
|| manager.shutdown.load(Ordering::SeqCst)
⋮----
.send(LiveEvent::Error("Cancelled".to_string()));
⋮----
match socket.read() {
⋮----
let msg_str = msg.as_str();
if is_setup_complete(msg_str) {
⋮----
if let Some(error) = parse_error(msg_str) {
let _ = request.response_tx.send(LiveEvent::Error(error));
⋮----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if is_setup_complete(&text) {
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock =>
⋮----
if setup_start.elapsed() > Duration::from_secs(15) {
⋮----
.send(LiveEvent::Error("Setup timeout".to_string()));
⋮----
.send(LiveEvent::Error(format!("Setup error: {}", e)));
⋮----
if let Err(e) = send_live_content(&mut socket, &request.req.content) {
⋮----
.send(LiveEvent::Error(format!("Send failed: {}", e)));
⋮----
let (text_chunk, is_thought, is_turn_complete) = parse_live_response(msg_str);
⋮----
let _ = request.response_tx.send(LiveEvent::Thinking);
⋮----
let _ = request.response_tx.send(LiveEvent::TextChunk(text));
⋮----
let _ = request.response_tx.send(LiveEvent::TurnComplete);
⋮----
let (text_chunk, is_thought, is_turn_complete) = parse_live_response(&text);
⋮----
let _ = request.response_tx.send(LiveEvent::TextChunk(chunk));
⋮----
.send(LiveEvent::Error(format!("Read error: {}", e)));
</file>

<file path="src/api/mod.rs">
pub mod audio;
pub mod client;
pub mod gemini_live;
pub mod ollama;
pub mod realtime_audio;
pub mod text;
pub mod tts;
pub mod types;
pub mod vision;
pub use audio::record_and_stream_gemini_live;
pub use audio::record_audio_and_transcribe;
⋮----
pub use vision::translate_image_streaming;
</file>

<file path="src/api/ollama.rs">
use anyhow::Result;
⋮----
use serde::Deserialize;
use super::client::UREQ_AGENT;
use crate::gui::locale::LocaleText;
⋮----
pub struct OllamaStreamChunk {
⋮----
pub struct OllamaGenerateResponse {
⋮----
pub struct OllamaModel {
⋮----
pub struct OllamaTagsResponse {
⋮----
pub struct OllamaModelWithCaps {
⋮----
struct OllamaShowResponse {
⋮----
struct OllamaModelDetails {
⋮----
pub fn fetch_ollama_models(base_url: &str) -> Result<Vec<OllamaModel>> {
let url = format!("{}/api/tags", base_url.trim_end_matches('/'));
let resp = UREQ_AGENT.get(&url)
.call()
.map_err(|e| anyhow::anyhow!("Failed to connect to Ollama: {}", e))?;
let tags: OllamaTagsResponse = resp.into_body().read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse Ollama response: {}", e))?;
Ok(tags.models)
⋮----
fn check_model_has_vision(base_url: &str, model_name: &str) -> bool {
let url = format!("{}/api/show", base_url.trim_end_matches('/'));
⋮----
let resp = match UREQ_AGENT.post(&url)
.send_json(&payload) {
⋮----
if let Ok(show_resp) = resp.into_body().read_json::<OllamaShowResponse>() {
let families_str = show_resp.details.families.join(" ").to_lowercase();
if families_str.contains("clip") || families_str.contains("vision") {
⋮----
let modelfile_lower = show_resp.modelfile.to_lowercase();
if modelfile_lower.contains("projector") || modelfile_lower.contains("vision") {
⋮----
let name_lower = model_name.to_lowercase();
if name_lower.contains("vision") || name_lower.contains("-vl") ||
name_lower.contains("llava") || name_lower.contains("bakllava") ||
name_lower.contains("moondream") || name_lower.contains("minicpm-v") {
⋮----
pub fn fetch_ollama_models_with_caps(base_url: &str) -> Result<Vec<OllamaModelWithCaps>> {
let models = fetch_ollama_models(base_url)?;
⋮----
let has_vision = check_model_has_vision(base_url, &model.name);
result.push(OllamaModelWithCaps {
⋮----
Ok(result)
⋮----
pub fn ollama_generate_text<F>(
⋮----
let url = format!("{}/api/generate", base_url.trim_end_matches('/'));
⋮----
let resp = UREQ_AGENT.post(&url)
.send_json(&payload)
.map_err(|e| anyhow::anyhow!("Ollama API Error: {}", e))?;
⋮----
let reader = BufReader::new(resp.into_body().into_reader());
⋮----
for line in reader.lines() {
⋮----
if line.is_empty() { continue; }
⋮----
if !thinking.is_empty() && !thinking_shown && !content_started {
on_chunk(locale.model_thinking);
⋮----
if !chunk.response.is_empty() {
⋮----
full_content.push_str(&chunk.response);
let wipe_content = format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
on_chunk(&wipe_content);
⋮----
on_chunk(&chunk.response);
⋮----
let ollama_resp: OllamaGenerateResponse = resp.into_body().read_json()
⋮----
on_chunk(&full_content);
⋮----
Ok(full_content)
⋮----
pub fn ollama_generate_vision<F>(
⋮----
image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
let b64_image = general_purpose::STANDARD.encode(&image_data);
⋮----
.map_err(|e| anyhow::anyhow!("Ollama Vision API Error: {}", e))?;
</file>

<file path="src/api/realtime_audio/capture.rs">
use anyhow::Result;
⋮----
use std::time::Duration;
use super::REALTIME_RMS;
⋮----
pub fn start_per_app_capture(
⋮----
use std::collections::VecDeque;
⋮----
if wasapi::initialize_mta().is_err() {
eprintln!("Per-app capture: Failed to initialize MTA");
⋮----
eprintln!(
⋮----
if let Err(e) = audio_client.initialize_client(&desired_format, &Direction::Capture, &mode)
⋮----
eprintln!("Hint: Per-app capture requires Windows 10 version 1903 or later");
⋮----
let capture_client = match audio_client.get_audiocaptureclient() {
⋮----
eprintln!("Per-app capture: Failed to get capture client: {:?}", e);
⋮----
let event_handle = match audio_client.set_get_eventhandle() {
⋮----
eprintln!("Per-app capture: Failed to get event handle: {:?}", e);
⋮----
if let Err(e) = audio_client.start_stream() {
eprintln!("Per-app capture: Failed to start stream: {:?}", e);
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if pause_signal.load(Ordering::Relaxed) {
⋮----
if event_handle.wait_for_event(100).is_err() {
⋮----
match capture_client.read_from_device_to_deque(&mut capture_buffer) {
⋮----
if !capture_buffer.is_empty() {
⋮----
let sample_count = capture_buffer.len() / bytes_per_sample;
⋮----
while capture_buffer.len() >= bytes_per_sample {
let low = capture_buffer.pop_front().unwrap_or(0);
let high = capture_buffer.pop_front().unwrap_or(0);
⋮----
samples.push(sample);
⋮----
if let Ok(mut buf) = audio_buffer.lock() {
buf.extend(&samples);
⋮----
if !samples.is_empty() {
⋮----
samples.iter().map(|&s| (s as f64 / 32768.0).powi(2)).sum();
let rms = (sum_sq / samples.len() as f64).sqrt() as f32;
REALTIME_RMS.store(rms.to_bits(), Ordering::Relaxed);
⋮----
eprintln!("Per-app capture: Read error: {:?}", e);
⋮----
let _ = audio_client.stop_stream();
⋮----
Ok(())
⋮----
pub fn start_device_loopback_capture(
⋮----
let host = cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host());
⋮----
.default_output_device()
.ok_or_else(|| anyhow::anyhow!("No output device available"))?;
let config = device.default_output_config()?;
let sample_rate = config.sample_rate();
let channels = config.channels() as usize;
let audio_buffer_clone = audio_buffer.clone();
⋮----
let stop_signal_audio = stop_signal.clone();
let pause_signal_audio = pause_signal.clone();
let err_fn = |err| eprintln!("Audio stream error: {}", err);
let stream = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
⋮----
if stop_signal_audio.load(Ordering::Relaxed)
|| pause_signal_audio.load(Ordering::Relaxed)
⋮----
.chunks(channels)
.map(|frame| {
let sum: f32 = frame.iter().sum();
⋮----
(avg.clamp(-1.0, 1.0) * i16::MAX as f32) as i16
⋮----
.collect();
⋮----
let new_len = (mono_samples.len() as f64 * resample_ratio) as usize;
⋮----
.map(|i| {
⋮----
let idx1 = (idx0 + 1).min(mono_samples.len() - 1);
⋮----
.collect()
⋮----
if let Ok(mut buf) = audio_buffer_clone.lock() {
buf.extend(resampled.iter().cloned());
⋮----
if !resampled.is_empty() {
⋮----
.iter()
.map(|&s| (s as f64 / 32768.0).powi(2))
.sum();
let rms = (sum_sq / resampled.len() as f64).sqrt() as f32;
⋮----
cpal::SampleFormat::I16 => device.build_input_stream(
⋮----
let sum: i32 = frame.iter().map(|&s| s as i32).sum();
⋮----
_ => return Err(anyhow::anyhow!("Unsupported audio format")),
⋮----
stream.play()?;
Ok(stream)
⋮----
pub fn start_mic_capture(
⋮----
.default_input_device()
.ok_or_else(|| anyhow::anyhow!("No microphone available. Please connect a microphone."))?;
let config = device.default_input_config()?;
</file>

<file path="src/api/realtime_audio/model_loader.rs">
use std::fs;
use std::io::Read;
⋮----
pub fn download_file(
⋮----
if path.exists() {
return Ok(());
⋮----
if let Some(parent) = path.parent() {
⋮----
use std::io::Write;
println!("Downloading file from: {}", url);
⋮----
.header("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")
.call()
.map_err(|e| anyhow!("Download failed: {}", e))?;
⋮----
.headers()
.get("content-length")
.and_then(|h| h.to_str().ok())
.and_then(|s| s.parse::<u64>().ok())
.unwrap_or(0);
let mut reader = response.into_body().into_reader();
⋮----
if stop_signal.load(std::sync::atomic::Ordering::Relaxed) {
⋮----
return Err(anyhow!("Download cancelled"));
⋮----
let bytes_read = reader.read(&mut buffer)?;
⋮----
file.write_all(&buffer[..bytes_read])?;
⋮----
if total_size > 0 && last_update.elapsed() >= update_interval {
⋮----
let msg = format!("Downloading... {:.0}%", progress);
⋮----
use crate::overlay::realtime_webview::state::REALTIME_STATE;
if let Ok(mut state) = REALTIME_STATE.lock() {
⋮----
use super::WM_DOWNLOAD_PROGRESS;
use crate::overlay::realtime_webview::state::REALTIME_HWND;
⋮----
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
Ok(())
⋮----
pub fn get_parakeet_model_dir() -> PathBuf {
⋮----
.unwrap_or_else(|| PathBuf::from("."))
.join("screen-goated-toolbox")
.join("models")
.join("parakeet")
⋮----
pub fn is_model_downloaded() -> bool {
let dir = get_parakeet_model_dir();
dir.join("encoder.onnx").exists()
&& dir.join("decoder_joint.onnx").exists()
&& dir.join("tokenizer.json").exists()
⋮----
pub fn download_parakeet_model(
⋮----
let app = crate::APP.lock().unwrap();
⋮----
state.download_title = locale.parakeet_downloading_title.to_string();
state.download_message = locale.parakeet_downloading_message.to_string();
⋮----
println!("Parakeet model not found, starting download. Modal should appear now...");
⋮----
let files_to_download = vec![
⋮----
state.download_message = locale.parakeet_downloading_file.replace("{}", filename);
⋮----
download_file(url, &dir.join(filename), &stop_signal, use_badge)?;
</file>

<file path="src/api/realtime_audio/parakeet.rs">
use crate::config::Preset;
use anyhow::Result;
⋮----
use windows::Win32::Foundation::HWND;
use windows::Win32::Foundation::LPARAM;
use windows::Win32::Foundation::WPARAM;
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
⋮----
use crate::overlay::realtime_webview::AUDIO_SOURCE_CHANGE;
⋮----
pub fn run_parakeet_transcription(
⋮----
if let Ok(mut s) = state.lock() {
s.set_transcription_method(TranscriptionMethod::Parakeet);
⋮----
run_parakeet_session(
stop_signal.clone(),
⋮----
s.append_transcript(&text);
⋮----
if !h.is_invalid() {
let _ = PostMessageW(Some(h), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
pub fn run_parakeet_session<F>(
⋮----
match super::model_loader::download_parakeet_model(stop_signal.clone(), use_badge) {
⋮----
let err_msg = e.to_string();
if err_msg.contains("cancelled") || stop_signal.load(Ordering::Relaxed) {
println!("Parakeet download was cancelled by user");
return Ok(());
⋮----
return Err(e);
⋮----
if stop_signal.load(Ordering::Relaxed) {
⋮----
let config = ExecutionConfig::new().with_execution_provider(ExecutionProvider::DirectML);
let mut parakeet = ParakeetEOU::from_pretrained(&model_dir, Some(config))
.map_err(|e| anyhow::anyhow!("Failed to load Parakeet model: {:?}", e))?;
⋮----
let app = crate::APP.lock().unwrap();
(app.config.realtime_audio_source.clone(), true)
⋮----
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
let selected_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
⋮----
audio_buffer.clone(),
⋮----
pause_signal.clone(),
⋮----
Some(super::capture::start_mic_capture(
⋮----
Some(super::capture::start_device_loopback_capture(
⋮----
while !stop_signal.load(Ordering::Relaxed) {
⋮----
!windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(hwnd)).as_bool()
⋮----
if pause_signal.load(Ordering::Relaxed) {
⋮----
if AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst)
|| crate::overlay::realtime_webview::TRANSCRIPTION_MODEL_CHANGE.load(Ordering::SeqCst)
⋮----
let mut buf = audio_buffer.lock().unwrap();
if !buf.is_empty() {
buf.drain(..).map(|s| s as f32 / 32768.0).collect()
⋮----
if !new_samples.is_empty() {
let sum_sq: f64 = new_samples.iter().map(|&s| (s as f64).powi(2)).sum();
let rms = (sum_sq / new_samples.len() as f64).sqrt() as f32;
REALTIME_RMS.store(rms.to_bits(), Ordering::Relaxed);
⋮----
crate::overlay::recording::AUDIO_WARMUP_COMPLETE.store(true, Ordering::SeqCst);
⋮----
first_speech = Some(std::time::Instant::now());
⋮----
if last_active.elapsed().as_millis() > 800
&& start.elapsed().as_millis() > 2000
⋮----
stop_signal.store(true, Ordering::SeqCst);
⋮----
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_VOLUME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
if let Ok(mut full) = full_buf.lock() {
full.extend(new_samples.iter().map(|&s| (s * 32768.0) as i16));
⋮----
sample_accumulator.extend(new_samples);
⋮----
while sample_accumulator.len() >= CHUNK_SIZE {
let chunk: Vec<f32> = sample_accumulator.drain(..CHUNK_SIZE).collect();
match parakeet.transcribe(&chunk, false) {
⋮----
if !text.is_empty() {
let processed = process_sentencepiece_text(&text);
if !processed.is_empty() {
callback(processed);
⋮----
eprintln!("Parakeet transcription error: {:?}", e);
⋮----
let silence = vec![0.0f32; CHUNK_SIZE];
⋮----
if let Ok(text) = parakeet.transcribe(&silence, false) {
⋮----
Ok(())
⋮----
fn process_sentencepiece_text(text: &str) -> String {
let starts_with_word = text.starts_with('\u{2581}') || text.starts_with('▁');
let processed = text.replace('\u{2581}', " ").replace('▁', " ");
let processed = processed.trim();
if processed.is_empty() {
⋮----
format!(" {}", processed)
⋮----
processed.to_string()
</file>

<file path="src/api/realtime_audio/transcription.rs">
use anyhow::Result;
⋮----
use crate::config::Preset;
use crate::overlay::realtime_webview::SELECTED_APP_PID;
use crate::APP;
⋮----
use super::state::SharedRealtimeState;
use super::translation::run_translation_loop;
use super::utils::update_overlay_text;
⋮----
enum AudioMode {
⋮----
pub fn start_realtime_transcription(
⋮----
let translation_send = translation_hwnd.map(crate::win_types::SendHwnd);
let has_translation = translation_hwnd.is_some() && preset.blocks.len() > 1;
⋮----
let t_send = translation_send.clone().unwrap();
let t_state = state.clone();
let t_stop = stop_signal.clone();
let t_preset = preset.clone();
⋮----
run_translation_loop(t_preset, t_stop, t_send, t_state);
⋮----
transcription_thread_entry(preset, stop_signal, overlay_send, translation_send, state);
⋮----
fn transcription_thread_entry(
⋮----
let hwnd_translation = translation_send.map(|h| h.0);
⋮----
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
TRANSCRIPTION_MODEL_CHANGE.store(false, Ordering::SeqCst);
REALTIME_RMS.store(0, Ordering::SeqCst);
⋮----
let app = APP.lock().unwrap();
app.config.realtime_transcription_model.clone()
⋮----
if let Ok(mut s) = state.lock() {
⋮----
s.set_transcription_method(super::state::TranscriptionMethod::Parakeet);
⋮----
s.set_transcription_method(super::state::TranscriptionMethod::GeminiLive);
⋮----
current_preset.clone(),
stop_signal.clone(),
⋮----
Some(hwnd_overlay),
state.clone(),
⋮----
run_realtime_transcription(
⋮----
let is_user_initiated = AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst)
|| TRANSCRIPTION_MODEL_CHANGE.load(Ordering::SeqCst)
|| stop_signal.load(Ordering::Relaxed);
⋮----
let err_msg = format!(" [Error: {}]", e);
eprintln!("Realtime transcription error: {}", e);
⋮----
s.append_transcript(&err_msg);
⋮----
let display_text = if let Ok(s) = state.lock() {
s.display_transcript.clone()
⋮----
update_overlay_text(hwnd_overlay, &display_text);
⋮----
let restart_source = AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst);
let restart_model = TRANSCRIPTION_MODEL_CHANGE.load(Ordering::SeqCst);
⋮----
if let Ok(new_source) = NEW_AUDIO_SOURCE.lock() {
if !new_source.is_empty() {
let mut app = APP.lock().unwrap();
app.config.realtime_audio_source = new_source.clone();
current_preset.audio_source = new_source.clone();
⋮----
if let Ok(new_model) = NEW_TRANSCRIPTION_MODEL.lock() {
if !new_model.is_empty() {
⋮----
app.config.realtime_transcription_model = new_model.clone();
⋮----
stop_signal.store(false, Ordering::SeqCst);
⋮----
if !restart_source && !restart_model && stop_signal.load(Ordering::Relaxed) {
⋮----
fn run_realtime_transcription(
⋮----
app.config.gemini_api_key.clone()
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
⋮----
let mut socket = connect_websocket(&gemini_api_key)?;
send_setup_message(&mut socket)?;
⋮----
set_socket_short_timeout(&mut socket)?;
⋮----
match socket.read() {
⋮----
let msg = msg.as_str();
if msg.contains("setupComplete") {
⋮----
if msg.contains("error") || msg.contains("Error") {
return Err(anyhow::anyhow!("Server returned error: {}", msg));
⋮----
.map(|f| format!("code={}, reason={}", f.code, f.reason))
.unwrap_or("no frame".to_string());
return Err(anyhow::anyhow!(
⋮----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if text.contains("setupComplete") {
⋮----
} else if data.len() < 100 {
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock
|| e.kind() == std::io::ErrorKind::TimedOut =>
⋮----
if setup_start.elapsed() > Duration::from_secs(30) {
return Err(anyhow::anyhow!("Setup timeout - no response from server"));
⋮----
return Err(e.into());
⋮----
if stop_signal.load(Ordering::Relaxed) {
return Ok(());
⋮----
if TRANSCRIPTION_MODEL_CHANGE.load(Ordering::SeqCst)
|| AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst)
⋮----
set_socket_nonblocking(&mut socket)?;
⋮----
use crate::overlay::realtime_webview::REALTIME_TTS_ENABLED;
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
let selected_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
⋮----
start_per_app_capture(
⋮----
audio_buffer.clone(),
⋮----
dummy_pause.clone(),
⋮----
_stream = Some(start_device_loopback_capture(
⋮----
_stream = Some(start_mic_capture(
⋮----
run_main_loop(
⋮----
drop(_stream);
Ok(())
⋮----
fn run_main_loop(
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if overlay_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
stop_signal.store(true, Ordering::SeqCst);
⋮----
if AUDIO_SOURCE_CHANGE.load(Ordering::SeqCst)
⋮----
if mode_start.elapsed() >= NORMAL_DURATION {
⋮----
silence_buffer.clear();
⋮----
if mode_start.elapsed() >= SILENCE_DURATION {
⋮----
if silence_buffer.is_empty() {
⋮----
if last_send.elapsed() >= send_interval {
⋮----
let mut buf = audio_buffer.lock().unwrap();
⋮----
if !real_audio.is_empty() {
if send_audio_chunk(&mut socket, &real_audio).is_err() {
⋮----
silence_buffer.extend(real_audio);
let silence: Vec<i16> = vec![0i16; SAMPLES_PER_100MS];
if send_audio_chunk(&mut socket, &silence).is_err() {
⋮----
let to_send: Vec<i16> = if silence_buffer.len() >= chunk_size {
silence_buffer.drain(..chunk_size).collect()
} else if !silence_buffer.is_empty() {
silence_buffer.drain(..).collect()
⋮----
if !to_send.is_empty() {
if send_audio_chunk(&mut socket, &to_send).is_err() {
⋮----
let _ = PostMessageW(Some(overlay_hwnd), WM_VOLUME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
if let Some(transcript) = parse_input_transcription(msg) {
if !transcript.is_empty() {
⋮----
let display_text = if let Ok(mut s) = state.lock() {
s.append_transcript(&transcript);
⋮----
if !display_text.is_empty() {
update_overlay_text(overlay_hwnd, &display_text);
⋮----
if let Some(transcript) = parse_input_transcription(&text) {
⋮----
if !try_reconnect(
⋮----
&& last_transcription_time.elapsed()
⋮----
let error_str = e.to_string();
if error_str.contains("reset")
|| error_str.contains("closed")
|| error_str.contains("broken")
⋮----
let _ = socket.close(None);
⋮----
fn try_reconnect(
⋮----
reconnect_buffer.extend(std::mem::take(&mut *buf));
⋮----
match connect_websocket(api_key) {
⋮----
if send_setup_message(&mut new_socket).is_err() {
⋮----
if set_socket_nonblocking(&mut new_socket).is_err() {
⋮----
silence_buffer.extend(reconnect_buffer);
</file>

<file path="src/api/realtime_audio/utils.rs">
use std::sync::Mutex;
⋮----
pub fn update_overlay_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = REALTIME_DISPLAY_TEXT.lock() {
*display = text.to_string();
⋮----
let _ = PostMessageW(Some(hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
pub fn update_translation_text(hwnd: HWND, text: &str) {
if let Ok(mut display) = TRANSLATION_DISPLAY_TEXT.lock() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_TRANSLATION_UPDATE, WPARAM(0), LPARAM(0));
⋮----
pub fn refresh_transcription_window() {
⋮----
if !realtime_hwnd.is_invalid() {
let _ = PostMessageW(Some(realtime_hwnd), WM_REALTIME_UPDATE, WPARAM(0), LPARAM(0));
</file>

<file path="src/api/realtime_audio/websocket.rs">
use anyhow::Result;
⋮----
use std::net::TcpStream;
use std::time::Duration;
use super::REALTIME_MODEL;
pub fn connect_websocket(
⋮----
let ws_url = format!(
⋮----
.host_str()
.ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
⋮----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
⋮----
let tls_stream = connector.connect(host, tcp_stream)?;
⋮----
Ok(socket)
⋮----
pub fn set_socket_nonblocking(
⋮----
let stream = socket.get_mut();
let tcp_stream = stream.get_mut();
tcp_stream.set_read_timeout(Some(Duration::from_millis(50)))?;
Ok(())
⋮----
pub fn set_socket_short_timeout(
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_millis(200)))?;
⋮----
pub fn send_setup_message(
⋮----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str.into()))?;
socket.flush()?;
⋮----
pub fn send_audio_chunk(
⋮----
let mut bytes = Vec::with_capacity(pcm_data.len() * 2);
⋮----
bytes.extend_from_slice(&sample.to_le_bytes());
⋮----
let b64_audio = general_purpose::STANDARD.encode(&bytes);
⋮----
socket.write(tungstenite::Message::Text(msg.to_string().into()))?;
⋮----
pub fn parse_input_transcription(msg: &str) -> Option<String> {
⋮----
if let Some(server_content) = json.get("serverContent") {
if let Some(input_transcription) = server_content.get("inputTranscription") {
if let Some(text) = input_transcription.get("text").and_then(|t| t.as_str()) {
return Some(text.to_string());
</file>

<file path="src/api/text.rs">
use super::client::UREQ_AGENT;
⋮----
use crate::gui::locale::LocaleText;
use crate::overlay::result::RefineContext;
use crate::overlay::utils::get_context_quote;
use crate::APP;
use anyhow::Result;
⋮----
pub fn translate_text_streaming<F>(
⋮----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
⋮----
Some(config.openrouter_api_key.clone())
⋮----
.unwrap_or_default();
⋮----
if config.cerebras_api_key.is_empty() {
⋮----
Some(config.cerebras_api_key.clone())
⋮----
let prompt = format!("{}\n\n{}", instruction, text);
⋮----
.map(|app| {
⋮----
config.ollama_base_url.clone(),
config.ollama_text_model.clone(),
⋮----
.unwrap_or_else(|| ("http://localhost:11434".to_string(), model.clone()));
let actual_model = if ollama_text_model.is_empty() {
model.clone()
⋮----
.to_lowercase()
.split("translate to ")
.nth(1)
.and_then(|s| s.split('.').next())
.and_then(|s| s.split(',').next())
.map(|s| s.trim().to_string())
.unwrap_or_else(|| "English".to_string());
⋮----
.chars()
.enumerate()
.map(|(i, c)| {
⋮----
c.to_uppercase().next().unwrap_or(c)
⋮----
on_chunk(&translated);
return Ok(translated);
⋮----
return Err(anyhow::anyhow!("GTX translation failed"));
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
⋮----
format!(
⋮----
let supports_thinking = (model.contains("gemini-2.5-flash") && !model.contains("lite"))
|| model.contains("gemini-3-flash-preview")
|| model.contains("gemini-robotics");
⋮----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_body().into_reader());
⋮----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
chunk_resp.get("candidates").and_then(|c| c.as_array())
⋮----
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
⋮----
part.get("text").and_then(|t| t.as_str())
⋮----
on_chunk(locale.model_thinking);
⋮----
full_content.push_str(text);
let wipe_content = format!(
⋮----
on_chunk(&wipe_content);
⋮----
on_chunk(text);
⋮----
.into_body()
.read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
⋮----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
⋮----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
⋮----
on_chunk(&full_content);
⋮----
if cerebras_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:cerebras"));
⋮----
.post("https://api.cerebras.ai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", cerebras_api_key))
.header("Content-Type", "application/json")
⋮----
.headers()
.get("x-ratelimit-remaining-requests-day")
.or_else(|| resp.headers().get("x-ratelimit-remaining-requests"))
.and_then(|v| v.to_str().ok())
.unwrap_or("?");
⋮----
.get("x-ratelimit-limit-requests-day")
.or_else(|| resp.headers().get("x-ratelimit-limit-requests"))
⋮----
.unwrap_or("?")
.to_string();
⋮----
if let Some(val) = conf.quota_limit_en.split_whitespace().next() {
limit = val.to_string();
⋮----
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
⋮----
let is_reasoning_model = model.contains("gpt-oss") || model.contains("zai-glm");
⋮----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
⋮----
.and_then(|c| c.delta.content.as_ref())
⋮----
full_content.push_str(content);
⋮----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
⋮----
on_chunk(content);
⋮----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
⋮----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
⋮----
.post("https://openrouter.ai/api/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", openrouter_api_key))
⋮----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
⋮----
let is_compound = model.starts_with("groq/compound");
⋮----
let context_quote = get_context_quote(&prompt);
⋮----
Some(label) => format!(
⋮----
None => format!(
⋮----
on_chunk(&search_msg);
⋮----
.post("https://api.groq.com/openai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", groq_api_key))
⋮----
if err_str.contains("401") {
⋮----
.get("x-ratelimit-remaining-requests")
⋮----
.get("x-ratelimit-limit-requests")
⋮----
.map_err(|e| anyhow::anyhow!("Failed to parse compound response: {}", e))?;
if let Some(choices) = json.get("choices").and_then(|c| c.as_array()) {
if let Some(first_choice) = choices.first() {
if let Some(message) = first_choice.get("message") {
⋮----
message.get("executed_tools").and_then(|t| t.as_array())
⋮----
if let Some(tool_type) = tool.get("type").and_then(|t| t.as_str()) {
⋮----
tool.get("arguments").and_then(|a| a.as_str())
⋮----
args_json.get("query").and_then(|q| q.as_str())
⋮----
search_queries.push(query.to_string());
⋮----
if !search_queries.is_empty() {
⋮----
phase1.push_str(&format!("{}\n", locale.search_query_label));
for (i, query) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, query));
⋮----
on_chunk(&phase1);
⋮----
.get("search_results")
.and_then(|s| s.get("results"))
.and_then(|r| r.as_array())
⋮----
.get("title")
.and_then(|t| t.as_str())
.unwrap_or(locale.search_no_title);
⋮----
.get("url")
.and_then(|u| u.as_str())
.unwrap_or("");
⋮----
.get("score")
.and_then(|s| s.as_f64())
.unwrap_or(0.0);
⋮----
.and_then(|c| c.as_str())
⋮----
all_sources.push((
title.to_string(),
url.to_string(),
⋮----
content.to_string(),
⋮----
if !all_sources.is_empty() {
all_sources.sort_by(|a, b| {
b.2.partial_cmp(&a.2).unwrap_or(std::cmp::Ordering::Equal)
⋮----
let mut phase2 = format!(
⋮----
phase2.push_str(&format!("{}\n\n", locale.search_sources_label));
⋮----
all_sources.iter().take(6).enumerate()
⋮----
let title_display = if title.chars().count() > 60 {
format!("{}...", title.chars().take(57).collect::<String>())
⋮----
title.clone()
⋮----
let domain = url.split('/').nth(2).unwrap_or(url);
⋮----
phase2.push_str(&format!(
⋮----
phase2.push_str(&format!("   🔗 {}\n", domain));
if !content.is_empty() {
let preview = if content.len() > 100 {
⋮----
content.replace('\n', " ")
⋮----
phase2.push_str(&format!("   📄 {}\n", preview));
⋮----
phase2.push('\n');
⋮----
on_chunk(&phase2);
⋮----
let phase3 = format!(
⋮----
on_chunk(&phase3);
⋮----
if let Some(content) = message.get("content").and_then(|c| c.as_str()) {
full_content = content.to_string();
⋮----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
⋮----
resp.into_body().read_json().map_err(|e| {
⋮----
json_obj.get("translation").and_then(|v| v.as_str())
⋮----
full_content = translation.to_string();
⋮----
full_content = content_str.clone();
⋮----
Ok(full_content)
⋮----
pub fn refine_text_streaming<F>(
⋮----
let final_prompt = format!(
⋮----
RefineContext::Image(_) => (original_model_id.to_string(), original_provider.to_string()),
⋮----
if !original_model_id.trim().is_empty() && original_model_id != "scout" {
(original_model_id.to_string(), original_provider.to_string())
⋮----
if !gemini_api_key.trim().is_empty() {
("gemini-flash-lite".to_string(), "google".to_string())
} else if !cerebras_api_key.trim().is_empty() {
⋮----
"qwen-3-235b-a22b-instruct-2507".to_string(),
"cerebras".to_string(),
⋮----
} else if !groq_api_key.trim().is_empty() {
("text_accurate_kimi".to_string(), "groq".to_string())
⋮----
let supports_thinking = (p_model.contains("gemini-2.5-flash")
&& !p_model.contains("lite"))
|| p_model.contains("gemini-3-flash-preview")
|| p_model.contains("gemini-robotics");
⋮----
.map_err(|e| anyhow::anyhow!("Gemini Refine Error: {}", e))?;
⋮----
if let Some(first) = candidates.first() {
⋮----
part.get("text").and_then(|v| v.as_str())
⋮----
full_content.push_str(t);
⋮----
on_chunk(t);
⋮----
let json: serde_json::Value = resp.into_body().read_json()?;
if let Some(candidates) = json.get("candidates").and_then(|c| c.as_array()) {
⋮----
final_prompt.clone(),
⋮----
.map_err(|e| anyhow::anyhow!("Cerebras Refine Error: {}", e))?;
⋮----
app.model_usage_stats.insert(p_model.clone(), usage_str);
⋮----
let is_reasoning_model = p_model.contains("gpt-oss") || p_model.contains("zai-glm");
⋮----
let json: ChatCompletionResponse = resp.into_body().read_json()?;
if let Some(choice) = json.choices.first() {
⋮----
.map_err(|e| anyhow::anyhow!("OpenRouter Refine Error: {}", e))?;
⋮----
let is_compound = p_model.starts_with("groq/compound");
⋮----
let context_quote = get_context_quote(&final_prompt);
on_chunk(&format!(
⋮----
.map_err(|e| anyhow::anyhow!("Groq Compound Refine Error: {}", e))?;
⋮----
if tool.get("type").and_then(|t| t.as_str()) == Some("search") {
⋮----
let mut phase1 = format!(
⋮----
for (i, q) in search_queries.iter().enumerate() {
phase1.push_str(&format!("  {}. \"{}\"\n", i + 1, q));
⋮----
r.get("url").and_then(|u| u.as_str()).unwrap_or("");
⋮----
all_sources.iter().take(5).enumerate()
⋮----
let t = if title.chars().count() > 50 {
⋮----
let domain = url.split('/').nth(2).unwrap_or("");
⋮----
phase2.push_str(&format!("\n{}", locale.search_synthesizing));
⋮----
.map_err(|e| anyhow::anyhow!("Groq Refine Error: {}", e))?;
⋮----
let img = image::load_from_memory(&img_bytes)?.to_rgba8();
vision_translate_image_streaming(
⋮----
Some(img_bytes.clone()),
⋮----
let mime = "image/jpeg".to_string();
⋮----
Some((img_bytes.clone(), mime)),
⋮----
exec_text_only(target_id_or_name, target_provider)
⋮----
RefineContext::None => exec_text_only(target_id_or_name, target_provider),
</file>

<file path="src/api/tts/edge_voices.rs">
use lazy_static::lazy_static;
⋮----
use std::collections::HashMap;
use std::sync::Mutex;
⋮----
pub struct EdgeVoice {
⋮----
pub struct EdgeVoiceCache {
⋮----
impl Default for EdgeVoiceCache {
fn default() -> Self {
⋮----
lazy_static! {
⋮----
pub fn load_edge_voices_async() {
⋮----
let cache = EDGE_VOICE_CACHE.lock().unwrap();
⋮----
let mut cache = EDGE_VOICE_CACHE.lock().unwrap();
⋮----
.header(
⋮----
.call()
⋮----
match response.into_body().read_to_string() {
⋮----
.entry(voice.locale.clone())
.or_insert_with(Vec::new)
.push(voice.clone());
⋮----
.split('-')
.next()
.unwrap_or(&voice.locale)
.to_lowercase();
⋮----
.entry(lang_code)
⋮----
cache.error = Some(format!("Parse error: {}", e));
⋮----
cache.error = Some(format!("Read error: {}", e));
⋮----
cache.error = Some(format!("Network error: {}", e));
⋮----
pub fn get_available_languages() -> Vec<(String, String)> {
⋮----
if lang_map.contains_key(&lang_code) {
⋮----
if let Some(dash_pos) = voice.friendly_name.rfind(" - ") {
⋮----
if let Some(paren_pos) = lang_region.find(" (") {
⋮----
lang_map.insert(lang_code, lang_only.to_string());
⋮----
lang_map.insert(lang_code, lang_region.to_string());
⋮----
let mut languages: Vec<(String, String)> = lang_map.into_iter().collect();
languages.sort_by(|a, b| a.1.cmp(&b.1));
⋮----
pub fn get_voices_for_language(lang_code: &str) -> Vec<EdgeVoice> {
⋮----
.get(&lang_code.to_lowercase())
.cloned()
.unwrap_or_default()
</file>

<file path="src/api/tts/instance.rs">
use std::sync::Arc;
use lazy_static::lazy_static;
use super::manager::TtsManager;
lazy_static! {
</file>

<file path="src/api/tts/mod.rs">
pub mod edge_voices;
pub mod instance;
pub mod manager;
pub mod player;
pub mod types;
pub mod utils;
pub mod websocket;
pub mod worker;
pub mod wsola;
pub use instance::TTS_MANAGER;
pub use manager::TtsManager;
pub fn init_tts() {
let manager = TTS_MANAGER.clone();
</file>

<file path="src/api/tts/player.rs">
use std::collections::VecDeque;
⋮----
use std::time::Duration;
⋮----
use super::manager::TtsManager;
⋮----
use super::wsola::WsolaStretcher;
pub fn run_player_thread(manager: Arc<TtsManager>) {
let audio_player = AudioPlayer::new(PLAYBACK_SAMPLE_RATE, manager.clone());
⋮----
if manager.shutdown.load(Ordering::SeqCst) {
⋮----
let mut pq = manager.playback_queue.lock().unwrap();
while pq.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.playback_signal.wait(pq).unwrap();
⋮----
pq.pop_front()
⋮----
manager.is_playing.store(true, Ordering::SeqCst);
⋮----
match rx.recv() {
⋮----
if generation < manager.interrupt_generation.load(Ordering::SeqCst) {
audio_player.stop();
clear_tts_state(hwnd);
⋮----
clear_tts_loading_state(hwnd);
⋮----
audio_player.play(&data, is_realtime);
⋮----
audio_player.drain();
⋮----
manager.is_playing.store(false, Ordering::SeqCst);
⋮----
struct AudioPlayer {
⋮----
impl AudioPlayer {
fn new(sample_rate: u32, manager: Arc<TtsManager>) -> Self {
⋮----
let buffer_clone = shared_buffer.clone();
⋮----
let shutdown_clone = shutdown.clone();
⋮----
if let Ok(app) = crate::APP.lock() {
let id = app.config.tts_output_device.clone();
if id.is_empty() {
⋮----
Some(id)
⋮----
if wasapi::initialize_mta().is_err() {
eprintln!("TTS: Failed to initialize COM");
⋮----
buffer_clone.clone(),
shutdown_clone.clone(),
⋮----
eprintln!(
⋮----
_thread: Some(thread),
⋮----
fn create_excluded_stream(
⋮----
Ok(())
⋮----
unsafe fn run_wasapi_excluded(
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED).ok();
⋮----
CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL)?;
⋮----
enumerator.GetDevice(&id_hstring)?
⋮----
enumerator.GetDefaultAudioEndpoint(eRender, eConsole)?
⋮----
let client: IAudioClient = device.Activate(CLSCTX_ALL, None)?;
let mix_format_ptr = client.GetMixFormat()?;
⋮----
client.Initialize(
⋮----
let buffer_size = client.GetBufferSize()?;
let render_client: IAudioRenderClient = client.GetService()?;
client.Start()?;
⋮----
let mut last_gen = manager.interrupt_generation.load(Ordering::SeqCst);
while !shutdown.load(Ordering::Relaxed) {
let current_gen = manager.interrupt_generation.load(Ordering::SeqCst);
⋮----
if let Ok(mut deck) = shared_buffer.lock() {
deck.clear();
⋮----
let padding = client.GetCurrentPadding()?;
let available = buffer_size.saturating_sub(padding);
⋮----
let buffer_ptr = render_client.GetBuffer(available)?;
let mut deck = shared_buffer.lock().unwrap();
⋮----
if let Some(sample) = deck.pop_front() {
⋮----
render_client.ReleaseBuffer(available, 0)?;
⋮----
client.Stop()?;
⋮----
fn play(&self, audio_data: &[u8], is_realtime: bool) {
⋮----
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_enabled = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
⋮----
.lock()
.map(|q| q.len())
.unwrap_or(0);
⋮----
let boost = (queue_len as u32 * 15).min(60);
(base_speed + boost).min(200)
⋮----
let old_speed = CURRENT_TTS_SPEED.swap(speed, Ordering::Relaxed);
⋮----
use crate::overlay::realtime_webview::state::TRANSLATION_HWND;
⋮----
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(speed as usize),
LPARAM(0),
⋮----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
⋮----
Some(TRANSLATION_HWND),
⋮----
.chunks_exact(2)
.map(|chunk| i16::from_le_bytes([chunk[0], chunk[1]]))
.collect();
if input_samples.is_empty() {
⋮----
let stretched_samples = if (speed_ratio - 1.0).abs() < 0.05 {
⋮----
if let Ok(mut wsola) = self.wsola.lock() {
let result = wsola.stretch(&input_samples, speed_ratio);
if result.is_empty() {
⋮----
let output_samples: Vec<i16> = stretched_samples.iter().flat_map(|&s| [s, s]).collect();
if let Ok(mut buf) = self.shared_buffer.lock() {
buf.extend(output_samples);
⋮----
fn drain(&self) {
⋮----
let len = self.shared_buffer.lock().map(|b| b.len()).unwrap_or(0);
⋮----
fn stop(&self) {
⋮----
buf.clear();
⋮----
impl Drop for AudioPlayer {
fn drop(&mut self) {
self.shutdown.store(true, Ordering::SeqCst);
</file>

<file path="src/api/tts/types.rs">
pub enum AudioEvent {
⋮----
pub struct QueuedRequest {
⋮----
pub struct TtsRequest {
</file>

<file path="src/api/tts/websocket.rs">
use anyhow::Result;
⋮----
use native_tls::TlsStream;
use std::net::TcpStream;
use std::time::Duration;
use tungstenite::WebSocket;
use super::types::TTS_MODEL;
pub fn connect_tts_websocket(api_key: &str) -> Result<WebSocket<TlsStream<TcpStream>>> {
let ws_url = format!(
⋮----
.host_str()
.ok_or_else(|| anyhow::anyhow!("No host in URL"))?;
⋮----
use std::net::ToSocketAddrs;
let addr = format!("{}:{}", host, port)
.to_socket_addrs()?
.next()
.ok_or_else(|| anyhow::anyhow!("Failed to resolve hostname: {}", host))?;
⋮----
tcp_stream.set_read_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_write_timeout(Some(Duration::from_secs(30)))?;
tcp_stream.set_nodelay(true)?;
⋮----
let tls_stream = connector.connect(host, tcp_stream)?;
⋮----
Ok(socket)
⋮----
pub fn send_tts_setup(
⋮----
let mut system_text = "You are a text-to-speech reader. Your ONLY job is to read the user's text out loud, exactly as written, word for word. Do NOT respond conversationally. Do NOT add commentary. Do NOT ask questions. ".to_string();
⋮----
"Slow" => system_text.push_str("Speak slowly, clearly, and with deliberate pacing. "),
"Fast" => system_text.push_str("Speak quickly, efficiently, and with a brisk pace. "),
_ => system_text.push_str("Simply read the provided text aloud naturally and clearly. "),
⋮----
if !instructions.trim().is_empty() {
system_text.push_str(" Additional instructions: ");
system_text.push_str(instructions.trim());
system_text.push(' ');
⋮----
system_text.push_str("Start reading immediately.");
⋮----
let msg_str = setup.to_string();
socket.write(tungstenite::Message::Text(msg_str.into()))?;
socket.flush()?;
Ok(())
⋮----
pub fn send_tts_text(socket: &mut WebSocket<TlsStream<TcpStream>>, text: &str) -> Result<()> {
let prompt = format!("[READ ALOUD VERBATIM - START NOW]\n\n{}", text);
⋮----
socket.write(tungstenite::Message::Text(msg.to_string().into()))?;
⋮----
pub fn parse_audio_data(msg: &str) -> Option<Vec<u8>> {
⋮----
if let Some(server_content) = json.get("serverContent") {
if let Some(model_turn) = server_content.get("modelTurn") {
if let Some(parts) = model_turn.get("parts").and_then(|p| p.as_array()) {
⋮----
if let Some(inline_data) = part.get("inlineData") {
if let Some(data_b64) = inline_data.get("data").and_then(|d| d.as_str())
⋮----
if let Ok(audio_bytes) = general_purpose::STANDARD.decode(data_b64)
⋮----
return Some(audio_bytes);
⋮----
pub fn is_turn_complete(msg: &str) -> bool {
⋮----
if let Some(turn_complete) = server_content.get("turnComplete") {
if turn_complete.as_bool().unwrap_or(false) {
⋮----
if let Some(gen_complete) = server_content.get("generationComplete") {
if gen_complete.as_bool().unwrap_or(false) {
</file>

<file path="src/api/tts/wsola.rs">
use std::f32;
pub struct WsolaStretcher {
⋮----
impl WsolaStretcher {
pub fn new(sample_rate: u32) -> Self {
⋮----
.map(|i| {
⋮----
0.5 * (1.0 - (2.0 * std::f32::consts::PI * t).cos())
⋮----
.collect();
⋮----
fn find_best_offset(&self, input_pos: usize, target_hop: usize) -> usize {
let start = target_hop.saturating_sub(self.search_range);
let end = (target_hop + self.search_range).min(self.input_buffer.len().saturating_sub(self.frame_size + input_pos).saturating_sub(1));
⋮----
if ref_pos + compare_len > self.input_buffer.len() {
⋮----
if candidate_pos + compare_len > self.input_buffer.len() {
⋮----
pub fn stretch(&mut self, input: &[i16], speed_ratio: f64) -> Vec<i16> {
if (speed_ratio - 1.0).abs() < 0.05 || input.is_empty() {
if !self.output_overlap.is_empty() {
let result: Vec<i16> = self.output_overlap.drain(..)
.map(|s| s.clamp(-32768.0, 32767.0) as i16)
⋮----
combined.extend(input.iter().cloned());
⋮----
return input.to_vec();
⋮----
if (speed_ratio - self.last_speed).abs() > 0.15 {
self.input_buffer.clear();
self.output_overlap.clear();
⋮----
self.input_buffer.extend(input.iter().map(|&s| s as f32));
if self.input_buffer.len() < self.frame_size + self.search_range {
⋮----
let target_analysis_hop = (self.hop_size as f64 * speed_ratio).round() as usize;
⋮----
let estimated_frames = self.input_buffer.len() / target_analysis_hop.max(1);
let mut output = vec![0.0f32; estimated_frames * synthesis_hop + self.frame_size];
for (i, &v) in self.output_overlap.iter().enumerate() {
if i < output.len() {
⋮----
if input_pos + self.frame_size + self.search_range + target_analysis_hop > self.input_buffer.len() {
⋮----
if output_pos + self.frame_size > output.len() {
output.resize(output_pos + self.frame_size * 2, 0.0);
⋮----
let actual_analysis_hop = self.find_best_offset(input_pos, target_analysis_hop);
⋮----
let complete_len = output_pos.min(output.len());
⋮----
if complete_len < output.len() {
self.output_overlap.extend_from_slice(&output[complete_len..]);
⋮----
let consumed = input_pos.min(self.input_buffer.len());
⋮----
self.input_buffer.drain(0..consumed);
⋮----
output[..complete_len].iter()
.map(|&s| s.clamp(-32768.0, 32767.0) as i16)
.collect()
</file>

<file path="src/api/types.rs">
pub struct StreamChunk {
⋮----
pub struct Choice {
⋮----
pub struct Delta {
⋮----
pub struct ChatCompletionResponse {
⋮----
pub struct ChatChoice {
⋮----
pub struct ChatMessage {
⋮----
pub struct ExecutedTool {
⋮----
pub struct SearchResults {
⋮----
pub struct SearchResult {
</file>

<file path="src/api/vision.rs">
use super::client::UREQ_AGENT;
⋮----
use crate::gui::locale::LocaleText;
use crate::APP;
use anyhow::Result;
⋮----
pub fn translate_image_streaming<F>(
⋮----
.lock()
.ok()
.and_then(|app| {
let config = app.config.clone();
if config.openrouter_api_key.is_empty() {
⋮----
Some(config.openrouter_api_key.clone())
⋮----
.unwrap_or_default();
⋮----
let mut mime_type = "image/png".to_string();
if provider == "google" && original_bytes.is_some() {
println!("DEBUG: Zero-Copy optimization active for Google provider");
let bytes = original_bytes.as_ref().unwrap();
b64_image = general_purpose::STANDARD.encode(bytes);
if bytes.starts_with(&[0xff, 0xd8, 0xff]) {
mime_type = "image/jpeg".to_string();
} else if bytes.starts_with(&[0x89, 0x50, 0x4e, 0x47]) {
mime_type = "image/png".to_string();
} else if bytes.starts_with(&[0x52, 0x49, 0x46, 0x46])
⋮----
mime_type = "image/webp".to_string();
⋮----
println!("DEBUG: Detected MIME type: {}", mime_type);
⋮----
if provider != "google" && (final_image.width() > max_dim || final_image.height() > max_dim)
⋮----
println!("DEBUG: Image exceeds {}px, resizing...", max_dim);
let (n_w, n_h) = if final_image.width() > final_image.height() {
let ratio = max_dim as f32 / final_image.width() as f32;
(max_dim, (final_image.height() as f32 * ratio) as u32)
⋮----
let ratio = max_dim as f32 / final_image.height() as f32;
((final_image.width() as f32 * ratio) as u32, max_dim)
⋮----
println!(
⋮----
final_image.write_to(&mut Cursor::new(&mut image_data), image::ImageFormat::Png)?;
b64_image = general_purpose::STANDARD.encode(&image_data);
⋮----
.map(|app| {
⋮----
config.ollama_base_url.clone(),
config.ollama_vision_model.clone(),
config.ui_language.clone(),
⋮----
.unwrap_or_else(|| {
⋮----
"http://localhost:11434".to_string(),
model.clone(),
"en".to_string(),
⋮----
let actual_model = if ollama_vision_model.is_empty() {
model.clone()
⋮----
let ollama_image = image::load_from_memory(&image_data)?.to_rgba8();
⋮----
} else if !image_data.is_empty() {
image_data.clone()
⋮----
return Err(anyhow::anyhow!("No image data available for Gemini Live"));
⋮----
.map(|app| app.config.ui_language.clone())
.unwrap_or_else(|| "en".to_string());
⋮----
prompt.clone(),
⋮----
Some((img_bytes, mime_type)),
⋮----
let boundary = format!(
⋮----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n");
body.extend_from_slice(b"1048576\r\n");
⋮----
body.extend_from_slice(
⋮----
body.extend_from_slice(b"Content-Type: image/png\r\n\r\n");
body.extend_from_slice(&image_data);
body.extend_from_slice(b"\r\n");
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
⋮----
.post("http://api.qrserver.com/v1/read-qr-code/")
.header(
⋮----
&format!("multipart/form-data; boundary={}", boundary),
⋮----
.send(&body)
.map_err(|e| anyhow::anyhow!("QR Server API Error: {}", e))?;
⋮----
.into_body()
.read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse QR response: {}", e))?;
if let Some(first) = json.as_array().and_then(|a| a.first()) {
if let Some(symbols) = first.get("symbol").and_then(|s| s.as_array()) {
if let Some(first_symbol) = symbols.first() {
if let Some(data) = first_symbol.get("data").and_then(|d| d.as_str()) {
if !data.is_empty() {
full_content = data.to_string();
on_chunk(&full_content);
return Ok(full_content);
⋮----
if let Some(error) = first_symbol.get("error").and_then(|e| e.as_str()) {
if !error.is_empty() {
return Err(anyhow::anyhow!("QR_NOT_FOUND: {}", error));
⋮----
return Err(anyhow::anyhow!(
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:gemini"));
⋮----
format!(
⋮----
let supports_thinking = (model.contains("gemini-2.5-flash") && !model.contains("lite"))
|| model.contains("gemini-3-flash-preview")
|| model.contains("gemini-robotics");
⋮----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_body().into_reader());
⋮----
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
chunk_resp.get("candidates").and_then(|c| c.as_array())
⋮----
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
.get("thought")
.and_then(|t| t.as_bool())
.unwrap_or(false);
⋮----
part.get("text").and_then(|t| t.as_str())
⋮----
on_chunk(locale.model_thinking);
⋮----
full_content.push_str(text);
let wipe_content = format!(
⋮----
on_chunk(&wipe_content);
⋮----
on_chunk(text);
⋮----
.map_err(|e| anyhow::anyhow!("Failed to parse non-streaming response: {}", e))?;
if let Some(candidates) = chat_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_choice) = candidates.first() {
⋮----
.iter()
.filter(|p| {
!p.get("thought").and_then(|t| t.as_bool()).unwrap_or(false)
⋮----
.filter_map(|p| p.get("text").and_then(|t| t.as_str()))
⋮----
if openrouter_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:openrouter"));
⋮----
.post("https://openrouter.ai/api/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", openrouter_api_key))
.header("Content-Type", "application/json")
⋮----
.get(0)
.and_then(|c| c.delta.reasoning.as_ref())
.filter(|s| !s.is_empty())
⋮----
.and_then(|c| c.delta.content.as_ref())
⋮----
full_content.push_str(content);
⋮----
format!("{}{}", crate::api::WIPE_SIGNAL, full_content);
⋮----
on_chunk(content);
⋮----
if let Some(choice) = chat_resp.choices.first() {
full_content = choice.message.content.clone();
⋮----
if groq_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:groq"));
⋮----
let resp = UREQ_AGENT.post("https://api.groq.com/openai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", groq_api_key))
⋮----
if err_str.contains("401") {
⋮----
} else if err_str.contains("400") {
⋮----
.headers()
.get("x-ratelimit-remaining-requests")
.and_then(|v| v.to_str().ok())
⋮----
.get("x-ratelimit-limit-requests")
⋮----
.unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.clone(), usage_str);
⋮----
chunk.choices.get(0).and_then(|c| c.delta.content.as_ref())
⋮----
json_obj.get("translation").and_then(|v| v.as_str())
⋮----
full_content = translation.to_string();
⋮----
full_content = content_str.clone();
⋮----
Ok(full_content)
</file>

<file path="src/config/io.rs">
use std::path::PathBuf;
use crate::config::config::Config;
⋮----
pub fn get_config_path() -> PathBuf {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
⋮----
config_dir.join("config_v3.json")
⋮----
pub fn load_config() -> Config {
let path = get_config_path();
if !path.exists() {
⋮----
migrate_config(&mut config);
⋮----
fn migrate_config(config: &mut Config) {
let default_presets = get_default_presets();
⋮----
config.presets.iter().map(|p| p.id.clone()).collect();
⋮----
.iter()
.filter(|p| p.is_builtin() && !existing_ids.contains(&p.id))
.cloned()
.collect();
if !new_presets.is_empty() {
config.presets.extend(new_presets);
⋮----
if !preset.is_builtin() {
⋮----
if let Some(default_preset) = default_presets.iter().find(|p| p.id == preset.id) {
⋮----
if preset.blocks.is_empty() && !preset.is_master {
preset.blocks.push(ProcessingBlock {
block_type: preset.preset_type.clone(),
⋮----
pub fn save_config(config: &Config) {
⋮----
pub fn get_all_languages() -> &'static Vec<String> {
</file>

<file path="src/config/mod.rs">
mod config;
mod io;
pub mod preset;
pub mod types;
pub use config::Config;
⋮----
pub use types::ThemeMode;
pub use types::Hotkey;
</file>

<file path="src/config/preset/defaults/audio.rs">
use crate::config::preset::Preset;
⋮----
pub fn create_audio_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/defaults/master.rs">
use crate::config::preset::Preset;
use crate::config::preset::PresetBuilder;
pub fn create_master_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/config/preset/mod.rs">
mod block;
pub mod defaults;
mod preset;
⋮----
pub use defaults::get_default_presets;
</file>

<file path="src/config/preset/preset.rs">
use super::block::ProcessingBlock;
use crate::config::types::Hotkey;
⋮----
pub struct Preset {
⋮----
fn default_prompt_mode() -> String {
"fixed".to_string()
⋮----
fn default_preset_type() -> String {
"image".to_string()
⋮----
fn default_text_input_mode() -> String {
"select".to_string()
⋮----
fn default_audio_source() -> String {
"mic".to_string()
⋮----
fn default_audio_processing_mode() -> String {
"record_then_process".to_string()
⋮----
fn default_realtime_window_mode() -> String {
"standard".to_string()
⋮----
fn default_true() -> bool {
⋮----
impl Default for Preset {
fn default() -> Self {
⋮----
id: generate_preset_id(),
name: "New Preset".to_string(),
blocks: vec![ProcessingBlock::default()],
block_connections: vec![],
prompt_mode: "fixed".to_string(),
preset_type: "image".to_string(),
text_input_mode: "select".to_string(),
audio_source: "mic".to_string(),
audio_processing_mode: "record_then_process".to_string(),
realtime_window_mode: "standard".to_string(),
video_capture_method: "region".to_string(),
⋮----
hotkeys: vec![],
⋮----
fn generate_preset_id() -> String {
format!(
⋮----
pub struct PresetBuilder {
⋮----
impl PresetBuilder {
pub fn new(id: &str, name: &str) -> Self {
⋮----
id: id.to_string(),
name: name.to_string(),
blocks: vec![],
⋮----
pub fn image(mut self) -> Self {
self.preset.preset_type = "image".to_string();
⋮----
pub fn text_select(mut self) -> Self {
self.preset.preset_type = "text".to_string();
self.preset.text_input_mode = "select".to_string();
⋮----
pub fn text_type(mut self) -> Self {
⋮----
self.preset.text_input_mode = "type".to_string();
⋮----
pub fn audio_mic(mut self) -> Self {
self.preset.preset_type = "audio".to_string();
self.preset.audio_source = "mic".to_string();
⋮----
pub fn audio_device(mut self) -> Self {
⋮----
self.preset.audio_source = "device".to_string();
⋮----
pub fn blocks(mut self, blocks: Vec<ProcessingBlock>) -> Self {
⋮----
pub fn connections(mut self, connections: Vec<(usize, usize)>) -> Self {
⋮----
pub fn auto_paste(mut self) -> Self {
⋮----
pub fn auto_stop(mut self) -> Self {
⋮----
pub fn realtime(mut self) -> Self {
self.preset.audio_processing_mode = "realtime".to_string();
⋮----
pub fn minimal_mode(mut self) -> Self {
self.preset.realtime_window_mode = "minimal".to_string();
⋮----
pub fn continuous(mut self) -> Self {
⋮----
pub fn dynamic_prompt(mut self) -> Self {
self.preset.prompt_mode = "dynamic".to_string();
⋮----
pub fn master(mut self) -> Self {
⋮----
self.preset.blocks = vec![];
⋮----
pub fn build(self) -> Preset {
⋮----
impl Preset {
pub fn is_builtin(&self) -> bool {
self.id.starts_with("preset_")
⋮----
pub fn is_master_preset(&self) -> bool {
⋮----
pub fn input_block(&self) -> Option<&ProcessingBlock> {
self.blocks.first()
⋮----
pub fn input_block_mut(&mut self) -> Option<&mut ProcessingBlock> {
self.blocks.first_mut()
</file>

<file path="src/config/types/enums.rs">
pub enum ThemeMode {
⋮----
pub enum BlockType {
⋮----
impl BlockType {
pub fn from_str(s: &str) -> Self {
⋮----
pub fn get_system_ui_language() -> String {
let sys_locale = sys_locale::get_locale().unwrap_or_default();
let lang_code = sys_locale.split('-').next().unwrap_or("en").to_lowercase();
match lang_code.as_str() {
"vi" => "vi".to_string(),
"ko" => "ko".to_string(),
"ja" => "ja".to_string(),
"zh" => "zh".to_string(),
_ => "en".to_string(),
</file>

<file path="src/config/types/hotkey.rs">
pub struct Hotkey {
⋮----
impl Hotkey {
pub fn new(code: u32, name: &str, modifiers: u32) -> Self {
⋮----
name: name.to_string(),
</file>

<file path="src/config/types/mod.rs">
mod enums;
mod hotkey;
mod tts;
⋮----
pub use hotkey::Hotkey;
</file>

<file path="src/config/types/tts.rs">
pub enum TtsMethod {
⋮----
pub struct EdgeTtsVoiceConfig {
⋮----
impl EdgeTtsVoiceConfig {
pub fn new(language_code: &str, language_name: &str, voice_name: &str) -> Self {
⋮----
language_code: language_code.to_string(),
language_name: language_name.to_string(),
voice_name: voice_name.to_string(),
⋮----
pub struct EdgeTtsSettings {
⋮----
impl Default for EdgeTtsSettings {
fn default() -> Self {
⋮----
voice_configs: default_edge_tts_voice_configs(),
⋮----
pub fn default_edge_tts_voice_configs() -> Vec<EdgeTtsVoiceConfig> {
vec![
⋮----
pub struct TtsLanguageCondition {
⋮----
impl TtsLanguageCondition {
pub fn new(language_code: &str, language_name: &str, instruction: &str) -> Self {
⋮----
instruction: instruction.to_string(),
⋮----
pub fn default_tts_language_conditions() -> Vec<TtsLanguageCondition> {
vec![TtsLanguageCondition::new(
</file>

<file path="src/gui/key_mapping.rs">
use eframe::egui;
pub fn egui_key_to_vk(key: &egui::Key) -> Option<u32> {
⋮----
egui::Key::Num0 => Some(0x30), egui::Key::Num1 => Some(0x31), egui::Key::Num2 => Some(0x32),
egui::Key::Num3 => Some(0x33), egui::Key::Num4 => Some(0x34), egui::Key::Num5 => Some(0x35),
egui::Key::Num6 => Some(0x36), egui::Key::Num7 => Some(0x37), egui::Key::Num8 => Some(0x38),
egui::Key::Num9 => Some(0x39),
egui::Key::A => Some(0x41), egui::Key::B => Some(0x42), egui::Key::C => Some(0x43),
egui::Key::D => Some(0x44), egui::Key::E => Some(0x45), egui::Key::F => Some(0x46),
egui::Key::G => Some(0x47), egui::Key::H => Some(0x48), egui::Key::I => Some(0x49),
egui::Key::J => Some(0x4A), egui::Key::K => Some(0x4B), egui::Key::L => Some(0x4C),
egui::Key::M => Some(0x4D), egui::Key::N => Some(0x4E), egui::Key::O => Some(0x4F),
egui::Key::P => Some(0x50), egui::Key::Q => Some(0x51), egui::Key::R => Some(0x52),
egui::Key::S => Some(0x53), egui::Key::T => Some(0x54), egui::Key::U => Some(0x55),
egui::Key::V => Some(0x56), egui::Key::W => Some(0x57), egui::Key::X => Some(0x58),
egui::Key::Y => Some(0x59), egui::Key::Z => Some(0x5A),
egui::Key::F1 => Some(0x70), egui::Key::F2 => Some(0x71), egui::Key::F3 => Some(0x72),
egui::Key::F4 => Some(0x73), egui::Key::F5 => Some(0x74), egui::Key::F6 => Some(0x75),
egui::Key::F7 => Some(0x76), egui::Key::F8 => Some(0x77), egui::Key::F9 => Some(0x78),
egui::Key::F10 => Some(0x79), egui::Key::F11 => Some(0x7A), egui::Key::F12 => Some(0x7B),
egui::Key::F13 => Some(0x7C), egui::Key::F14 => Some(0x7D), egui::Key::F15 => Some(0x7E),
egui::Key::F16 => Some(0x7F), egui::Key::F17 => Some(0x80), egui::Key::F18 => Some(0x81),
egui::Key::F19 => Some(0x82), egui::Key::F20 => Some(0x83),
egui::Key::Escape => Some(0x1B),
egui::Key::Insert => Some(0x2D),
egui::Key::Delete => Some(0x2E),
egui::Key::Home => Some(0x24),
egui::Key::End => Some(0x23),
egui::Key::PageUp => Some(0x21),
egui::Key::PageDown => Some(0x22),
egui::Key::ArrowLeft => Some(0x25),
egui::Key::ArrowUp => Some(0x26),
egui::Key::ArrowRight => Some(0x27),
egui::Key::ArrowDown => Some(0x28),
egui::Key::Backspace => Some(0x08),
egui::Key::Enter => Some(0x0D),
egui::Key::Space => Some(0x20),
egui::Key::Tab => Some(0x09),
egui::Key::Backtick => Some(0xC0),
egui::Key::Minus => Some(0xBD),
egui::Key::Plus => Some(0xBB),
egui::Key::OpenBracket => Some(0xDB),
egui::Key::CloseBracket => Some(0xDD),
egui::Key::Backslash => Some(0xDC),
egui::Key::Semicolon => Some(0xBA),
egui::Key::Comma => Some(0xBC),
egui::Key::Period => Some(0xBE),
egui::Key::Slash => Some(0xBF),
⋮----
pub fn egui_pointer_to_vk(btn: &egui::PointerButton) -> Option<u32> {
⋮----
egui::PointerButton::Middle => Some(0x04),
egui::PointerButton::Extra1 => Some(0x05),
egui::PointerButton::Extra2 => Some(0x06),
</file>

<file path="src/gui/settings_ui/footer.rs">
use crate::gui::locale::LocaleText;
use eframe::egui;
⋮----
pub fn render_footer(
⋮----
ui.horizontal(|ui| {
ui.allocate_ui(egui::vec2(180.0, ui.available_height()), |ui| {
ui.horizontal_centered(|ui| {
⋮----
cfg!(target_os = "windows") && crate::gui::utils::is_running_as_admin();
⋮----
.size(11.0)
.color(egui::Color32::from_rgb(34, 139, 34))
⋮----
.color(ui.visuals().weak_text_color())
⋮----
ui.label(footer_text);
⋮----
let version_text = format!("{} v{}", text.footer_version, env!("CARGO_PKG_VERSION"));
let version_galley = ui.painter().layout_no_wrap(
version_text.clone(),
⋮----
ui.visuals().weak_text_color(),
⋮----
let version_width = version_galley.rect.width() + 10.0;
let available_w = (ui.available_width() - version_width).max(0.0);
ui.allocate_ui(egui::vec2(available_w, ui.available_height()), |ui| {
ui.vertical_centered(|ui| {
let tip_color = ui.visuals().text_color().linear_multiply(tip_alpha);
⋮----
let is_dark_mode = ui.visuals().dark_mode;
⋮----
format_footer_tip(&current_tip, tip_color, is_dark_mode, tip_alpha);
let text_galley = ui.painter().layout_job(layout_job);
let total_width = icon_size + icon_spacing + text_galley.rect.width();
let (response, painter) = ui.allocate_painter(
egui::vec2(total_width + 8.0, ui.available_height().max(18.0)),
⋮----
egui::pos2(rect.left(), rect.center().y - icon_size / 2.0),
⋮----
paint_icon(&painter, icon_rect, Icon::Lightbulb, icon_color);
⋮----
icon_rect.right() + icon_spacing,
rect.center().y - text_galley.rect.height() / 2.0,
⋮----
painter.galley(text_pos, text_galley, egui::Color32::WHITE);
if response.on_hover_text(text.tips_click_hint).clicked() {
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
ui.label(
⋮----
.color(ui.visuals().weak_text_color()),
⋮----
fn format_footer_tip(
⋮----
base_color.r(),
base_color.g(),
base_color.b(),
(base_color.a() as f32 * alpha_factor) as u8,
⋮----
bold_color.r(),
bold_color.g(),
bold_color.b(),
⋮----
let mut chars = text.chars().peekable();
⋮----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
⋮----
job.append(&current_text, 0.0, fmt);
current_text.clear();
⋮----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/global/tts_settings.rs">
use eframe::egui;
⋮----
use crate::gui::locale::LocaleText;
⋮----
pub fn render_tts_settings_modal(
⋮----
let male_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Male").collect();
let female_voices: Vec<_> = VOICES.iter().filter(|(_, g)| *g == "Female").collect();
egui::Window::new(format!("🔊 {}", text.tts_settings_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(650.0)
.default_height(600.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.set_min_height(500.0);
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("🔊 {}", text.tts_settings_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
⋮----
ui.separator();
ui.add_space(8.0);
⋮----
ui.label(egui::RichText::new(text.tts_method_label).strong());
if ui.radio_value(&mut config.tts_method, TtsMethod::GeminiLive, text.tts_method_standard).clicked() {
⋮----
if ui.radio_value(&mut config.tts_method, TtsMethod::EdgeTTS, text.tts_method_edge).clicked() {
⋮----
if ui.radio_value(&mut config.tts_method, TtsMethod::GoogleTranslate, text.tts_method_fast).clicked() {
⋮----
config.tts_speed = "Normal".to_string();
⋮----
ui.add_space(10.0);
⋮----
ui.columns(2, |columns| {
columns[0].label(egui::RichText::new(text.tts_speed_label).strong());
columns[0].horizontal(|ui| {
if ui.radio_value(&mut config.tts_speed, "Slow".to_string(), text.tts_speed_slow).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Normal".to_string(), text.tts_speed_normal).clicked() { changed = true; }
if ui.radio_value(&mut config.tts_speed, "Fast".to_string(), text.tts_speed_fast).clicked() { changed = true; }
⋮----
columns[1].label(egui::RichText::new(text.tts_instructions_label).strong());
⋮----
for (idx, condition) in config.tts_language_conditions.iter_mut().enumerate() {
columns[1].horizontal(|ui| {
let display_name = supported_languages.iter()
.find(|(code, _)| code.eq_ignore_ascii_case(&condition.language_code))
.map(|(_, name)| *name)
.unwrap_or(&condition.language_name);
ui.label(egui::RichText::new(display_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
ui.label("→");
if ui.add(
⋮----
.desired_width(180.0)
.hint_text(text.tts_instructions_hint)
).changed() {
⋮----
if icon_button(ui, Icon::Close).on_hover_text("Remove").clicked() {
to_remove = Some(idx);
⋮----
config.tts_language_conditions.remove(idx);
⋮----
let used_codes: Vec<_> = config.tts_language_conditions.iter()
.map(|c| c.language_code.as_str())
.collect();
let available: Vec<_> = supported_languages.iter()
.filter(|(code, _)| !used_codes.contains(code))
⋮----
if !available.is_empty() {
⋮----
.selected_text(text.tts_add_condition)
.width(140.0)
.show_ui(ui, |ui| {
⋮----
if ui.selectable_label(false, *name).clicked() {
config.tts_language_conditions.push(crate::config::TtsLanguageCondition {
language_code: code.to_string(),
language_name: name.to_string(),
⋮----
ui.columns(4, |columns| {
⋮----
use std::collections::hash_map::RandomState;
⋮----
if ui.radio(is_selected, "").clicked() {
config.tts_voice = name.to_string();
⋮----
if ui.button("🔊").on_hover_text("Preview").clicked() {
⋮----
if !text.tts_preview_texts.is_empty() {
⋮----
let mut hasher = s.build_hasher();
hasher.write_usize(SystemTime::now().duration_since(UNIX_EPOCH).unwrap_or_default().subsec_nanos() as usize);
let rand_val = hasher.finish();
let len = text.tts_preview_texts.len();
⋮----
let last = LAST_PREVIEW_IDX.load(Ordering::Relaxed);
⋮----
LAST_PREVIEW_IDX.store(idx, Ordering::Relaxed);
let preview_text = text.tts_preview_texts[idx].replace("{}", name);
crate::api::tts::TTS_MANAGER.speak_interrupt(&preview_text, 0);
⋮----
let preview_text = format!("Hello, I am {}. This is a voice preview.", name);
⋮----
ui.label(egui::RichText::new(name).strong());
⋮----
let male_mid = (male_voices.len() + 1) / 2;
let male_col1: Vec<_> = male_voices.iter().take(male_mid).collect();
let male_col2: Vec<_> = male_voices.iter().skip(male_mid).collect();
let female_mid = (female_voices.len() + 1) / 2;
let female_col1: Vec<_> = female_voices.iter().take(female_mid).collect();
let female_col2: Vec<_> = female_voices.iter().skip(female_mid).collect();
columns[0].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_male).strong().underline());
ui.add_space(4.0);
⋮----
render_voice(ui, name, config, text, &mut changed);
⋮----
columns[1].vertical(|ui| {
ui.label(egui::RichText::new("").strong()); // Empty header for alignment
⋮----
// Column 2: Female (first half)
columns[2].vertical(|ui| {
ui.label(egui::RichText::new(text.tts_female).strong().underline());
⋮----
// Column 3: Female (second half)
columns[3].vertical(|ui| {
⋮----
// Simplified UI for Google Translate
ui.vertical_centered(|ui| {
ui.add_space(20.0);
ui.label(egui::RichText::new(text.tts_google_translate_title).size(18.0).strong());
⋮----
ui.label(text.tts_google_translate_desc);
⋮----
ui.label(egui::RichText::new(text.tts_speed_label).strong());
⋮----
ui.label(egui::RichText::new(text.tts_edge_title).size(18.0).strong());
ui.add_space(5.0);
ui.label(text.tts_edge_desc);
ui.add_space(15.0);
⋮----
ui.label(egui::RichText::new(text.tts_pitch_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.pitch, -50..=50).suffix(" Hz")).changed() {
⋮----
ui.label(egui::RichText::new(text.tts_rate_label).strong());
if ui.add(egui::Slider::new(&mut config.edge_tts_settings.rate, -50..=100).suffix("%")).changed() {
⋮----
ui.label(egui::RichText::new(text.tts_voice_per_language_label).strong());
⋮----
let cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
(cache.loaded, cache.loading, cache.error.clone())
⋮----
ui.spinner();
ui.label(text.tts_loading_voices);
⋮----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.tts_failed_load_voices, error).replace("{}", ""));
if ui.button(text.tts_retry_label).clicked() {
// Reset cache and retry
let mut cache = crate::api::tts::edge_voices::EDGE_VOICE_CACHE.lock().unwrap();
⋮----
// Loaded - show voice configuration
egui::ScrollArea::vertical().max_height(180.0).show(ui, |ui| {
⋮----
for (idx, voice_config) in config.edge_tts_settings.voice_configs.iter_mut().enumerate() {
⋮----
// Language name (read-only)
ui.label(egui::RichText::new(&voice_config.language_name).strong().color(egui::Color32::from_rgb(100, 180, 100)));
⋮----
// Voice dropdown for this language
⋮----
egui::ComboBox::from_id_salt(format!("edge_voice_{}", idx))
.selected_text(&voice_config.voice_name)
.width(220.0)
⋮----
let display = format!("{} ({})", voice.short_name, voice.gender);
if ui.selectable_label(voice_config.voice_name == voice.short_name, &display).clicked() {
voice_config.voice_name = voice.short_name.clone();
⋮----
// Remove button
⋮----
config.edge_tts_settings.voice_configs.remove(idx);
⋮----
let used_codes: Vec<_> = config.edge_tts_settings.voice_configs.iter()
⋮----
let available: Vec<_> = available_langs.iter()
.filter(|(code, _)| !used_codes.contains(&code.as_str()))
⋮----
.selected_text(text.tts_add_language_label)
.width(150.0)
⋮----
if ui.selectable_label(false, name).clicked() {
⋮----
let default_voice = voices.first()
.map(|v| v.short_name.clone())
.unwrap_or_else(|| format!("{}-??-??Neural", code));
config.edge_tts_settings.voice_configs.push(
⋮----
language_code: code.clone(),
language_name: name.clone(),
⋮----
if ui.button(text.tts_reset_to_defaults_label).clicked() {
⋮----
ui.label(text.tts_initializing_voices);
</file>

<file path="src/gui/settings_ui/global/usage_stats.rs">
use eframe::egui;
use crate::gui::locale::LocaleText;
⋮----
use std::collections::HashMap;
pub fn render_usage_modal(
⋮----
egui::Window::new(format!("📊 {}", text.usage_statistics_title))
.collapsible(false)
.resizable(false)
.title_bar(false)
.default_width(400.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ui.ctx(), |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(format!("📊 {}", text.usage_statistics_title)).strong().size(14.0));
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if icon_button(ui, Icon::Close).clicked() {
⋮----
ui.separator();
ui.add_space(4.0);
⋮----
get_all_models_with_ollama()
⋮----
get_all_models().to_vec()
⋮----
.max_height(450.0)
.auto_shrink([false, false])
.show(ui, |ui| {
ui.set_width(ui.available_width());
⋮----
egui::CollapsingHeader::new(egui::RichText::new("⚡ Groq").strong().size(13.0))
.default_open(true)
⋮----
egui::Grid::new("groq_grid").striped(true).show(ui, |ui| {
ui.label(egui::RichText::new(text.usage_model_column).strong().size(11.0));
ui.label(egui::RichText::new(text.usage_remaining_column).strong().size(11.0));
ui.end_row();
⋮----
if shown_models.contains(&model.full_name) { continue; }
shown_models.insert(model.full_name.clone());
ui.label(&model.full_name);
⋮----
ui.label("");
⋮----
let static_limit = model.quota_limit_en.split_whitespace().next().unwrap_or("?");
let default_status = format!("??? / {}", static_limit);
let raw_status = usage_stats.get(&model.full_name).cloned().unwrap_or(default_status);
let display_status = if let Some((usage, limit)) = raw_status.split_once(" / ") {
⋮----
format!("{} / {}", usage, final_limit)
⋮----
ui.label(display_status);
⋮----
egui::CollapsingHeader::new(egui::RichText::new("🔥 Cerebras").strong().size(13.0))
⋮----
egui::Grid::new("cerebras_grid").striped(true).show(ui, |ui| {
⋮----
if !shown_models.contains("gpt-oss-120b") {
shown_models.insert("gpt-oss-120b".to_string());
ui.label("gpt-oss-120b");
⋮----
let raw_status = usage_stats.get("gpt-oss-120b").cloned().unwrap_or(default_status);
⋮----
ui.hyperlink_to(text.usage_check_link, "https://cloud.cerebras.ai/");
⋮----
egui::CollapsingHeader::new(egui::RichText::new("✨ Google Gemini").strong().size(13.0))
⋮----
ui.add_space(120.0);
ui.hyperlink_to(text.usage_check_link, "https://aistudio.google.com/usage?timeRange=last-1-day&tab=rate-limit");
⋮----
egui::CollapsingHeader::new(egui::RichText::new("🌐 OpenRouter").strong().size(13.0))
⋮----
ui.hyperlink_to(text.usage_check_link, "https://openrouter.ai/activity");
⋮----
egui::CollapsingHeader::new(egui::RichText::new("🏠 Ollama (Local)").strong().size(13.0))
⋮----
ui.label("∞ Unlimited");
</file>

<file path="src/gui/settings_ui/history.rs">
use crate::config::Config;
⋮----
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
pub fn render_history_panel(
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.set_max_width(510.0);
ui.add_space(5.0);
⋮----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
egui::RichText::new(format!("📜 {}", text.history_title))
.strong()
.size(14.0),
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
⋮----
.add(egui::Slider::new(&mut config.max_history_items, 10..=200))
.changed()
⋮----
history_manager.request_prune(config.max_history_items);
⋮----
ui.label(text.max_items_label);
⋮----
ui.add_space(8.0);
⋮----
ui.scope(|ui| {
⋮----
let visuals = ui.visuals_mut();
⋮----
ui.add(
⋮----
.hint_text(text.search_placeholder)
.desired_width(220.0),
⋮----
if !search_query.is_empty() {
if icon_button(ui, Icon::Close)
.on_hover_text("Clear search")
.clicked()
⋮----
*search_query = "".to_string();
⋮----
if icon_button(ui, Icon::Folder)
.on_hover_text("Open Media Folder")
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox")
.join("history_media");
⋮----
.add(
⋮----
.color(egui::Color32::WHITE)
.small(),
⋮----
.fill(clear_bg)
.corner_radius(8.0),
⋮----
history_manager.clear_all();
⋮----
let items = history_manager.items.lock().unwrap().clone();
let q = search_query.to_lowercase();
⋮----
.iter()
.filter(|i| q.is_empty() || i.text.to_lowercase().contains(&q) || i.timestamp.contains(&q))
.collect();
if filtered.is_empty() {
ui.centered_and_justified(|ui| {
ui.label(text.history_empty);
⋮----
egui::Frame::new().show(ui, |ui| {
ui.set_height(460.0);
egui::ScrollArea::vertical().show(ui, |ui| {
⋮----
.fill(item_bg)
⋮----
.inner_margin(8.0)
.corner_radius(8.0)
⋮----
draw_icon_static(ui, icon, Some(14.0));
ui.label(egui::RichText::new(&item.timestamp).size(10.0).weak());
ui.with_layout(
⋮----
if icon_button(ui, Icon::DeleteLarge)
.on_hover_text("Delete")
⋮----
id_to_delete = Some(item.id);
⋮----
if icon_button(ui, Icon::Copy)
.on_hover_text("Copy Text")
⋮----
if !item.media_path.is_empty() {
⋮----
if ui.button(btn_text).clicked() {
⋮----
.unwrap()
⋮----
let path = config_dir.join(&item.media_path);
⋮----
ui.label(egui::RichText::new(&item.text).size(13.0));
⋮----
ui.add_space(4.0);
⋮----
history_manager.delete(id);
</file>

<file path="src/gui/settings_ui/node_graph/conversion.rs">
use super::node::ChainNode;
use crate::config::ProcessingBlock;
use eframe::egui;
⋮----
pub fn blocks_to_snarl(
⋮----
let positions: Vec<egui::Pos2> = if !connections.is_empty() {
⋮----
adj.entry(from).or_default().push(to);
⋮----
let mut depths = vec![0; blocks.len()];
⋮----
queue.push_back((0, 0));
let mut visited = vec![false; blocks.len()];
⋮----
while let Some((u, d)) = queue.pop_front() {
⋮----
layer_nodes.entry(d).or_default().push(u);
if let Some(children) = adj.get(&u) {
⋮----
if v < blocks.len() && !visited[v] {
⋮----
queue.push_back((v, d + 1));
⋮----
let mut pos_map = vec![egui::pos2(0.0, 0.0); blocks.len()];
for (depth, nodes) in layer_nodes.iter() {
let count = nodes.len();
⋮----
for (i, &node_idx) in nodes.iter().enumerate() {
⋮----
for i in 0..blocks.len() {
⋮----
.iter()
.enumerate()
.map(|(i, _)| egui::pos2(start_x + i as f32 * spacing_x, start_y))
.collect()
⋮----
let has_input_adapter = blocks.iter().any(|b| b.block_type == "input_adapter");
⋮----
block_type: preset_type.to_string(),
⋮----
virtual_input_id = Some(snarl.insert_node(pos, node));
⋮----
for (i, block) in blocks.iter().enumerate() {
⋮----
.any(|(from, to)| *to == i && blocks[*from].block_type == "input_adapter");
⋮----
if virtual_input_id.is_some() {
⋮----
let node_id = snarl.insert_node(pos, node);
node_ids.push(node_id);
⋮----
if !node_ids.is_empty() {
⋮----
snarl.connect(from, to);
⋮----
if !connections.is_empty() {
⋮----
if from_idx < node_ids.len() && to_idx < node_ids.len() {
⋮----
} else if blocks.len() > 1 {
for i in 0..node_ids.len() - 1 {
⋮----
pub fn snarl_to_graph(snarl: &Snarl<ChainNode>) -> (Vec<ProcessingBlock>, Vec<(usize, usize)>) {
⋮----
for (node_id, node) in snarl.node_ids() {
if node.is_input() {
input_node_id = Some(node_id);
⋮----
queue.push_back((start_id, true));
while let Some((node_id, _is_first)) = queue.pop_front() {
if node_to_idx.contains_key(&node_id) {
⋮----
if let Some(node) = snarl.get_node(node_id) {
let block = node.to_block();
let idx = blocks.len();
node_to_idx.insert(node_id, idx);
blocks.push(block);
⋮----
for (from, to) in snarl.wires() {
⋮----
queue.push_back((to.node, false));
⋮----
(node_to_idx.get(&from.node), node_to_idx.get(&to.node))
⋮----
connections.push((from_idx, to_idx));
</file>

<file path="src/gui/settings_ui/node_graph/mod.rs">
pub mod body;
pub mod conversion;
pub mod node;
pub mod utils;
pub mod viewer;
⋮----
pub use node::ChainNode;
pub use utils::request_node_graph_view_reset;
pub use viewer::ChainViewer;
use crate::gui::locale::LocaleText;
use eframe::egui;
use egui_snarl::ui::SnarlStyle;
⋮----
use std::collections::HashMap;
pub fn render_node_graph(
⋮----
snarl.show(&mut viewer, &style, egui::Id::new("chain_graph"), ui);
⋮----
for (out, inp) in snarl.wires() {
⋮----
to_disconnect.push((out, inp));
⋮----
input_count.entry(inp).or_default().push(out);
⋮----
if sources.len() > 1 {
for &src in sources.iter().take(sources.len() - 1) {
to_disconnect.push((src, _inp));
⋮----
snarl.disconnect(out, inp);
</file>

<file path="src/gui/settings_ui/node_graph/utils.rs">
use crate::config::get_all_languages;
use crate::model_config::model_supports_search_by_id;
use eframe::egui;
use std::collections::HashMap;
pub fn model_supports_search(model_id: &str) -> bool {
model_supports_search_by_id(model_id)
⋮----
pub fn request_node_graph_view_reset(ctx: &egui::Context) {
⋮----
ctx.data_mut(|d| d.insert_temp(reset_id, true));
⋮----
pub fn show_language_vars(
⋮----
let tag = format!("{{language{}}}", k);
if prompt.contains(&tag) {
detected_vars.push(k);
⋮----
let key = format!("language{}", num);
if !language_vars.contains_key(&key) {
language_vars.insert(key.clone(), "Vietnamese".to_string());
⋮----
let label = format!("{{language{}}}:", num);
ui.horizontal(|ui| {
ui.label(label);
let current_val = language_vars.get(&key).cloned().unwrap_or_default();
let search_id = egui::Id::new(format!("lang_search_{}", num));
let is_dark = ui.visuals().dark_mode;
⋮----
let button_response = ui.add(
egui::Button::new(egui::RichText::new(&current_val).color(egui::Color32::WHITE))
.fill(lang_var_bg)
.corner_radius(8.0),
⋮----
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
⋮----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
⋮----
ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let _search_response = ui.add(
⋮----
.hint_text("Search...")
.desired_width(110.0),
⋮----
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
ui.separator();
⋮----
.max_height(200.0)
.min_scrolled_height(200.0)
.auto_shrink([true, false])
.show(ui, |ui| {
ui.set_width(120.0);
for lang in get_all_languages() {
let matches_search = search_text.is_empty()
|| lang.to_lowercase().contains(&search_text.to_lowercase());
⋮----
if ui.selectable_label(is_selected, lang).clicked() {
language_vars.insert(key.clone(), lang.clone());
⋮----
ui.data_mut(|d| {
⋮----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
⋮----
pub fn insert_next_language_tag(prompt: &mut String, language_vars: &mut HashMap<String, String>) {
⋮----
if prompt.contains(&format!("{{language{}}}", k)) {
⋮----
let tag = format!(" {{language{}}} ", next_num);
prompt.push_str(&tag);
let key = format!("language{}", next_num);
⋮----
language_vars.insert(key, "Vietnamese".to_string());
</file>

<file path="src/history.rs">
use chrono::Local;
⋮----
use std::fs;
use std::path::PathBuf;
⋮----
use std::thread;
⋮----
pub enum HistoryType {
⋮----
pub struct HistoryItem {
⋮----
pub enum HistoryAction {
⋮----
pub struct HistoryManager {
⋮----
impl HistoryManager {
pub fn new(max_items: usize) -> Self {
let (tx, rx) = channel();
let (_, db_path, _) = get_paths();
let initial_items = if db_path.exists() {
let file = fs::File::open(&db_path).ok();
⋮----
serde_json::from_reader(f).unwrap_or_default()
⋮----
let items_clone = items.clone();
⋮----
process_queue(rx, items_clone, max_items);
⋮----
pub fn save_image(&self, img: ImageBuffer<Rgba<u8>, Vec<u8>>, text: String) {
let _ = self.tx.send(HistoryAction::SaveImage { img, text });
⋮----
pub fn save_audio(&self, wav_data: Vec<u8>, text: String) {
let _ = self.tx.send(HistoryAction::SaveAudio { wav_data, text });
⋮----
pub fn save_text(&self, result_text: String, input_text: String) {
if !result_text.trim().is_empty() {
let _ = self.tx.send(HistoryAction::SaveText {
⋮----
pub fn delete(&self, id: i64) {
let _ = self.tx.send(HistoryAction::Delete(id));
let mut guard = self.items.lock().unwrap();
if let Some(pos) = guard.iter().position(|x| x.id == id) {
guard.remove(pos);
⋮----
pub fn clear_all(&self) {
let _ = self.tx.send(HistoryAction::ClearAll);
⋮----
guard.clear();
⋮----
pub fn request_prune(&self, limit: usize) {
let _ = self.tx.send(HistoryAction::Prune(limit));
⋮----
fn get_paths() -> (PathBuf, PathBuf, PathBuf) {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
let media_dir = config_dir.join("history_media");
let db_path = config_dir.join("history.json");
⋮----
fn save_db(items: &Vec<HistoryItem>) {
⋮----
fn process_queue(
⋮----
let (_, _, media_dir) = get_paths();
while let Ok(action) = rx.recv() {
⋮----
let mut items = cache.lock().unwrap();
⋮----
let timestamp = now.format("%Y-%m-%d %H:%M:%S").to_string();
let filename = format!("img_{}.png", now.format("%Y%m%d_%H%M%S_%f"));
let path = media_dir.join(&filename);
let id = now.timestamp_nanos_opt().unwrap_or(0);
if img.save(&path).is_ok() {
items.insert(
⋮----
let filename = format!("audio_{}.wav", now.format("%Y%m%d_%H%M%S_%f"));
⋮----
if fs::write(&path, wav_data).is_ok() {
⋮----
let filename = format!("text_{}.txt", now.format("%Y%m%d_%H%M%S_%f"));
⋮----
if fs::write(&path, &input_text).is_ok() {
⋮----
if let Some(pos) = items.iter().position(|x| x.id == id) {
let item = items.remove(pos);
let _ = fs::remove_file(media_dir.join(item.media_path));
⋮----
for entry in entries.flatten() {
let _ = fs::remove_file(entry.path());
⋮----
items.clear();
⋮----
if items.len() > max_items {
while items.len() > max_items {
if let Some(item) = items.pop() {
⋮----
save_db(&items);
</file>

<file path="src/overlay/broom_assets.rs">
pub struct BroomRenderParams {
⋮----
pub fn render_procedural_broom(params: BroomRenderParams) -> Vec<u32> {
let mut pixels = vec![0u32; (BROOM_W * BROOM_H) as usize];
⋮----
let handle_rad = (params.tilt_angle * 0.25).to_radians();
let h_sin = handle_rad.sin();
let h_cos = handle_rad.cos();
let bristle_target_rad = (params.tilt_angle * 0.5).to_radians();
⋮----
let b_sin = current_angle.sin();
let b_cos = current_angle.cos();
⋮----
let start_x = (cx - half_w).round() as i32;
let end_x = (cx + half_w).round() as i32;
let py = cy.round() as i32;
⋮----
draw_pixel(px, py, c_shadow, true);
⋮----
let rel_x = (px as f32 - cx).round() as i32;
⋮----
draw_pixel(px, py, col, false);
⋮----
for px in (cx - half_w).round() as i32 ..= (cx + half_w).round() as i32 {
draw_pixel(px, cy.round() as i32, c_band, false);
⋮----
let px = cx.round() as i32;
⋮----
draw_pixel(px, py, c_handle_dk, false);
draw_pixel(px + 1, py, c_handle_lt, false);
</file>

<file path="src/overlay/favorite_bubble/mod.rs">
pub mod html;
pub mod panel;
pub mod render;
pub mod state;
pub mod utils;
pub mod window;
pub use panel::update_favorites_panel;
</file>

<file path="src/overlay/favorite_bubble/utils.rs">
use windows::Win32::Foundation::HWND;
pub struct HwndWrapper(pub HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
</file>

<file path="src/overlay/html_components/js_main.rs">
pub fn get(font_size: u32) -> String {
format!(
</file>

<file path="src/overlay/html_components/mod.rs">
pub mod css_main;
pub mod css_modals;
pub mod font_manager;
pub mod grid_js;
pub mod icons;
pub mod js_logic;
pub mod js_main;
</file>

<file path="src/overlay/input_history.rs">
use std::fs;
use std::path::PathBuf;
use std::sync::Mutex;
⋮----
pub struct InputHistory {
⋮----
impl Default for InputHistory {
fn default() -> Self {
⋮----
impl InputHistory {
fn history_path() -> PathBuf {
⋮----
.unwrap_or_default()
.join("screen-goated-toolbox");
⋮----
config_dir.join("input_history.json")
⋮----
pub fn load() -> Self {
⋮----
if path.exists() {
⋮----
fn save(&self) {
⋮----
pub fn add_entry(&mut self, text: &str) {
let text = text.trim().to_string();
if text.is_empty() {
⋮----
self.entries.retain(|e| e != &text);
self.entries.push(text);
while self.entries.len() > MAX_HISTORY_SIZE {
self.entries.remove(0);
⋮----
self.reset_navigation();
self.save();
⋮----
pub fn navigate_up(&mut self, current_text: &str) -> Option<String> {
if self.entries.is_empty() {
⋮----
self.current_draft = current_text.to_string();
self.nav_index = self.entries.len() as i32;
⋮----
if (self.nav_index as usize) < self.entries.len() {
self.entries.get(self.nav_index as usize).cloned()
⋮----
pub fn navigate_down(&mut self, _current_text: &str) -> Option<String> {
⋮----
if (self.nav_index as usize) >= self.entries.len() {
let draft = self.current_draft.clone();
⋮----
Some(draft)
⋮----
pub fn reset_navigation(&mut self) {
⋮----
self.current_draft.clear();
⋮----
pub fn add_to_history(text: &str) {
if let Ok(mut history) = INPUT_HISTORY.lock() {
history.add_entry(text);
⋮----
pub fn navigate_history_up(current_text: &str) -> Option<String> {
⋮----
history.navigate_up(current_text)
⋮----
pub fn navigate_history_down(current_text: &str) -> Option<String> {
⋮----
history.navigate_down(current_text)
⋮----
pub fn reset_history_navigation() {
⋮----
history.reset_navigation();
</file>

<file path="src/overlay/paint_utils.rs">
pub fn hsv_to_rgb(h: f32, s: f32, v: f32) -> u32 {
⋮----
let x = c * (1.0 - (h_prime % 2.0 - 1.0).abs());
⋮----
pub fn sd_rounded_box(px: f32, py: f32, bx: f32, by: f32, r: f32) -> f32 {
let qx = px.abs() - bx + r;
let qy = py.abs() - by + r;
let len_max_q = (qx.max(0.0).powi(2) + qy.max(0.0).powi(2)).sqrt();
let min_max_q = qx.max(qy).min(0.0);
⋮----
pub unsafe fn draw_direct_sdf_glow(
⋮----
if pixels_ptr.is_null() { return; }
⋮----
let eff_radius = CORNER_RADIUS.min(bx).min(by);
let min_dim = (w as f32).min(h as f32);
let dynamic_base_scale = (min_dim * 0.2).clamp(20.0, 60.0);
⋮----
let time_rad = time_offset.to_radians();
⋮----
let qx = px.abs() - bx + eff_radius;
let qy = py.abs() - by + eff_radius;
⋮----
((qx * qx + qy * qy).sqrt()) - eff_radius
⋮----
qx.max(qy) - eff_radius
⋮----
let t = (d / 2.0).clamp(0.0, 1.0);
⋮----
let dist_in = d.abs();
let t_rough = (dist_in / (dynamic_base_scale * 1.4)).clamp(0.0, 1.0);
let base_intensity_rough = (1.0 - t_rough).powi(3);
⋮----
let angle = py.atan2(px);
let noise = (angle * 4.0 + time_rad * 2.0).sin() * 0.5;
⋮----
let t = (dist_in / local_glow_width).clamp(0.0, 1.0);
let intensity = (1.0 - t).powi(3);
⋮----
let deg = angle.to_degrees() + 180.0;
⋮----
let rgb = if dist_in < 2.5 { 0x00FFFFFF } else { hsv_to_rgb(hue, 0.8, 1.0) };
⋮----
pub unsafe fn draw_minimal_glow(
⋮----
for pixel in pixels.iter_mut() {
⋮----
let scan_y = margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
</file>

<file path="src/overlay/preset_wheel/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn escape_html(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&#39;")
⋮----
fn calculate_row_distribution(n: usize) -> Vec<usize> {
⋮----
return vec![];
⋮----
return vec![1];
⋮----
let cols = ((n as f64 / squish_factor).sqrt().ceil() as usize).max(1);
⋮----
rows.push(base + 1);
⋮----
rows.push(base);
⋮----
pub fn generate_items_html(presets: &[(usize, Preset)], ui_lang: &str) -> String {
let n = presets.len();
let row_distribution = calculate_row_distribution(n);
⋮----
for (row_idx, &items_in_row) in row_distribution.iter().enumerate() {
html.push_str(&format!(
⋮----
if item_idx < presets.len() {
⋮----
let name = escape_html(&get_localized_preset_name(&preset.id, ui_lang));
let color_class = format!("color-{}", item_idx % 12);
⋮----
html.push_str("</div>");
⋮----
/// Returns the static HTML skeleton with CSS and JS (loaded once)
pub fn get_wheel_template(is_dark: bool) -> String {
⋮----
pub fn get_wheel_template(is_dark: bool) -> String {
⋮----
let css = generate_css(is_dark);
let js = get_js();
format!(
⋮----
/// Generate CSS for the wheel with light/dark theme support
pub fn generate_css(is_dark: bool) -> String {
⋮----
pub fn generate_css(is_dark: bool) -> String {
// Theme-specific colors
⋮----
fn get_js() -> &'static str {
</file>

<file path="src/overlay/preset_wheel/mod.rs">
mod html;
mod window;
</file>

<file path="src/overlay/process/mod.rs">
pub mod chain;
pub mod pipeline;
pub mod types;
pub mod window;
</file>

<file path="src/overlay/process/window.rs">
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
use std::collections::HashMap;
⋮----
pub unsafe fn create_processing_window(rect: RECT, graphics_mode: String) -> HWND {
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGTProcessingOverlay");
REGISTER_PROC_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(processing_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_WAIT).unwrap();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
RegisterClassW(&wc);
⋮----
let w = (rect.right - rect.left).abs();
let h = (rect.bottom - rect.top).abs();
⋮----
let hwnd = CreateWindowExW(
⋮----
class_name, w!("Processing"), WS_POPUP, rect.left, rect.top, w, h, None, None, Some(instance.into()), None
).unwrap_or_default();
let mut states = PROC_STATES.lock().unwrap();
states.insert(hwnd.0 as isize, ProcessingState::new(graphics_mode));
drop(states);
SetTimer(Some(hwnd), 1, timer_interval, None);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
unsafe extern "system" fn processing_wnd_proc(hwnd: HWND, msg: u32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
let state = states.entry(hwnd.0 as isize).or_insert(ProcessingState::new("standard".to_string()));
⋮----
let _ = KillTimer(Some(hwnd), 1); state.timer_killed = true;
SetTimer(Some(hwnd), 2, 25, None);
⋮----
LRESULT(0)
⋮----
let _ = KillTimer(Some(hwnd), 1); let _ = KillTimer(Some(hwnd), 2);
let _ = DestroyWindow(hwnd);
return LRESULT(0);
⋮----
let mut rect = RECT::default(); let _ = GetWindowRect(hwnd, &mut rect);
let w = (rect.right - rect.left).abs(); let h = (rect.bottom - rect.top).abs();
⋮----
let state = states.get_mut(&(hwnd.0 as isize)).unwrap();
⋮----
(MAX_GLOW_BUFFER_DIM as f32 / w as f32).min(MAX_GLOW_BUFFER_DIM as f32 / h as f32).min(1.0)
⋮----
let buf_w = ((w as f32) * scale_factor).ceil() as i32;
let buf_h = ((h as f32) * scale_factor).ceil() as i32;
if state.cache_hbm.is_invalid() || state.scaled_w != buf_w || state.scaled_h != buf_h {
state.cleanup();
let screen_dc = GetDC(None);
⋮----
let res = CreateDIBSection(Some(screen_dc), &bmi, DIB_RGB_COLORS, &mut state.cache_bits, None, 0);
ReleaseDC(None, screen_dc);
if let Ok(hbm) = res { if !hbm.is_invalid() && !state.cache_bits.is_null() { state.cache_hbm = hbm; state.scaled_w = buf_w; state.scaled_h = buf_h; } else { return LRESULT(0); } } else { return LRESULT(0); }
⋮----
if !is_fading && !state.cache_bits.is_null() {
⋮----
let scaled_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(scaled_dc, state.cache_hbm.into());
⋮----
let dest_hbm = CreateDIBSection(Some(screen_dc), &dest_bmi, DIB_RGB_COLORS, &mut dest_bits, None, 0);
⋮----
if !hbm.is_invalid() {
let dest_dc = CreateCompatibleDC(Some(screen_dc)); SelectObject(dest_dc, hbm.into());
SetStretchBltMode(dest_dc, HALFTONE); let _ = StretchBlt(dest_dc, 0, 0, w, h, Some(scaled_dc), 0, 0, state.scaled_w, state.scaled_h, SRCCOPY);
let _ = DeleteDC(scaled_dc); (Some((dest_dc, hbm)), w, h)
} else { let _ = DeleteDC(scaled_dc); (None, state.scaled_w, state.scaled_h) }
⋮----
let (mem_dc, old_hbm, temp_res) = if let Some((dc, hbm)) = final_hbm { (dc, HGDIOBJ::default(), Some(hbm)) } else { let dc = CreateCompatibleDC(Some(screen_dc)); let old = SelectObject(dc, state.cache_hbm.into()); (dc, old, None) };
⋮----
let _ = UpdateLayeredWindow(hwnd, None, None, Some(&size), Some(mem_dc), Some(&pt_src), COLORREF(0), Some(&blend), ULW_ALPHA);
if temp_res.is_some() { let _ = DeleteDC(mem_dc); if let Some(hbm) = temp_res { let _ = DeleteObject(hbm.into()); } } else { SelectObject(mem_dc, old_hbm); let _ = DeleteDC(mem_dc); }
⋮----
WM_PAINT => { let mut ps = PAINTSTRUCT::default(); BeginPaint(hwnd, &mut ps); let _ = EndPaint(hwnd, &mut ps); LRESULT(0) }
WM_DESTROY => { let mut states = PROC_STATES.lock().unwrap(); if let Some(mut state) = states.remove(&(hwnd.0 as isize)) { state.cleanup(); } LRESULT(0) }
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/realtime_egui.rs">
use crate::APP;
use eframe::egui;
⋮----
use std::sync::Mutex;
⋮----
struct RealtimeUiState {
⋮----
impl Default for RealtimeUiState {
fn default() -> Self {
⋮----
pub fn show_realtime_egui_overlay(preset_idx: usize) {
if MINIMAL_ACTIVE.load(Ordering::SeqCst) || unsafe { IS_ACTIVE } {
⋮----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
⋮----
let mut state = REALTIME_STATE.lock().unwrap();
⋮----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
REALTIME_TTS_ENABLED.store(false, Ordering::SeqCst);
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() { name.clear(); }
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() { queue.clear(); }
USER_REQUESTED_CLOSE.store(false, Ordering::SeqCst);
MINIMAL_ACTIVE.store(true, Ordering::SeqCst);
MINIMAL_PRESET_IDX.store(preset_idx, Ordering::SeqCst);
let app = APP.lock().unwrap();
let preset = app.config.presets[preset_idx].clone();
⋮----
let config_language = app.config.realtime_target_language.clone();
let config_audio_source = app.config.realtime_audio_source.clone();
drop(app);
⋮----
if let Ok(mut ui_state) = UI_STATE.lock() {
⋮----
ui_state.apps_list.clear();
⋮----
ui_state.committed_segments.clear();
⋮----
let effective_source = if config_audio_source.is_empty() { "device".to_string() } else { config_audio_source };
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = effective_source.clone();
⋮----
if !config_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = config_language.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
⋮----
let mut final_preset = preset.clone();
⋮----
start_realtime_transcription(
⋮----
REALTIME_STOP_SIGNAL.clone(),
⋮----
Some(windows::Win32::Foundation::HWND::default()),
REALTIME_STATE.clone(),
⋮----
if let Ok(guard) = crate::gui::GUI_CONTEXT.lock() {
if let Some(ctx) = guard.as_ref() {
ctx.request_repaint();
⋮----
pub fn render_minimal_overlay(ctx: &egui::Context) {
if !MINIMAL_ACTIVE.load(Ordering::SeqCst) {
⋮----
if USER_REQUESTED_CLOSE.load(Ordering::SeqCst) {
MINIMAL_ACTIVE.store(false, Ordering::SeqCst);
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
⋮----
let mut ui_state = UI_STATE.lock().unwrap();
let ui_language = APP.lock().map(|a| a.config.ui_language.clone()).unwrap_or_else(|_| "en".to_string());
⋮----
ctx.show_viewport_immediate(
⋮----
.with_inner_size([700.0, 200.0])
.with_title(title)
.with_always_on_top(),
⋮----
if ctx.input(|i| i.viewport().close_requested()) {
USER_REQUESTED_CLOSE.store(true, Ordering::SeqCst);
⋮----
egui::CentralPanel::default().show(ctx, |ui| {
render_main_ui(ui, &mut ui_state);
⋮----
fn render_main_ui(ui: &mut egui::Ui, state: &mut RealtimeUiState) {
let current_source = NEW_AUDIO_SOURCE.lock().map(|s| s.clone()).unwrap_or_else(|_| "mic".to_string());
⋮----
let app_pid = SELECTED_APP_PID.load(Ordering::SeqCst);
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
⋮----
ui.horizontal(|ui| {
⋮----
ui.label(egui::RichText::new(locale.device_mode_warning)
.color(egui::Color32::from_rgb(255, 180, 100)).size(11.0));
if ui.small_button(locale.select_app_btn).clicked() {
⋮----
if state.apps_list.is_empty() {
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
if ui.selectable_label(state.show_translation, "🌐").on_hover_text(locale.toggle_translation_tooltip).clicked() {
⋮----
TRANS_VISIBLE.store(state.show_translation, Ordering::SeqCst);
⋮----
if ui.selectable_label(state.show_transcription, "📝").on_hover_text(locale.toggle_transcription_tooltip).clicked() {
⋮----
MIC_VISIBLE.store(state.show_transcription, Ordering::SeqCst);
⋮----
ui.separator();
if ui.small_button("➖").on_hover_text(locale.font_minus_tooltip).clicked() {
state.font_size = (state.font_size - 2.0).max(10.0);
if let Ok(mut app) = APP.lock() {
⋮----
if ui.small_button("➕").on_hover_text(locale.font_plus_tooltip).clicked() {
state.font_size = (state.font_size + 2.0).min(40.0);
⋮----
if ui.small_button(tts_label).on_hover_text(locale.tts_settings_title).clicked() {
⋮----
let current_model = APP.lock().map(|a| a.config.realtime_translation_model.clone()).unwrap_or_default();
let model_label = match current_model.as_str() {
⋮----
ui.menu_button(model_label, |ui| {
if ui.selectable_label(current_model == "cerebras-oss", "🔥 Cerebras").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "cerebras-oss".to_string(); }
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "cerebras-oss".to_string(); }
ui.close();
⋮----
if ui.selectable_label(current_model == "google-gemma", "✨ Gemma").clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gemma".to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gemma".to_string(); }
⋮----
if ui.selectable_label(current_model == "google-gtx", format!("🌍 {}", locale.google_gtx_label)).clicked() {
if let Ok(mut m) = NEW_TRANSLATION_MODEL.lock() { *m = "google-gtx".to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_translation_model = "google-gtx".to_string(); }
⋮----
let current_lang = NEW_TARGET_LANGUAGE.lock().map(|l| if l.is_empty() { "English".to_string() } else { l.clone() }).unwrap_or_else(|_| "English".to_string());
⋮----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| current_lang.chars().take(2).collect::<String>().to_uppercase());
let btn_resp = ui.button(&lang_code);
if btn_resp.clicked() {
egui::Popup::toggle_id(ui.ctx(), btn_resp.id);
⋮----
.close_behavior(egui::PopupCloseBehavior::CloseOnClickOutside)
.show(|ui| {
ui.set_min_width(120.0);
⋮----
let mut search_text: String = ui.data_mut(|d| d.get_temp(search_id).unwrap_or_default());
let response = ui.add(egui::TextEdit::singleline(&mut search_text).hint_text("Search...").desired_width(120.0));
if response.changed() {
ui.data_mut(|d| d.insert_temp(search_id, search_text.clone()));
⋮----
if response.clicked() {
response.request_focus();
⋮----
egui::ScrollArea::vertical().max_height(250.0).show(ui, |ui| {
⋮----
let matches = search_text.is_empty() || lang.to_lowercase().contains(&search_text.to_lowercase());
⋮----
if ui.selectable_label(current_lang == *lang, lang).clicked() {
if let Ok(mut l) = NEW_TARGET_LANGUAGE.lock() { *l = lang.to_string(); }
⋮----
if let Ok(mut app) = APP.lock() { app.config.realtime_target_language = lang.to_string(); }
ui.data_mut(|d| d.remove_temp::<String>(search_id));
egui::Popup::toggle_id(ui.ctx(), popup_id);
⋮----
if ui.selectable_label(!is_device_mode, "🎤").on_hover_text(locale.audio_src_mic).clicked() {
if let Ok(mut s) = NEW_AUDIO_SOURCE.lock() { *s = "mic".to_string(); }
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
if let Ok(mut app) = APP.lock() { app.config.realtime_audio_source = "mic".to_string(); }
⋮----
if ui.selectable_label(is_device_mode, "🔊").on_hover_text(locale.audio_src_device).clicked() {
⋮----
ui.add_enabled_ui(can_enable_tts, |ui| {
if ui.checkbox(&mut tts_on, "TTS").changed() {
⋮----
REALTIME_TTS_ENABLED.store(true, Ordering::SeqCst);
⋮----
let current_speed = CURRENT_TTS_SPEED.load(Ordering::Relaxed);
let base_speed = REALTIME_TTS_SPEED.load(Ordering::Relaxed);
let auto_speed = REALTIME_TTS_AUTO_SPEED.load(Ordering::Relaxed);
ui.label(format!("{:.1}x", current_speed as f32 / 100.0));
⋮----
if ui.add(egui::Slider::new(&mut speed_val, 50..=200).show_value(false)).changed() {
REALTIME_TTS_SPEED.store(speed_val as u32, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
⋮----
if ui.checkbox(&mut auto_on, locale.realtime_tts_auto).changed() {
REALTIME_TTS_AUTO_SPEED.store(auto_on, Ordering::SeqCst);
⋮----
ui.label(egui::RichText::new(locale.app_select_title).strong().size(11.0));
if ui.small_button("🔄").clicked() {
⋮----
if ui.small_button("✖").clicked() {
⋮----
let selected_name = SELECTED_APP_NAME.lock().map(|n| n.clone()).unwrap_or_default();
if !selected_name.is_empty() {
ui.label(egui::RichText::new(format!("✓ {}", selected_name)).color(egui::Color32::GREEN).size(10.0));
⋮----
egui::ScrollArea::vertical().max_height(80.0).id_salt("app_list").show(ui, |ui| {
for (pid, name) in state.apps_list.clone() {
⋮----
let display = if name.chars().count() > 40 {
format!("{}...", name.chars().take(37).collect::<String>())
⋮----
name.clone()
⋮----
if ui.selectable_label(is_selected, &display).clicked() {
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.clone();
⋮----
*new_source = "device".to_string();
⋮----
let state_data = REALTIME_STATE.lock().unwrap();
⋮----
if state.show_translation && TRANS_VISIBLE.load(Ordering::SeqCst) {
⋮----
let old_len = committed.len();
let is_mic_mode = current_source.is_empty() || current_source == "mic";
⋮----
let current_tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
if current_tts_enabled && tts_allowed && !committed.is_empty() {
⋮----
let text = committed.trim_end();
let search_limit = text.len().saturating_sub(1);
⋮----
if let Some(idx) = text[..search_limit].rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n') {
⋮----
let new_committed = committed[state.last_spoken_len..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
⋮----
crate::api::tts::TTS_MANAGER.speak_realtime(&text_to_speak, 0);
⋮----
state_data.full_transcript.clone(),
⋮----
state_data.committed_translation.clone(),
state_data.uncommitted_translation.clone(),
⋮----
drop(state_data);
let available_height = ui.available_height();
let rect = ui.ctx().input(|i| i.viewport().inner_rect);
let current_window_size = rect.map(|r| r.size()).unwrap_or(egui::Vec2::ZERO);
let current_len = committed_translation.len();
⋮----
state.committed_segments.clear();
⋮----
let new_segment = committed_translation[state.last_committed_len..].to_string();
state.committed_segments.push(new_segment);
⋮----
let window_resized = (current_window_size - state.prev_window_size).length() > 1.0;
⋮----
let has_content = !committed_translation.is_empty() || !uncommitted_translation.is_empty();
⋮----
let available_width = ui.available_width();
let col_width = ((available_width - 10.0) / 2.0).max(1.0);
let content_height = available_height.max(50.0);
⋮----
ui.vertical(|ui| {
ui.set_width(col_width);
ui.set_min_height(content_height);
⋮----
.id_salt("trans_scroll")
.auto_shrink([false, false])
.stick_to_bottom(true)
.show(ui, |ui| {
render_transcript(ui, &full_transcript, last_committed_pos, &font);
⋮----
.id_salt("transl_scroll")
⋮----
render_translation(ui, &state.committed_segments, &uncommitted_translation, &font);
⋮----
ui.scroll_to_cursor(Some(egui::Align::BOTTOM));
⋮----
.id_salt("trans_full")
⋮----
.id_salt("transl_full")
⋮----
fn render_transcript(ui: &mut egui::Ui, full: &str, split_pos: usize, font: &egui::FontId) {
let split_idx = split_pos.min(full.len());
let split_idx = if full.is_char_boundary(split_idx) { split_idx } else {
full.char_indices().take_while(|(i, _)| *i < split_idx).last().map(|(i, c)| i + c.len_utf8()).unwrap_or(0)
⋮----
let committed = full[..split_idx].trim_end();
let uncommitted = full[split_idx..].trim_start();
let dark_mode = ui.visuals().dark_mode;
ui.horizontal_wrapped(|ui| {
ui.spacing_mut().item_spacing.x = 0.0;
if !committed.is_empty() {
ui.label(egui::RichText::new(committed).font(font.clone()).color(get_text_color(true, dark_mode)));
⋮----
if !uncommitted.is_empty() {
if !committed.is_empty() { ui.label(" "); }
⋮----
ui.label(egui::RichText::new(uncommitted).font(font.clone()).color(color).italics());
⋮----
fn render_translation(ui: &mut egui::Ui, segments: &[String], uncommitted: &str, font: &egui::FontId) {
let uncommitted = uncommitted.trim_start();
⋮----
for (i, segment) in segments.iter().enumerate() {
let color = get_segment_color(i, dark_mode);
ui.label(egui::RichText::new(segment).font(font.clone()).color(color));
⋮----
fn tr(key: &str, lang: &str) -> String {
⋮----
"device_mode_warning" => "⚠ Đã chọn âm thanh thiết bị nhưng chưa chọn ứng dụng".to_string(),
"select_app" => "Chọn ứng dụng".to_string(),
"toggle_translation" => "Tắt/Mở dịch".to_string(),
"toggle_transcription" => "Tắt/Mở phụ đề".to_string(),
"font_minus" => "Giảm cỡ chữ".to_string(),
"font_plus" => "Tăng cỡ chữ".to_string(),
"tts_settings" => "Cài đặt đọc văn bản (TTS)".to_string(),
"microphone" => "Microphone".to_string(),
"system_audio" => "Âm thanh hệ thống".to_string(),
"select_app_title" => "🎧 Chọn ứng dụng để thu âm".to_string(),
"auto" => "Tự động".to_string(),
_ => key.to_string(),
⋮----
"device_mode_warning" => "⚠ Device audio selected but no app chosen".to_string(),
"select_app" => "Select App".to_string(),
"toggle_translation" => "Toggle Translation".to_string(),
"toggle_transcription" => "Toggle Transcription".to_string(),
"font_minus" => "Font -".to_string(),
"font_plus" => "Font +".to_string(),
"tts_settings" => "TTS Settings".to_string(),
⋮----
"system_audio" => "System Audio".to_string(),
"select_app_title" => "🎧 Select App to Record".to_string(),
"auto" => "Auto".to_string(),
⋮----
fn get_segment_color(index: usize, dark_mode: bool) -> egui::Color32 {
⋮----
fn get_text_color(is_committed: bool, dark_mode: bool) -> egui::Color32 {
</file>

<file path="src/overlay/result/logic.rs">
fn rand_float(min: f32, max: f32) -> f32 {
⋮----
SEED = SEED.wrapping_mul(1103515245).wrapping_add(12345);
⋮----
pub fn handle_timer(hwnd: HWND, wparam: WPARAM) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
for mut pt in p.particles.drain(..) {
⋮----
keep.push(pt);
⋮----
.duration_since(std::time::UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
let time_since_resize = now.wrapping_sub(state.last_resize_time);
⋮----
let _ = GetClientRect(hwnd, &mut client_rect);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&bottom_region), false);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&left_margin), false);
⋮----
let _ = InvalidateRect(Some(hwnd), Some(&right_margin), false);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
if IsWindow(Some(linked)).as_bool() {
let _ = SetLayeredWindowAttributes(linked, COLORREF(0), 0, LWA_ALPHA);
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = KillTimer(Some(hwnd), 1);
⋮----
state.physics.particles.push(DustParticle {
x: cx + rand_float(-10.0, 10.0),
⋮----
vx: rand_float(-2.0, 2.0),
vy: rand_float(-2.0, -5.0),
⋮----
size: rand_float(1.0, 3.0),
</file>

<file path="src/win_types.rs">
use windows::Win32::UI::WindowsAndMessaging::HHOOK;
use windows::Win32::Graphics::Gdi::HBITMAP;
⋮----
pub struct SendHwnd(pub HWND);
unsafe impl Send for SendHwnd {}
unsafe impl Sync for SendHwnd {}
impl Default for SendHwnd {
fn default() -> Self {
SendHwnd(HWND::default())
⋮----
impl SendHwnd {
pub fn is_invalid(&self) -> bool {
self.0.is_invalid()
⋮----
pub fn as_isize(&self) -> isize {
⋮----
pub fn from_isize(val: isize) -> Self {
SendHwnd(HWND(val as *mut std::ffi::c_void))
⋮----
pub struct SendHandle(pub HANDLE);
unsafe impl Send for SendHandle {}
unsafe impl Sync for SendHandle {}
impl SendHandle {
⋮----
pub struct SendHhook(pub HHOOK);
unsafe impl Send for SendHhook {}
unsafe impl Sync for SendHhook {}
impl Default for SendHhook {
⋮----
SendHhook(HHOOK::default())
⋮----
pub struct SendHbitmap(pub HBITMAP);
unsafe impl Send for SendHbitmap {}
unsafe impl Sync for SendHbitmap {}
impl Default for SendHbitmap {
⋮----
SendHbitmap(HBITMAP::default())
⋮----
impl SendHbitmap {
</file>

<file path=".cargo/config.toml">
[build]
# Optimize compilation
rustflags = [
    "-Z", "location-detail=none",
    "-C", "target-cpu=native",
    "-C", "target-feature=+crt-static"
]

[target.x86_64-pc-windows-msvc]
rustflags = [
    "-C", "target-feature=+crt-static"
]
</file>

<file path="build.ps1">
# Re-patch egui-snarl to ensure custom scroll-to-zoom is applied
Write-Host "Setting up patched egui-snarl..." -ForegroundColor Cyan
$snarlDir = Join-Path $PSScriptRoot "libs\egui-snarl"
if (Test-Path $snarlDir) {
    Remove-Item $snarlDir -Recurse -Force
}
& (Join-Path $PSScriptRoot "scripts\setup-egui-snarl.ps1")

# --- Build PromptDJ Frontend ---
Write-Host "Building PromptDJ Frontend..." -ForegroundColor Cyan
$pdjDir = Join-Path $PSScriptRoot "promptdj-midi"
$pdjDist = Join-Path $pdjDir "dist"
$pdjTargetDist = Join-Path $PSScriptRoot "src\overlay\prompt_dj\dist"

Push-Location $pdjDir
try {
    npm run build
}
finally {
    Pop-Location
}

if (Test-Path $pdjDist) {
    if (-not (Test-Path $pdjTargetDist)) {
        New-Item -ItemType Directory -Path $pdjTargetDist -Force | Out-Null
    }
    Copy-Item -Path "$pdjDist\*" -Destination $pdjTargetDist -Recurse -Force
    Write-Host "PromptDJ assets synchronized." -ForegroundColor Green
}
else {
    Write-Host "FAILED: PromptDJ build did not produce dist folder." -ForegroundColor Red
    exit 1
}

# --- Continue Main Build ---
# Extract version from Cargo.toml
$cargoContent = Get-Content "Cargo.toml" -Raw
if ($cargoContent -match 'version\s*=\s*"([^"]+)"') {
    $version = $matches[1]
}
else {
    Write-Host "Failed to extract version from Cargo.toml" -ForegroundColor Red
    exit 1
}

# Output paths
$outputExeName = "ScreenGoatedToolbox_v$version.exe"
$outputPath = "target/release/$outputExeName"
$exePathRelease = "target/release/screen-goated-toolbox.exe"

# =============================================================================
# Build Release version (LTO optimized + stripped)
# =============================================================================
Write-Host ""
Write-Host "=== Building ScreenGoatedToolbox v$version ===" -ForegroundColor Cyan
Write-Host "Using 'release' profile (LTO + stripped)..." -ForegroundColor Gray
cargo build --release

if (Test-Path $exePathRelease) {
    if (Test-Path $outputPath) {
        Remove-Item $outputPath
    }
    Move-Item $exePathRelease $outputPath
    $size = (Get-Item $outputPath).Length / 1MB
    Write-Host "  -> Created: $outputExeName ($([Math]::Round($size, 2)) MB)" -ForegroundColor Green
}
else {
    Write-Host "  -> FAILED: release build did not produce exe" -ForegroundColor Red
    exit 1
}

# =============================================================================
# SUMMARY
# =============================================================================
Write-Host ""
Write-Host "=======================================" -ForegroundColor White
Write-Host "         BUILD COMPLETE v$version" -ForegroundColor White
Write-Host "=======================================" -ForegroundColor White
Write-Host ""
Write-Host "  $outputExeName" -ForegroundColor Green
Write-Host "  Size: $([Math]::Round($size, 2)) MB" -ForegroundColor Gray
Write-Host ""
</file>

<file path="src/api/audio.rs">
use super::client::UREQ_AGENT;
use crate::config::Preset;
⋮----
use crate::win_types::SendHwnd;
use crate::APP;
use anyhow::Result;
⋮----
fn encode_wav(samples: &[i16], sample_rate: u32, channels: u16) -> Vec<u8> {
⋮----
hound::WavWriter::new(&mut wav_cursor, spec).expect("Failed to create memory writer");
⋮----
.write_sample(*sample)
.expect("Failed to write sample");
⋮----
writer.finalize().expect("Failed to finalize WAV");
⋮----
wav_cursor.into_inner()
⋮----
pub fn transcribe_audio_gemini<F>(
⋮----
if gemini_api_key.trim().is_empty() {
return Err(anyhow::anyhow!("NO_API_KEY:google"));
⋮----
let b64_audio = general_purpose::STANDARD.encode(&wav_data);
let url = format!(
⋮----
if !model.contains("gemma-3-27b-it") {
⋮----
.post(&url)
.header("x-goog-api-key", gemini_api_key)
.send_json(payload)
.map_err(|e| {
let err_str = e.to_string();
if err_str.contains("401") || err_str.contains("403") {
⋮----
let reader = BufReader::new(resp.into_body().into_reader());
for line in reader.lines() {
let line = line.map_err(|e| anyhow::anyhow!("Failed to read line: {}", e))?;
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
if let Some(candidates) = chunk_resp.get("candidates").and_then(|c| c.as_array()) {
if let Some(first_candidate) = candidates.first() {
⋮----
.get("content")
.and_then(|c| c.get("parts"))
.and_then(|p| p.as_array())
⋮----
if let Some(first_part) = parts.first() {
if let Some(text) = first_part.get("text").and_then(|t| t.as_str())
⋮----
full_content.push_str(text);
on_chunk(text);
⋮----
if full_content.is_empty() {
return Err(anyhow::anyhow!("No content received from Gemini Audio API"));
⋮----
Ok(full_content)
⋮----
fn transcribe_with_gemini_live_input(api_key: &str, wav_data: Vec<u8>) -> anyhow::Result<String> {
⋮----
use crate::overlay::recording::AUDIO_INITIALIZING;
⋮----
println!(
⋮----
AUDIO_INITIALIZING.store(true, Ordering::SeqCst);
println!("[GeminiLiveInput] Connecting to WebSocket...");
let mut socket = match connect_websocket(api_key) {
⋮----
println!("[GeminiLiveInput] WebSocket connected successfully");
⋮----
println!("[GeminiLiveInput] WebSocket connection failed: {}", e);
AUDIO_INITIALIZING.store(false, Ordering::SeqCst);
return Err(e);
⋮----
println!("[GeminiLiveInput] Sending setup message...");
if let Err(e) = send_setup_message(&mut socket) {
println!("[GeminiLiveInput] Setup message failed: {}", e);
⋮----
if let Err(e) = set_socket_short_timeout(&mut socket) {
⋮----
println!("[GeminiLiveInput] Waiting for setupComplete...");
⋮----
match socket.read() {
⋮----
let msg = msg.as_str();
⋮----
if msg.contains("setupComplete") {
println!("[GeminiLiveInput] Setup complete received!");
⋮----
if msg.contains("error") || msg.contains("Error") {
println!("[GeminiLiveInput] Server error: {}", msg);
⋮----
return Err(anyhow::anyhow!("Server returned error: {}", msg));
⋮----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if text.contains("setupComplete") {
println!("[GeminiLiveInput] Setup complete (from binary)!");
⋮----
println!("[GeminiLiveInput] Received other message type: {:?}", other);
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock
|| e.kind() == std::io::ErrorKind::TimedOut =>
⋮----
if setup_start.elapsed() > Duration::from_secs(30) {
println!("[GeminiLiveInput] Setup timeout after 30s");
⋮----
return Err(anyhow::anyhow!("Setup timeout"));
⋮----
println!("[GeminiLiveInput] Socket error during setup: {}", e);
⋮----
return Err(e.into());
⋮----
if let Err(e) = set_socket_nonblocking(&mut socket) {
⋮----
crate::overlay::recording::AUDIO_WARMUP_COMPLETE.store(true, Ordering::SeqCst);
println!("[GeminiLiveInput] Extracting PCM samples from WAV...");
let pcm_samples = extract_pcm_from_wav(&wav_data)?;
⋮----
println!("[GeminiLiveInput] Sending audio chunks...");
while offset < pcm_samples.len() {
let end = (offset + chunk_size).min(pcm_samples.len());
⋮----
if send_audio_chunk(&mut socket, chunk).is_err() {
⋮----
if let Some(transcript) = parse_input_transcription(msg) {
if !transcript.is_empty() {
println!("[GeminiLiveInput] Got transcript: '{}'", transcript);
⋮----
accumulated_text.push_str(&transcript);
⋮----
if let Some(transcript) = parse_input_transcription(&text) {
⋮----
while conclude_start.elapsed() < conclude_duration {
⋮----
println!("[GeminiLiveInput] Got final transcript: '{}'", transcript);
⋮----
let _ = socket.close(None);
⋮----
println!("[GeminiLiveInput] Final result: '{}'", accumulated_text);
if accumulated_text.is_empty() {
Ok(String::new())
⋮----
Ok(accumulated_text)
⋮----
fn extract_pcm_from_wav(wav_data: &[u8]) -> anyhow::Result<Vec<i16>> {
use std::io::Cursor;
⋮----
let spec = reader.spec();
⋮----
.filter_map(|s| s.ok())
.collect(),
⋮----
.map(|f| (f * i16::MAX as f32) as i16)
⋮----
.chunks(spec.channels as usize)
.map(|chunk| {
let sum: i32 = chunk.iter().map(|&s| s as i32).sum();
(sum / chunk.len() as i32) as i16
⋮----
.collect()
⋮----
let new_len = (mono_samples.len() as f64 * ratio) as usize;
⋮----
if src_idx < mono_samples.len() {
resampled.push(mono_samples[src_idx]);
⋮----
Ok(resampled)
⋮----
Ok(mono_samples)
⋮----
fn resample_to_16khz(samples: &[i16], source_rate: u32) -> Vec<i16> {
⋮----
return samples.to_vec();
⋮----
let new_len = (samples.len() as f64 * ratio) as usize;
⋮----
if src_idx < samples.len() {
resampled.push(samples[src_idx]);
⋮----
enum AudioMode {
⋮----
fn try_reconnect(
⋮----
use std::sync::atomic::Ordering;
⋮----
if stop_signal.load(Ordering::Relaxed) {
println!("[GeminiLiveStream] Stop signal received during reconnection.");
⋮----
let mut buf = audio_buffer.lock().unwrap();
reconnect_buffer.extend(std::mem::take(&mut *buf));
⋮----
match connect_websocket(api_key) {
⋮----
if send_setup_message(&mut new_socket).is_err() {
⋮----
if set_socket_nonblocking(&mut new_socket).is_err() {
let _ = new_socket.close(None);
⋮----
silence_buffer.clear();
silence_buffer.extend(reconnect_buffer);
⋮----
pub fn record_and_stream_gemini_live(
⋮----
use std::sync::Mutex;
⋮----
println!("[GeminiLiveStream] Starting real-time streaming...");
⋮----
.iter()
.find(|b| b.block_type == "audio")
.or_else(|| preset.blocks.first());
⋮----
.map(|b| {
⋮----
.unwrap_or(false);
⋮----
struct WindowGuard(HWND);
impl Drop for WindowGuard {
fn drop(&mut self) {
⋮----
let _ = PostMessageW(Some(self.0), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let preset_for_thread = preset.clone();
⋮----
let screen_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let screen_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
let (rect, _) = if preset_for_thread.blocks.len() > 1 {
⋮----
Some(RECT {
⋮----
.or_else(|| preset_for_thread.blocks.first());
let model_id = active_block.map(|b| b.model.clone()).unwrap_or_default();
⋮----
.map(|b| b.render_mode.clone())
.unwrap_or_default();
⋮----
.map(|m| m.provider)
.unwrap_or("gemini".to_string());
let hwnd = create_result_window(
⋮----
get_chain_color(0),
⋮----
"Listening...".to_string(),
⋮----
let _ = ShowWindow(hwnd, SW_SHOW);
⋮----
let _ = tx.send(SendHwnd(hwnd));
⋮----
while GetMessageW(&mut m, None, 0, 0).into() {
let _ = TranslateMessage(&m);
DispatchMessageW(&m);
if !IsWindow(Some(hwnd)).as_bool() {
⋮----
if let Ok(SendHwnd(h)) = rx.recv() {
streaming_hwnd = Some(h);
⋮----
let _window_guard = streaming_hwnd.map(WindowGuard);
⋮----
update_window_text(h, text);
⋮----
let app = APP.lock().unwrap();
app.config.gemini_api_key.clone()
⋮----
eprintln!("[GeminiLiveStream] No API key");
⋮----
let _ = PostMessageW(Some(overlay_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
println!("[GeminiLiveStream] Connecting WebSocket...");
let mut socket = match connect_websocket(&gemini_api_key) {
⋮----
println!("[GeminiLiveStream] Connected");
⋮----
println!("[GeminiLiveStream] Connection failed: {}", e);
⋮----
println!("[GeminiLiveStream] Setup failed: {}", e);
⋮----
let _ = set_socket_short_timeout(&mut socket);
⋮----
if msg.as_str().contains("setupComplete") {
⋮----
if String::from_utf8(data.to_vec())
.map(|t| t.contains("setupComplete"))
.unwrap_or(false)
⋮----
let _ = set_socket_nonblocking(&mut socket);
⋮----
println!("[GeminiLiveStream] Setup complete, starting audio...");
⋮----
cpal::host_from_id(cpal::HostId::Wasapi).unwrap_or(cpal::default_host())
⋮----
match host.default_output_device() {
⋮----
match host.default_input_device() {
⋮----
.default_output_config()
.or_else(|_| device.default_input_config())
⋮----
device.default_input_config()
⋮----
let sample_rate = config.sample_rate();
let channels = config.channels() as usize;
⋮----
let audio_buffer_clone = audio_buffer.clone();
let full_buffer_clone = full_audio_buffer.clone();
let pause_clone = pause_signal.clone();
let stream = match config.sample_format() {
cpal::SampleFormat::F32 => device.build_input_stream(
&config.into(),
⋮----
if pause_clone.load(Ordering::Relaxed) {
⋮----
rms = (rms / data.len() as f32).sqrt();
⋮----
data.chunks(channels)
.map(|c| {
((c.iter().sum::<f32>() / channels as f32) * i16::MAX as f32) as i16
⋮----
data.iter().map(|&f| (f * i16::MAX as f32) as i16).collect()
⋮----
let resampled = resample_to_16khz(&mono, sample_rate);
if let Ok(mut buf) = audio_buffer_clone.lock() {
buf.extend(resampled.clone());
⋮----
if let Ok(mut full) = full_buffer_clone.lock() {
full.extend(resampled);
⋮----
|e| eprintln!("Stream error: {}", e),
⋮----
cpal::SampleFormat::I16 => device.build_input_stream(
⋮----
.map(|c| (c.iter().map(|&s| s as i32).sum::<i32>() / c.len() as i32) as i16)
⋮----
data.to_vec()
⋮----
if stream.play().is_err() {
⋮----
println!("[GeminiLiveStream] Streaming audio...");
⋮----
while !stop_signal.load(Ordering::SeqCst) && !abort_signal.load(Ordering::SeqCst) {
if !preset.hide_recording_ui && !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
⋮----
if mode_start.elapsed() >= NORMAL_DURATION {
⋮----
if mode_start.elapsed() >= SILENCE_DURATION {
⋮----
if silence_buffer.is_empty() {
⋮----
if last_send.elapsed() >= send_interval {
⋮----
if !real_audio.is_empty() && !pause_signal.load(Ordering::Relaxed) {
for chunk in real_audio.chunks(chunk_size) {
⋮----
silence_buffer.extend(real_audio);
let silence: Vec<i16> = vec![0i16; SAMPLES_PER_100MS];
if send_audio_chunk(&mut socket, &silence).is_err() {
⋮----
let to_send: Vec<i16> = if silence_buffer.len() >= double_chunk {
silence_buffer.drain(..double_chunk).collect()
} else if !silence_buffer.is_empty() {
silence_buffer.drain(..).collect()
⋮----
if !to_send.is_empty() {
if send_audio_chunk(&mut socket, &to_send).is_err() {
⋮----
if let Some(t) = parse_input_transcription(msg.as_str()) {
if !t.is_empty() {
⋮----
if let Ok(mut txt) = accumulated_text.lock() {
txt.push_str(&t);
update_stream_text(&txt);
⋮----
if let Ok(s) = String::from_utf8(data.to_vec()) {
if let Some(t) = parse_input_transcription(&s) {
⋮----
if !try_reconnect(
⋮----
&& last_transcription_time.elapsed()
⋮----
let error_str = e.to_string();
if error_str.contains("reset")
|| error_str.contains("closed")
|| error_str.contains("broken")
⋮----
if auto_stop && !pause_signal.load(Ordering::Relaxed) {
⋮----
f32::from_bits(crate::overlay::recording::CURRENT_RMS.load(Ordering::Relaxed));
⋮----
first_speech = Some(Instant::now());
⋮----
&& first_speech.map(|t| t.elapsed().as_millis()).unwrap_or(0) >= 2000
&& last_active.elapsed().as_millis() > 800
⋮----
stop_signal.store(true, Ordering::SeqCst);
⋮----
drop(stream);
println!("[GeminiLiveStream] Stopped, waiting 2s...");
if !abort_signal.load(Ordering::SeqCst) {
let remaining: Vec<i16> = std::mem::take(&mut *audio_buffer.lock().unwrap());
if !remaining.is_empty() {
let _ = send_audio_chunk(&mut socket, &remaining);
⋮----
println!("[GeminiLiveStream] Waiting for tail...");
⋮----
let final_text = accumulated_text.lock().unwrap().clone();
println!("[GeminiLiveStream] Result: '{}'", final_text);
if abort_signal.load(Ordering::SeqCst) || final_text.is_empty() {
⋮----
if IsWindow(Some(overlay_hwnd)).as_bool() {
⋮----
app.history.save_audio(Vec::new(), final_text.clone());
⋮----
let (rect, retrans) = if preset.blocks.len() > 1 {
⋮----
let samples = full_audio_buffer.lock().unwrap();
encode_wav(&samples, 16000, 1)
⋮----
pub fn record_and_stream_parakeet(
⋮----
let acc_clone = accumulated_text.clone();
let preset_clone = preset.clone();
⋮----
let first_block = preset_for_thread.blocks.first();
let model_id = first_block.map(|b| b.model.clone()).unwrap_or_default();
⋮----
.unwrap_or("parakeet".to_string());
⋮----
if !text.is_empty() {
if let Ok(mut txt) = acc_clone.lock() {
txt.push_str(&text);
⋮----
update_window_text(h, &txt);
⋮----
println!("[ParakeetStream] Starting Parakeet session...");
⋮----
stop_signal.clone(),
pause_signal.clone(),
Some(full_audio_buffer.clone()),
Some(overlay_hwnd),
⋮----
Some(preset_clone.audio_source.clone()),
⋮----
let _ = PostMessageW(Some(h), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
eprintln!("[ParakeetStream] Error: {:?}", e);
⋮----
if abort_signal.load(Ordering::SeqCst) {
⋮----
println!("[ParakeetStream] Final Result: '{}'", final_text);
if final_text.is_empty() {
⋮----
let app = crate::APP.lock().unwrap();
⋮----
.save_audio(final_wav.clone(), final_text.clone());
⋮----
fn upload_audio_to_whisper(
⋮----
let boundary = format!(
⋮----
body.extend_from_slice(format!("--{}\r\n", boundary).as_bytes());
body.extend_from_slice(b"Content-Disposition: form-data; name=\"model\"\r\n\r\n");
body.extend_from_slice(model.as_bytes());
body.extend_from_slice(b"\r\n");
⋮----
body.extend_from_slice(
⋮----
body.extend_from_slice(b"Content-Type: audio/wav\r\n\r\n");
body.extend_from_slice(&audio_data);
⋮----
body.extend_from_slice(format!("--{}--\r\n", boundary).as_bytes());
⋮----
.post("https://api.groq.com/openai/v1/audio/transcriptions")
.header("Authorization", &format!("Bearer {}", api_key))
.header(
⋮----
&format!("multipart/form-data; boundary={}", boundary),
⋮----
.send(&body);
⋮----
return Err(anyhow::anyhow!("API request failed: {}", err_str));
⋮----
.headers()
.get("x-ratelimit-remaining-requests")
.and_then(|v| v.to_str().ok())
⋮----
.get("x-ratelimit-limit-requests")
⋮----
.unwrap_or("?");
let usage_str = format!("{} / {}", remaining, limit);
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(model.to_string(), usage_str);
⋮----
.into_body()
.read_json()
.map_err(|e| anyhow::anyhow!("Failed to parse response: {}", e))?;
⋮----
.get("text")
.and_then(|t| t.as_str())
.ok_or_else(|| anyhow::anyhow!("No text in response"))?;
Ok(text.to_string())
⋮----
fn execute_audio_processing_logic(preset: &Preset, wav_data: Vec<u8>) -> anyhow::Result<String> {
⋮----
match preset.blocks.iter().find(|b| b.block_type == "audio") {
Some(b) => (b.clone(), false),
⋮----
.find(|b| b.block_type == "input_adapter")
⋮----
Some(b) => (b.clone(), true),
⋮----
let debug_types: Vec<_> = preset.blocks.iter().map(|b| &b.block_type).collect();
eprintln!(
⋮----
return Err(anyhow::anyhow!(
⋮----
return Ok(String::new());
⋮----
let model_config = get_model_by_id(&audio_block.model);
⋮----
let model_name = model_config.full_name.clone();
let provider = model_config.provider.clone();
⋮----
app.config.api_key.clone(),
app.config.gemini_api_key.clone(),
⋮----
let mut final_prompt = if model_is_non_llm(&audio_block.model) {
⋮----
audio_block.prompt.clone()
⋮----
let pattern = format!("{{{}}}", key);
final_prompt = final_prompt.replace(&pattern, value);
⋮----
if final_prompt.contains("{language1}") && !audio_block.language_vars.contains_key("language1")
⋮----
final_prompt = final_prompt.replace("{language1}", &audio_block.selected_language);
⋮----
final_prompt = final_prompt.replace("{language}", &audio_block.selected_language);
⋮----
if groq_api_key.trim().is_empty() {
Err(anyhow::anyhow!("NO_API_KEY:groq"))
⋮----
upload_audio_to_whisper(&groq_api_key, &model_name, wav_data)
⋮----
Err(anyhow::anyhow!("NO_API_KEY:google"))
⋮----
transcribe_audio_gemini(&gemini_api_key, final_prompt, model_name, wav_data, |_| {})
⋮----
Err(anyhow::anyhow!("NO_API_KEY:gemini"))
⋮----
transcribe_with_gemini_live_input(&gemini_api_key, wav_data)
⋮----
Err(anyhow::anyhow!("Unsupported audio provider: {}", provider))
⋮----
pub fn record_audio_and_transcribe(
⋮----
let pause_signal_audio = pause_signal.clone();
⋮----
eprintln!("Error: No default output device found for loopback.");
⋮----
eprintln!("Error: Device capture not supported on this OS or no device found.");
⋮----
eprintln!("Error: No input device available.");
⋮----
match device.default_output_config() {
⋮----
Err(_) => match device.default_input_config() {
⋮----
eprintln!("Failed to get audio config: {}", e);
⋮----
match device.default_input_config() {
⋮----
let channels = config.channels();
⋮----
let err_fn = |err| eprintln!("Audio stream error: {}", err);
⋮----
let pause_signal_builder = pause_signal_audio.clone();
let stream_res = match config.sample_format() {
⋮----
if !pause_signal_builder.load(Ordering::Relaxed) {
let _ = tx.send(data.to_vec());
⋮----
.store(true, Ordering::SeqCst);
⋮----
data.iter().map(|&s| s as f32 / i16::MAX as f32).collect();
let _ = tx.send(f32_data);
⋮----
Err(cpal::BuildStreamError::StreamConfigNotSupported)
⋮----
eprintln!("Failed to build stream: {}", e);
⋮----
let stream = stream_res.unwrap();
if let Err(e) = stream.play() {
eprintln!("Failed to play stream: {}", e);
⋮----
while !stop_signal.load(Ordering::SeqCst) {
while let Ok(chunk) = rx.try_recv() {
collected_samples.extend(chunk);
⋮----
&& !stop_signal.load(Ordering::Relaxed)
&& !pause_signal_audio.load(Ordering::Relaxed)
⋮----
let rms_bits = crate::overlay::recording::CURRENT_RMS.load(Ordering::Relaxed);
⋮----
first_speech_time = Some(std::time::Instant::now());
⋮----
.map(|t| t.elapsed().as_millis())
.unwrap_or(0);
⋮----
let silence_duration = last_active_time.elapsed().as_millis();
⋮----
if !unsafe { IsWindow(Some(overlay_hwnd)).as_bool() } {
⋮----
.map(|&s| (s.clamp(-1.0, 1.0) * i16::MAX as f32) as i16)
.collect();
if samples.is_empty() {
println!("Warning: Recorded audio buffer is empty.");
⋮----
let wav_data = wav_cursor.into_inner();
⋮----
let audio_mode = Some(preset.audio_source.as_str());
⋮----
let mut app = crate::APP.lock().unwrap();
⋮----
app.config.presets[idx].clone()
⋮----
preset.clone()
⋮----
let wav_data_for_history = wav_data.clone();
let transcription_result = execute_audio_processing_logic(&working_preset, wav_data);
⋮----
let wav_data_for_overlay = wav_data_for_history.clone();
⋮----
.save_audio(wav_data_for_history, transcription_text.clone());
⋮----
let has_multiple_blocks = working_preset.blocks.len() > 1;
⋮----
eprintln!("Transcription error: {}", e);
⋮----
pub fn process_audio_file_request(preset: Preset, wav_data: Vec<u8>) {
let processing_result = execute_audio_processing_logic(&preset, wav_data.clone());
⋮----
.save_audio(wav_data.clone(), result_text.clone());
⋮----
unsafe { (GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)) };
let has_multiple_blocks = preset.blocks.len() > 1;
⋮----
HWND(std::ptr::null_mut()),
⋮----
eprintln!("Audio file processing error: {}", e);
</file>

<file path="src/api/gemini_live/types.rs">
use std::sync::mpsc;
⋮----
pub enum LiveEvent {
⋮----
pub enum LiveInputContent {
⋮----
pub struct LiveRequest {
⋮----
pub struct QueuedLiveRequest {
</file>

<file path="src/api/tts/manager.rs">
use super::utils;
use std::collections::VecDeque;
use std::sync::mpsc;
⋮----
pub struct TtsManager {
⋮----
impl TtsManager {
pub fn new() -> Self {
⋮----
pub fn _is_ready(&self) -> bool {
self._is_ready.load(Ordering::SeqCst)
⋮----
pub fn speak(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, false)
⋮----
pub fn speak_realtime(&self, text: &str, hwnd: isize) -> u64 {
self.speak_internal(text, hwnd, true)
⋮----
fn speak_internal(&self, text: &str, hwnd: isize, is_realtime: bool) -> u64 {
let id = REQUEST_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
let current_gen = self.interrupt_generation.load(Ordering::SeqCst);
⋮----
let mut wq = self.work_queue.lock().unwrap();
wq.push_back((
⋮----
text: text.to_string(),
⋮----
self.work_signal.notify_one();
⋮----
let mut pq = self.playback_queue.lock().unwrap();
pq.push_back((rx, hwnd, id, current_gen, is_realtime));
⋮----
self.playback_signal.notify_one();
⋮----
pub fn speak_interrupt(&self, text: &str, hwnd: isize) -> u64 {
let new_gen = self.interrupt_generation.fetch_add(1, Ordering::SeqCst) + 1;
⋮----
wq.clear();
⋮----
pq.clear();
⋮----
pq.push_back((rx, hwnd, id, new_gen, false));
⋮----
pub fn stop(&self) {
self.interrupt_generation.fetch_add(1, Ordering::SeqCst);
⋮----
self.playback_signal.notify_all();
⋮----
pub fn stop_if_active(&self, _request_id: u64) {
self.stop();
⋮----
pub fn is_speaking(&self, _request_id: u64) -> bool {
self.has_pending_audio()
⋮----
pub fn has_pending_audio(&self) -> bool {
if self.is_playing.load(Ordering::SeqCst) {
⋮----
.lock()
.map(|q| !q.is_empty())
.unwrap_or(false);
⋮----
pub fn _shutdown(&self) {
self.shutdown.store(true, Ordering::SeqCst);
⋮----
self.work_signal.notify_all();
⋮----
pub fn get_output_devices() -> Vec<(String, String)> {
</file>

<file path="src/api/tts/utils.rs">
use windows::Win32::Foundation::HWND;
use windows::Win32::Graphics::Gdi::InvalidateRect;
⋮----
use crate::overlay::result::state::WINDOW_STATES;
pub fn clear_tts_loading_state(hwnd: isize) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd) {
⋮----
let _ = InvalidateRect(Some(HWND(hwnd as *mut std::ffi::c_void)), None, false);
⋮----
pub fn clear_tts_state(hwnd: isize) {
⋮----
pub fn get_language_instruction_for_text(
⋮----
let detected_code = detected.code();
⋮----
if condition.language_code.eq_ignore_ascii_case(detected_code) {
return Some(condition.instruction.clone());
⋮----
pub fn get_output_devices() -> Vec<(String, String)> {
⋮----
let _ = CoInitializeEx(None, COINIT_MULTITHREADED);
⋮----
if let Ok(collection) = enumerator.EnumAudioEndpoints(eRender, DEVICE_STATE_ACTIVE) {
if let Ok(count) = collection.GetCount() {
⋮----
if let Ok(device) = collection.Item(i) {
if let Ok(id) = device.GetId() {
let id_str = id.to_string().unwrap_or_default();
let name = if let Ok(_props) = device.OpenPropertyStore(STGM_READ) {
id_str.clone()
⋮----
devices.push((id_str, name));
</file>

<file path="src/api/tts/worker.rs">
use super::manager::TtsManager;
use super::types::AudioEvent;
⋮----
use crate::api::client::UREQ_AGENT;
use crate::APP;
use isolang::Language;
pub fn run_socket_worker(manager: Arc<TtsManager>) {
⋮----
if manager.shutdown.load(Ordering::SeqCst) {
⋮----
let mut queue = manager.work_queue.lock().unwrap();
while queue.is_empty() && !manager.shutdown.load(Ordering::SeqCst) {
let result = manager.work_signal.wait(queue).unwrap();
⋮----
queue.pop_front().unwrap()
⋮----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst) {
let _ = tx.send(AudioEvent::End);
⋮----
match APP.lock() {
Ok(app) => app.config.tts_method.clone(),
⋮----
handle_google_tts(manager.clone(), request, tx);
⋮----
handle_edge_tts(manager.clone(), request, tx);
⋮----
Ok(app) => app.config.gemini_api_key.clone(),
⋮----
if api_key.trim().is_empty() {
eprintln!("TTS: No Gemini API key configured");
⋮----
clear_tts_loading_state(request.req.hwnd);
clear_tts_state(request.req.hwnd);
⋮----
let socket_result = connect_tts_websocket(&api_key);
⋮----
eprintln!("TTS: Failed to connect: {}", e);
⋮----
let app = APP.lock().unwrap();
let voice = app.config.tts_voice.clone();
let conditions = app.config.tts_language_conditions.clone();
let instruction = get_language_instruction_for_text(&request.req.text, &conditions);
⋮----
(voice, "Normal".to_string(), instruction)
⋮----
(voice, app.config.tts_speed.clone(), instruction)
⋮----
if let Err(e) = send_tts_setup(
⋮----
language_instruction.as_deref(),
⋮----
eprintln!("TTS: Failed to send setup: {}", e);
let _ = socket.close(None);
⋮----
if request.generation < manager.interrupt_generation.load(Ordering::SeqCst)
|| manager.shutdown.load(Ordering::SeqCst)
⋮----
match socket.read() {
⋮----
let msg = msg.as_str();
if msg.contains("setupComplete") {
⋮----
if msg.contains("error") || msg.contains("Error") {
eprintln!("TTS: Setup error: {}", msg);
⋮----
if let Ok(text) = String::from_utf8(data.to_vec()) {
if text.contains("setupComplete") {
⋮----
if e.kind() == std::io::ErrorKind::WouldBlock =>
⋮----
if setup_start.elapsed() > Duration::from_secs(10) {
⋮----
if let Err(e) = send_tts_text(&mut socket, &request.req.text) {
eprintln!("TTS: Failed to send text: {}", e);
⋮----
if let Some(audio_data) = parse_audio_data(msg) {
let _ = tx.send(AudioEvent::Data(audio_data));
⋮----
if is_turn_complete(msg) {
⋮----
if let Some(audio_data) = parse_audio_data(&text) {
⋮----
if is_turn_complete(&text) {
⋮----
eprintln!("TTS: Read error: {}", e);
⋮----
fn handle_google_tts(
⋮----
let text = request.req.text.clone();
let lang_code = whatlang::detect_lang(&text).unwrap_or(whatlang::Lang::Eng);
let tl = Language::from_639_3(lang_code.code())
.and_then(|l| l.to_639_1())
.unwrap_or("en");
let url = format!(
⋮----
let resp = match UREQ_AGENT.get(&url).call() {
⋮----
.into_body()
.into_reader()
.read_to_end(&mut mp3_data)
.is_err()
⋮----
match decoder.next_frame() {
⋮----
for chunk in data.chunks(2) {
⋮----
all_samples.push(sample);
⋮----
all_samples.extend_from_slice(&data);
⋮----
if all_samples.is_empty() {
⋮----
let resampled = resample_audio(&all_samples, source_sample_rate, 24000);
let mut bytes = Vec::with_capacity(resampled.len() * 2);
⋮----
bytes.extend_from_slice(&sample.to_le_bytes());
⋮----
let mut bytes = Vec::with_capacity(all_samples.len() * 2);
⋮----
for chunk in audio_bytes.chunks(chunk_size) {
⋮----
let _ = tx.send(AudioEvent::Data(chunk.to_vec()));
⋮----
fn handle_edge_tts(
⋮----
let manager_clone = manager.clone();
⋮----
let mut voice = "en-US-AriaNeural".to_string();
⋮----
.and_then(|info| Language::from_639_3(info.lang().code()))
⋮----
voice = config.voice_name.clone();
⋮----
let connection_id = format!(
⋮----
let wss_url = format!(
⋮----
let stream = match std::net::TcpStream::connect(format!("{}:443", host)) {
⋮----
let tls_stream = match connector.connect(host, stream) {
⋮----
let (mut socket, _) = match client(&wss_url, tls_stream) {
⋮----
let request_id = format!(
⋮----
let config_msg = format!(
⋮----
if socket.send(Message::Text(config_msg.into())).is_err() {
⋮----
format!("+{}Hz", pitch)
⋮----
format!("{}Hz", pitch)
⋮----
format!("+{}%", rate)
⋮----
format!("{}%", rate)
⋮----
.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
.replace('\'', "&apos;");
let ssml = format!(
⋮----
let ssml_msg = format!(
⋮----
if socket.send(Message::Text(ssml_msg.into())).is_err() {
⋮----
if generation < manager_clone.interrupt_generation.load(Ordering::SeqCst) {
⋮----
if data.len() >= 2 {
⋮----
if data.len() > audio_start {
⋮----
if header.windows(11).any(|w| w == b"Path:audio\r") {
mp3_data.extend_from_slice(&data[audio_start..]);
⋮----
let text = text.as_str();
if text.contains("Path:turn.end") {
⋮----
Err(tungstenite::Error::Io(ref e)) if e.kind() == std::io::ErrorKind::WouldBlock => {
⋮----
if mp3_data.is_empty() {
⋮----
fn resample_audio(samples: &[i16], from_rate: u32, to_rate: u32) -> Vec<i16> {
⋮----
return samples.to_vec();
⋮----
let new_len = (samples.len() as f32 * ratio) as usize;
⋮----
if src_idx >= samples.len() - 1 {
result.push(samples[src_idx.min(samples.len() - 1)]);
⋮----
result.push(val as i16);
</file>

<file path="src/assets.rs">
include_bytes!("../assets/GoogleSansFlex-VariableFont_GRAD,ROND,opsz,slnt,wdth,wght.ttf");
</file>

<file path="src/config/preset/defaults/mod.rs">
mod audio;
mod image;
mod master;
mod text;
use crate::config::preset::Preset;
pub use audio::create_audio_presets;
pub use image::create_image_presets;
pub use master::create_master_presets;
pub use text::create_text_presets;
pub fn get_default_presets() -> Vec<Preset> {
let image = create_image_presets();
let text = create_text_presets();
let audio = create_audio_presets();
let masters = create_master_presets();
⋮----
presets.iter().find(|p| p.id == id).cloned().unwrap()
⋮----
vec![
</file>

<file path="src/debug_log.rs">
use chrono::Local;
use std::fs::OpenOptions;
use std::io::Write;
use std::path::PathBuf;
⋮----
pub fn log_debug(msg: &str) {
let _lock = LOG_MUTEX.lock().unwrap();
let mut path = dirs::data_local_dir().unwrap_or_else(|| PathBuf::from("."));
path.push("SGT");
path.push("logs");
⋮----
path.push("session.log");
if let Ok(mut file) = OpenOptions::new().create(true).append(true).open(path) {
let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S%.3f");
let _ = writeln!(file, "[{}] {}", timestamp, msg);
⋮----
macro_rules! log_info {
</file>

<file path="src/gui/app/input_handler.rs">
use crate::APP;
use crate::overlay::preset_wheel::show_preset_wheel;
⋮----
use crate::overlay::utils::get_clipboard_image_bytes;
use eframe::egui;
⋮----
use std::io::Cursor;
use std::path::Path;
use std::sync::mpsc;
⋮----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
⋮----
fn is_image_extension(ext: &str) -> bool {
IMAGE_EXTENSIONS.contains(&ext.to_lowercase().as_str())
⋮----
fn is_audio_extension(ext: &str) -> bool {
AUDIO_EXTENSIONS.contains(&ext.to_lowercase().as_str())
⋮----
fn load_text_file(path: &Path) -> Option<String> {
std::fs::read_to_string(path).ok()
⋮----
fn load_audio_file(path: &Path) -> Option<Vec<u8>> {
use symphonia::core::audio::SampleBuffer;
use symphonia::core::codecs::DecoderOptions;
use symphonia::core::formats::FormatOptions;
use symphonia::core::io::MediaSourceStream;
use symphonia::core::meta::MetadataOptions;
use symphonia::core::probe::Hint;
let file = std::fs::File::open(path).ok()?;
⋮----
if let Some(ext) = path.extension().and_then(|e| e.to_str()) {
hint.with_extension(ext);
⋮----
.format(
⋮----
.ok()?;
⋮----
.tracks()
.iter()
.find(|t| t.codec_params.codec != symphonia::core::codecs::CODEC_TYPE_NULL)?;
⋮----
let codec_params = track.codec_params.clone();
let sample_rate = codec_params.sample_rate.unwrap_or(44100);
let channels = codec_params.channels.map(|c| c.count()).unwrap_or(2) as u16;
⋮----
.make(&codec_params, &DecoderOptions::default())
⋮----
let packet = match format.next_packet() {
⋮----
if e.kind() == std::io::ErrorKind::UnexpectedEof =>
⋮----
if packet.track_id() != track_id {
⋮----
let decoded = match decoder.decode(&packet) {
⋮----
let spec = *decoded.spec();
let duration = decoded.capacity() as u64;
⋮----
sample_buf.copy_interleaved_ref(decoded);
all_samples.extend(sample_buf.samples());
⋮----
if all_samples.is_empty() {
⋮----
let mut writer = hound::WavWriter::new(&mut wav_cursor, spec).ok()?;
⋮----
writer.write_sample(*sample).ok()?;
⋮----
writer.finalize().ok()?;
⋮----
Some(wav_cursor.into_inner())
⋮----
fn get_cursor_pos() -> POINT {
⋮----
let _ = GetCursorPos(&mut pos);
⋮----
fn get_screen_rect_at_cursor() -> RECT {
let pos = get_cursor_pos();
⋮----
fn process_image_content(img: ImageBuffer<Rgba<u8>, Vec<u8>>) {
let cursor_pos = get_cursor_pos();
let selected = show_preset_wheel("image", None, cursor_pos);
⋮----
let mut app = APP.lock().unwrap();
⋮----
(app.config.clone(), app.config.presets[preset_idx].clone())
⋮----
let rect = get_screen_rect_at_cursor();
⋮----
start_processing_pipeline(img, rect, config, preset);
⋮----
fn process_text_content(text: String) {
⋮----
let selected = show_preset_wheel("text", None, cursor_pos);
⋮----
let ui_lang = config.ui_language.clone();
⋮----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
⋮----
start_text_processing(text, rect, config, preset, localized_name, cancel_hotkey);
⋮----
fn process_image_parallel(rx: mpsc::Receiver<Option<(ImageBuffer<Rgba<u8>, Vec<u8>>, Vec<u8>)>>) {
⋮----
start_processing_pipeline_parallel(rx, rect, config, preset);
⋮----
fn process_text_parallel(rx: mpsc::Receiver<Option<String>>) {
⋮----
if let Ok(Some(text)) = rx.recv() {
⋮----
fn process_audio_parallel(rx: mpsc::Receiver<Option<Vec<u8>>>) {
⋮----
let selected = show_preset_wheel("audio", None, cursor_pos);
⋮----
app.config.presets[preset_idx].clone()
⋮----
if let Ok(Some(wav_data)) = rx.recv() {
⋮----
pub fn process_file_path(path: &Path) {
⋮----
let path_clone = path.to_path_buf();
let ext = path.extension().and_then(|e| e.to_str()).unwrap_or("");
⋮----
if is_image_extension(ext) {
⋮----
let _ = tx.send(Some((img.to_rgba8(), bytes)));
⋮----
let _ = tx.send(None);
⋮----
process_image_parallel(rx);
} else if is_audio_extension(ext) {
⋮----
let _ = tx.send(load_audio_file(&path_clone));
⋮----
process_audio_parallel(rx);
⋮----
let _ = tx.send(load_text_file(&path_clone));
⋮----
process_text_parallel(rx);
⋮----
pub fn handle_dropped_files(ctx: &egui::Context) -> bool {
let dropped_files = ctx.input(|i| i.raw.dropped_files.clone());
if dropped_files.is_empty() {
⋮----
if let Some(file) = dropped_files.first() {
⋮----
process_file_path(path);
⋮----
let bytes_clone = bytes.clone();
⋮----
let rgba = img.to_rgba8();
process_image_content(rgba);
⋮----
else if let Ok(text) = String::from_utf8(bytes_clone.to_vec()) {
process_text_content(text);
⋮----
pub fn is_files_hovered(ctx: &egui::Context) -> bool {
ctx.input(|i| !i.raw.hovered_files.is_empty())
⋮----
fn get_clipboard_text() -> Option<String> {
use windows::Win32::Foundation::HGLOBAL;
⋮----
if OpenClipboard(None).is_ok() {
if let Ok(h_data) = GetClipboardData(13) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
⋮----
while *wide_ptr.add(len) != 0 {
⋮----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
let _ = CloseClipboard();
if !text.is_empty() {
return Some(text);
⋮----
pub fn handle_paste(ctx: &egui::Context) -> bool {
⋮----
let has_focus = ctx.input(|i| i.focused);
⋮----
let focused_id = ctx.memory(|mem| mem.focused());
⋮----
if api_key_ids.contains(&id) {
⋮----
let ctrl_down = unsafe { (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 };
let v_down = unsafe { (GetAsyncKeyState(VK_V.0 as i32) as u16 & 0x8000) != 0 };
let v_was_down = LAST_V_STATE.swap(v_down, Ordering::SeqCst);
⋮----
let paste_event = ctx.input(|i| {
⋮----
.any(|e| matches!(e, egui::Event::Paste(_)))
⋮----
if let Some(img_bytes) = get_clipboard_image_bytes() {
⋮----
if let Some(text) = get_clipboard_text() {
</file>

<file path="src/gui/app/utils.rs">
use crate::config::save_config;
use eframe::egui;
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::Foundation::CloseHandle;
⋮----
pub fn simple_rand(seed: u32) -> u32 {
seed.wrapping_mul(1103515245).wrapping_add(12345)
⋮----
pub fn signal_restore_window() {
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
⋮----
if let Ok(event) = OpenEventW(
⋮----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
⋮----
let _ = SetEvent(event);
let _ = CloseHandle(event);
⋮----
impl SettingsApp {
pub(crate) fn save_and_sync(&mut self) {
⋮----
let mut state = self.app_state_ref.lock().unwrap();
⋮----
state.config = self.config.clone();
drop(state);
save_config(&self.config);
⋮----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
⋮----
.unwrap_or_default();
if !hwnd.is_invalid() {
⋮----
Some(hwnd),
⋮----
pub(crate) fn restore_window(&self, ctx: &egui::Context) {
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
ctx.send_viewport_cmd(egui::ViewportCommand::Minimized(false));
ctx.send_viewport_cmd(egui::ViewportCommand::Focus);
ctx.send_viewport_cmd(egui::ViewportCommand::WindowLevel(
⋮----
ctx.request_repaint();
⋮----
pub(crate) fn check_hotkey_conflict(
⋮----
for (idx, preset) in self.config.presets.iter().enumerate() {
⋮----
return Some(format!(
⋮----
pub fn restart_app() {
⋮----
let kill_mutex_cmd = "timeout /t 1 /nobreak > NUL".to_string();
let start_cmd = format!("start \"\" \"{}\" --restarted", exe_path.to_string_lossy());
⋮----
let batch_content = format!(
⋮----
let bat_path = temp_dir.join(format!("sgt_restart_{}.bat", std::process::id()));
⋮----
use std::os::windows::process::CommandExt;
⋮----
.args(["/C", &bat_path.to_string_lossy()])
.creation_flags(0x08000000)
.spawn();
⋮----
.arg("--restarted")
</file>

<file path="src/gui/icons.rs">
use eframe::egui;
use std::f32::consts::PI;
⋮----
pub enum Icon {
⋮----
pub fn icon_button(ui: &mut egui::Ui, icon: Icon) -> egui::Response {
icon_button_sized(ui, icon, 24.0)
⋮----
pub fn icon_button_sized(ui: &mut egui::Ui, icon: Icon, size_val: f32) -> egui::Response {
⋮----
let (rect, response) = ui.allocate_exact_size(size, egui::Sense::click());
if response.hovered() {
ui.painter()
.rect_filled(rect.shrink(2.0), 4.0, ui.visuals().widgets.hovered.bg_fill);
⋮----
let color = if response.hovered() {
ui.visuals().widgets.hovered.fg_stroke.color
⋮----
ui.visuals().widgets.inactive.fg_stroke.color
⋮----
paint_internal(ui.painter(), rect, icon, color);
⋮----
pub fn draw_icon_static(ui: &mut egui::Ui, icon: Icon, size_override: Option<f32>) {
let side = size_override.unwrap_or(16.0);
let (rect, _) = ui.allocate_exact_size(egui::vec2(side, side), egui::Sense::hover());
let color = ui.visuals().text_color();
⋮----
pub fn paint_icon(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
paint_internal(painter, rect, icon, color);
⋮----
fn paint_internal(painter: &egui::Painter, rect: egui::Rect, icon: Icon, color: egui::Color32) {
let center = rect.center();
let scale = rect.width().min(rect.height()) / 22.0;
⋮----
points.push(center + egui::vec2(theta_a.cos() * r, theta_a.sin() * r));
points.push(center + egui::vec2(theta_b.cos() * r, theta_b.sin() * r));
⋮----
points.push(points[0]);
painter.add(egui::Shape::line(points, stroke));
painter.circle_stroke(center, hole_r, stroke);
⋮----
let pts_top = bezier_points(p_left, p_top, p_right, 10);
let pts_bot = bezier_points(p_right, p_bot, p_left, 10);
⋮----
full_eye.extend(pts_bot);
painter.add(egui::Shape::line(full_eye, stroke));
painter.circle_filled(center, 2.5 * scale, color);
⋮----
let pts = bezier_points(p_left, p_top, p_right, 12);
painter.add(egui::Shape::line(pts, stroke));
⋮----
painter.line_segment(
⋮----
painter.rect_stroke(caps_rect, w / 2.0, stroke, egui::StrokeKind::Middle);
let y_start = caps_rect.top() + 3.5 * scale;
⋮----
let u_path = bezier_points(u_left, u_bot, u_right, 10);
painter.add(egui::Shape::line(u_path, stroke));
⋮----
let img_rect = rect.shrink(3.0 * scale);
painter.rect_stroke(img_rect, 2.0 * scale, stroke, egui::StrokeKind::Middle);
let p1 = img_rect.left_bottom() - egui::vec2(-1.0, 2.0) * scale;
let p2 = img_rect.left_bottom() + egui::vec2(3.0, -6.0) * scale;
let p3 = img_rect.left_bottom() + egui::vec2(6.0, -3.0) * scale;
let p4 = img_rect.left_bottom() + egui::vec2(9.0, -7.0) * scale;
let p5 = img_rect.right_bottom() - egui::vec2(1.0, 2.0) * scale;
painter.add(egui::Shape::line(vec![p1, p2, p3, p4, p5], stroke));
painter.circle_filled(
img_rect.left_top() + egui::vec2(3.5, 3.5) * scale,
⋮----
painter.add(egui::Shape::line(vec![p1, p2, p3, p4], stroke));
⋮----
let p1 = body_rect.left_top();
let p2 = body_rect.left_bottom();
let p3 = body_rect.right_bottom();
let p4 = body_rect.right_top();
let p5 = body_rect.left_top() + egui::vec2(tab_w, 0.0);
let p6 = body_rect.left_top() + egui::vec2(tab_w, -tab_h);
let p7 = body_rect.left_top() + egui::vec2(0.0, -tab_h);
painter.add(egui::Shape::line(
vec![p7, p1, p2, p3, p4, p5, p6, p7],
⋮----
painter.rect_stroke(back_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_filled(
⋮----
painter.ctx().style().visuals.panel_fill,
⋮----
painter.rect_stroke(front_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_stroke(back_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_stroke(front_rect, 0.8 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.line_segment([p1, p2], stroke);
painter.line_segment([p3, p4], stroke);
⋮----
painter.rect_stroke(rect, 0.5 * scale, stroke, egui::StrokeKind::Middle);
let cone_pts = vec![
⋮----
painter.add(egui::Shape::closed_line(cone_pts, stroke));
⋮----
wave1_pts.push(egui::pos2(
wave_x + wave_r1 * angle.cos(),
center.y + wave_r1 * angle.sin(),
⋮----
painter.add(egui::Shape::line(wave1_pts, stroke));
⋮----
wave2_pts.push(egui::pos2(
wave_x + wave_r2 * angle.cos(),
center.y + wave_r2 * angle.sin(),
⋮----
painter.add(egui::Shape::line(wave2_pts, stroke));
⋮----
painter.circle_stroke(egui::pos2(center.x, bulb_cy), bulb_r, stroke);
⋮----
let wave_pts = vec![
⋮----
painter.add(egui::Shape::line(wave_pts, wave_stroke));
⋮----
points.push(egui::pos2(
center.x + r * angle.cos(),
center.y + r * angle.sin(),
⋮----
raw_points.push(egui::pos2(
⋮----
let p_start = lerp(p, p_prev, round_ratio);
let p_end = lerp(p, p_next, round_ratio);
let curve = bezier_points(p_start, p, p_end, 5);
path_points.extend(curve);
⋮----
path_points.push(p);
⋮----
painter.add(egui::Shape::Path(egui::epaint::PathShape {
⋮----
stroke: egui::Stroke::new(1.0 * scale, gold).into(),
⋮----
painter.circle_stroke(center, 4.0 * scale, stroke);
⋮----
let angle = (i as f32 * 45.0).to_radians();
let dir = egui::vec2(angle.cos(), angle.sin());
⋮----
painter.line_segment([start, end], stroke);
⋮----
painter.circle_filled(center, r, color);
⋮----
painter.rect_stroke(screen_rect, 1.0 * scale, stroke, egui::StrokeKind::Middle);
⋮----
painter.circle_filled(egui::pos2(cx, cy), r, color);
⋮----
painter.circle_stroke(center, r, stroke);
painter.line_segment([center, center + egui::vec2(4.0 * scale, 0.0)], stroke);
painter.line_segment([center, center + egui::vec2(0.0, -5.0 * scale)], stroke);
⋮----
painter.circle_filled(center, r_head, color);
⋮----
let beak_pts = vec![
⋮----
painter.add(egui::Shape::convex_polygon(beak_pts, color, stroke));
⋮----
painter.rect_stroke(rect, 0.0, stroke, egui::StrokeKind::Middle);
⋮----
painter.rect_stroke(rect_back, 0.0, stroke, egui::StrokeKind::Middle);
⋮----
rect_front.expand(stroke.width / 2.0),
⋮----
painter.rect_stroke(rect_front, 0.0, stroke, egui::StrokeKind::Middle);
⋮----
fn lerp(a: egui::Pos2, b: egui::Pos2, t: f32) -> egui::Pos2 {
⋮----
fn lerp_quadratic(p0: egui::Pos2, p1: egui::Pos2, p2: egui::Pos2, t: f32) -> egui::Pos2 {
let l1 = lerp(p0, p1, t);
let l2 = lerp(p1, p2, t);
lerp(l1, l2, t)
⋮----
fn bezier_points(
⋮----
points.push(lerp_quadratic(p0, p1, p2, t));
</file>

<file path="src/gui/mod.rs">
pub mod app;
pub mod icons;
mod key_mapping;
pub mod locale;
pub mod settings_ui;
pub mod splash;
pub mod utils;
pub use app::SettingsApp;
pub use app::signal_restore_window;
pub use utils::configure_fonts;
</file>

<file path="src/gui/settings_ui/download_manager/persistence.rs">
use std::fs;
use std::path::PathBuf;
⋮----
pub struct DownloadManagerConfig {
⋮----
impl Default for DownloadManagerConfig {
fn default() -> Self {
⋮----
pub fn get_config_path() -> PathBuf {
⋮----
.unwrap_or(PathBuf::from("."))
.join("screen-goated-toolbox")
.join("download_manager.json")
⋮----
pub fn load_config() -> DownloadManagerConfig {
let path = get_config_path();
if path.exists() {
⋮----
pub fn save_config(config: &DownloadManagerConfig) {
⋮----
if let Some(parent) = path.parent() {
</file>

<file path="src/gui/settings_ui/help_assistant.rs">
use crate::api::client::UREQ_AGENT;
⋮----
pub fn is_modal_open() -> bool {
HELP_INPUT_ACTIVE.load(Ordering::SeqCst)
⋮----
fn fetch_repomix_xml() -> Result<String, String> {
⋮----
match UREQ_AGENT.get(url).call() {
⋮----
.into_body()
.read_to_string()
.map_err(|e| format!("Failed to read response: {}", e)),
Err(e) => Err(format!("Failed to fetch XML: {}", e)),
⋮----
fn ask_gemini(gemini_api_key: &str, question: &str, context_xml: &str) -> Result<String, String> {
if gemini_api_key.trim().is_empty() {
return Err("Gemini API key not configured. Please set it in Global Settings.".to_string());
⋮----
let url = format!(
⋮----
let user_message = format!(
⋮----
.post(&url)
.header("Content-Type", "application/json")
.send(&body.to_string())
.map_err(|e| format!("API request failed: {}", e))?;
⋮----
.read_json()
.map_err(|e| format!("Failed to parse response: {}", e))?;
⋮----
.as_str()
.map(|s| s.to_string())
.ok_or_else(|| "Failed to extract response text".to_string())
⋮----
pub fn show_help_input() {
HELP_INPUT_ACTIVE.store(true, Ordering::SeqCst);
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.gemini_api_key.clone(),
app.config.ui_language.clone(),
⋮----
let placeholder = match ui_language.as_str() {
⋮----
placeholder.to_string(),
ui_language.clone(),
⋮----
let question = question.trim().to_string();
if question.is_empty() {
HELP_INPUT_ACTIVE.store(false, Ordering::SeqCst);
⋮----
let gemini_key = gemini_api_key.clone();
let lang = ui_language.clone();
⋮----
let loading_msg = match lang.as_str() {
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
⋮----
unsafe { (GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)) };
⋮----
"gemini-2.5-flash".to_string(),
"google".to_string(),
⋮----
"Ask SGT".to_string(),
⋮----
loading_msg.to_string(),
⋮----
let _ = ShowWindow(result_hwnd, SW_SHOW);
let _ = SetForegroundWindow(result_hwnd);
⋮----
let result = match fetch_repomix_xml() {
Ok(xml) => ask_gemini(&gemini_key, &question, &xml),
Err(e) => Err(format!("Failed to fetch context: {}", e)),
⋮----
Ok(answer) => format!("## ❓ {}\n\n{}", question, answer),
Err(e) => format!("## ❌ Error\n\n{}", e),
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
</file>

<file path="src/gui/settings_ui/mod.rs">
pub mod download_manager;
mod footer;
mod global;
pub mod help_assistant;
mod history;
pub mod node_graph;
mod preset;
mod sidebar;
pub use footer::render_footer;
pub use global::render_global_settings;
pub use history::render_history_panel;
pub use preset::render_preset_editor;
pub use sidebar::get_localized_preset_name;
pub use sidebar::render_sidebar;
⋮----
pub enum ViewMode {
</file>

<file path="src/gui/settings_ui/node_graph/node.rs">
use crate::config::ProcessingBlock;
use std::collections::HashMap;
⋮----
pub enum ChainNode {
⋮----
impl Default for ChainNode {
fn default() -> Self {
⋮----
id: format!(
⋮----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
⋮----
render_mode: "markdown_stream".to_string(),
⋮----
impl ChainNode {
pub fn is_input(&self) -> bool {
matches!(self, ChainNode::Input { .. })
⋮----
pub fn is_special(&self) -> bool {
matches!(self, ChainNode::Special { .. })
⋮----
pub fn to_block(&self) -> ProcessingBlock {
⋮----
id: id.clone(),
block_type: "input_adapter".to_string(),
⋮----
render_mode: render_mode.clone(),
⋮----
block_type: block_type.clone(),
model: model.clone(),
prompt: prompt.clone(),
selected_language: language_vars.get("language1").cloned().unwrap_or_default(),
language_vars: language_vars.clone(),
⋮----
pub fn from_block(block: &ProcessingBlock, role: &str) -> Self {
let mut language_vars = block.language_vars.clone();
if !language_vars.contains_key("language1") && !block.selected_language.is_empty() {
language_vars.insert("language1".to_string(), block.selected_language.clone());
⋮----
id: block.id.clone(),
block_type: block.block_type.clone(),
⋮----
render_mode: block.render_mode.clone(),
⋮----
model: block.model.clone(),
prompt: block.prompt.clone(),
⋮----
pub fn id(&self) -> &str {
⋮----
pub fn set_auto_copy(&mut self, val: bool) {
</file>

<file path="src/gui/settings_ui/node_graph/viewer.rs">
use super::body::show_body;
use super::node::ChainNode;
⋮----
use crate::gui::locale::LocaleText;
use eframe::egui;
⋮----
pub struct ChainViewer<'a> {
⋮----
pub fn new(
⋮----
ui_language: ui_language.to_string(),
⋮----
preset_type: preset_type.to_string(),
⋮----
/// Check if a model's provider is enabled
    pub fn is_provider_enabled(&self, provider: &str) -> bool {
⋮----
pub fn is_provider_enabled(&self, provider: &str) -> bool {
⋮----
fn title(&mut self, node: &ChainNode) -> String {
⋮----
self.preset_type.as_str()
⋮----
block_type.as_str()
⋮----
format!("{} {}", prefix, type_name)
⋮----
match self.preset_type.as_str() {
"image" => self.text.node_special_image_to_text.to_string(),
"audio" => self.text.node_special_audio_to_text.to_string(),
_ => self.text.node_special_default.to_string(),
⋮----
ChainNode::Process { .. } => self.text.node_process_title.to_string(),
⋮----
fn show_header(
⋮----
ui.horizontal(|ui| {
⋮----
draw_icon_static(ui, icon, Some(16.0));
⋮----
ui.label(format!("{} {}", prefix, type_name));
⋮----
draw_icon_static(ui, Icon::Settings, Some(16.0));
⋮----
ui.label(title);
⋮----
let title = match self.preset_type.as_str() {
⋮----
let header_color = if ui.visuals().dark_mode {
⋮----
ui.label(egui::RichText::new(title).color(header_color));
⋮----
fn inputs(&mut self, node: &ChainNode) -> usize {
⋮----
fn outputs(&mut self, _node: &ChainNode) -> usize {
⋮----
fn show_input(
⋮----
// Green color for text connections
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 200, 100))
⋮----
fn show_output(
⋮----
PinInfo::circle().with_fill(egui::Color32::from_rgb(100, 150, 255))
⋮----
fn has_body(&mut self, _node: &ChainNode) -> bool {
⋮----
fn show_body(
⋮----
show_body(self, node_id, ui, snarl);
⋮----
fn has_graph_menu(&mut self, _pos: egui::Pos2, _snarl: &mut Snarl<ChainNode>) -> bool {
⋮----
fn show_graph_menu(
⋮----
let add_special_label = match self.preset_type.as_str() {
⋮----
if ui.button(add_process_label).clicked() {
snarl.insert_node(pos, ChainNode::default());
⋮----
ui.close();
⋮----
if ui.button(add_special_label).clicked() {
⋮----
snarl.insert_node(pos, node);
⋮----
fn has_node_menu(&mut self, node: &ChainNode) -> bool {
!node.is_input()
⋮----
fn show_node_menu(
⋮----
let delete_label = match self.ui_language.as_str() {
⋮----
if ui.button(delete_label).clicked() {
snarl.remove_node(node_id);
⋮----
fn connect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
let to_node = snarl.get_node(to.id.node);
let from_node = snarl.get_node(from.id.node);
⋮----
if to_node.is_special() {
if !from_node.is_input() {
⋮----
snarl.connect(from.id, to.id);
⋮----
fn disconnect(&mut self, from: &OutPin, to: &InPin, snarl: &mut Snarl<ChainNode>) {
snarl.disconnect(from.id, to.id);
</file>

<file path="src/gui/settings_ui/preset.rs">
use eframe::egui;
⋮----
use crate::gui::locale::LocaleText;
use super::get_localized_preset_name;
use egui_snarl::Snarl;
⋮----
pub fn render_preset_editor(
⋮----
if preset_idx >= config.presets.len() { return false; }
let mut preset = config.presets[preset_idx].clone();
⋮----
ui.set_max_width(510.0);
let is_default_preset = preset.id.starts_with("preset_");
⋮----
get_localized_preset_name(&preset.id, &config.ui_language)
⋮----
preset.name.clone()
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.add_space(5.0);
⋮----
.fill(header_bg)
.stroke(header_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(text.preset_name_label).strong());
⋮----
ui.label(egui::RichText::new(&display_name).strong().size(15.0));
⋮----
if ui.add(egui::TextEdit::singleline(&mut preset.name).font(egui::TextStyle::Body)).changed() {
⋮----
ui.add_space(10.0);
⋮----
if ui.checkbox(&mut preset.show_controller_ui, text.controller_checkbox_label).clicked() {
if !preset.show_controller_ui && preset.blocks.is_empty() {
preset.blocks.push(create_default_block_for_type(&preset.preset_type));
*snarl = blocks_to_snarl(&preset.blocks, &preset.block_connections, &preset.preset_type);
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.restore_preset_btn).color(egui::Color32::WHITE).small())
.fill(restore_bg)
.corner_radius(8.0))
.on_hover_text(text.restore_preset_tooltip)
.clicked() {
⋮----
if let Some(default_p) = default_config.presets.iter().find(|p| p.id == preset.id) {
preset = default_p.clone();
⋮----
request_node_graph_view_reset(ui.ctx());
⋮----
ui.add_space(6.0);
⋮----
ui.label(text.preset_type_label);
let selected_text = match preset.preset_type.as_str() {
⋮----
.selected_text(selected_text)
.show_ui(ui, |ui| {
if ui.selectable_value(&mut preset.preset_type, "image".to_string(), text.preset_type_image).clicked() {
if let Some(first) = preset.blocks.first_mut() {
first.block_type = "image".to_string();
first.model = "maverick".to_string();
⋮----
if ui.selectable_value(&mut preset.preset_type, "text".to_string(), text.preset_type_text).clicked() {
⋮----
first.block_type = "text".to_string();
first.model = "text_accurate_kimi".to_string();
⋮----
if ui.selectable_value(&mut preset.preset_type, "audio".to_string(), text.preset_type_audio).clicked() {
⋮----
first.block_type = "audio".to_string();
first.model = "whisper-accurate".to_string();
⋮----
ui.add_enabled_ui(false, |ui| {
let _ = ui.selectable_value(&mut preset.preset_type, "video".to_string(), text.preset_type_video);
⋮----
ui.add_space(15.0);
⋮----
ui.label(text.command_mode_label);
⋮----
.selected_text(if preset.prompt_mode == "dynamic" { text.prompt_mode_dynamic } else { text.prompt_mode_fixed })
⋮----
if ui.selectable_value(&mut preset.prompt_mode, "fixed".to_string(), text.prompt_mode_fixed).clicked() { changed = true; }
if ui.selectable_value(&mut preset.prompt_mode, "dynamic".to_string(), text.prompt_mode_dynamic).clicked() { changed = true; }
⋮----
ui.label(text.text_input_mode_label);
⋮----
.selected_text(if preset.text_input_mode == "type" { text.text_mode_type } else { text.text_mode_select })
⋮----
if ui.selectable_value(&mut preset.text_input_mode, "select".to_string(), text.text_mode_select).clicked() { changed = true; }
if ui.selectable_value(&mut preset.text_input_mode, "type".to_string(), text.text_mode_type).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.continuous_input, text.continuous_input_label).clicked() { changed = true; }
⋮----
let mode_label = match config.ui_language.as_str() {
⋮----
ui.label(mode_label);
let mode_record = match config.ui_language.as_str() {
⋮----
let mode_realtime = match config.ui_language.as_str() {
⋮----
.selected_text(selected_mode_text)
⋮----
if ui.selectable_value(&mut preset.audio_processing_mode, "record_then_process".to_string(), mode_record).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_processing_mode, "realtime".to_string(), mode_realtime).clicked() { changed = true; }
⋮----
ui.add_space(8.0);
⋮----
let window_mode_label = match config.ui_language.as_str() {
⋮----
ui.label(window_mode_label);
let mode_standard = match config.ui_language.as_str() {
⋮----
let mode_minimal = match config.ui_language.as_str() {
⋮----
.selected_text(selected_window_mode)
⋮----
if ui.selectable_value(&mut preset.realtime_window_mode, "standard".to_string(), mode_standard).clicked() { changed = true; }
if ui.selectable_value(&mut preset.realtime_window_mode, "minimal".to_string(), mode_minimal).clicked() { changed = true; }
⋮----
ui.label(text.audio_source_label);
⋮----
if ui.selectable_value(&mut preset.audio_source, "mic".to_string(), text.audio_src_mic).clicked() { changed = true; }
if ui.selectable_value(&mut preset.audio_source, "device".to_string(), text.audio_src_device).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.hide_recording_ui, text.hide_recording_ui_label).clicked() { changed = true; }
⋮----
if ui.checkbox(&mut preset.auto_stop_recording, text.auto_stop_recording_label).clicked() { changed = true; }
⋮----
let has_any_auto_copy = preset.blocks.iter().any(|b| b.auto_copy && b.block_type != "input_adapter");
⋮----
if ui.checkbox(&mut preset.auto_paste, text.auto_paste_label).clicked() { changed = true; }
if ui.checkbox(&mut preset.auto_paste_newline, text.auto_paste_newline_label).clicked() { changed = true; }
⋮----
ui.label(egui::RichText::new(text.hotkeys_section).strong());
⋮----
if *recording_hotkey_for_preset == Some(preset_idx) {
⋮----
ui.colored_label(text_color, text.press_keys);
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.cancel_label).color(egui::Color32::WHITE))
.fill(cancel_bg)
.corner_radius(10.0))
⋮----
if ui.add(egui::Button::new(egui::RichText::new(text.add_hotkey_button).color(egui::Color32::WHITE))
.fill(add_bg)
⋮----
.on_hover_cursor(egui::CursorIcon::PointingHand)
⋮----
*recording_hotkey_for_preset = Some(preset_idx);
⋮----
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if ui.add(egui::Button::new(egui::RichText::new(format!("{} ×", hotkey.name)).color(egui::Color32::WHITE).small())
.fill(hotkey_bg)
⋮----
hotkey_to_remove = Some(h_idx);
⋮----
if let Some(h) = hotkey_to_remove { preset.hotkeys.remove(h); changed = true; }
⋮----
ui.colored_label(egui::Color32::RED, msg);
⋮----
ui.push_id("node_graph_area", |ui| {
⋮----
.fill(graph_bg)
.inner_margin(6.0)
.corner_radius(8.0)
⋮----
ui.set_min_height(325.0);
if render_node_graph(ui, snarl, &config.ui_language, &preset.prompt_mode, config.use_groq, config.use_gemini, config.use_openrouter, config.use_ollama, &preset.preset_type, text) {
⋮----
ui.add_space(20.0);
⋮----
.fill(bg_color)
.inner_margin(24.0)
.corner_radius(12.0)
⋮----
ui.set_min_height(260.0);
⋮----
match config.ui_language.as_str() {
⋮----
ui.label(egui::RichText::new(title).heading().color(accent_color));
ui.add_space(16.0);
⋮----
ui.label(egui::RichText::new(desc).color(text_color));
⋮----
fn create_default_block_for_type(preset_type: &str) -> ProcessingBlock {
⋮----
block_type: "audio".to_string(),
model: "whisper-accurate".to_string(),
prompt: "Transcribe this audio.".to_string(),
selected_language: "Vietnamese".to_string(),
⋮----
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Process this text.".to_string(),
⋮----
block_type: "image".to_string(),
model: "maverick".to_string(),
prompt: "Extract text from this image.".to_string(),
</file>

<file path="src/icon_gen.rs">
use eframe::egui;
use lazy_static::lazy_static;
use tray_icon::Icon;
struct SafeIcon(Icon);
unsafe impl Send for SafeIcon {}
unsafe impl Sync for SafeIcon {}
lazy_static! {
⋮----
fn load_tray_icon(is_system_dark: bool) -> Icon {
⋮----
include_bytes!("../assets/tray_icon.png")
⋮----
include_bytes!("../assets/tray_icon-light.png")
⋮----
let img = image::load_from_memory(icon_bytes).expect("Failed to load tray icon");
let img_rgba = img.to_rgba8();
let (width, height) = img_rgba.dimensions();
let rgba = img_rgba.into_raw();
tray_icon::Icon::from_rgba(rgba, width, height).unwrap()
⋮----
pub fn get_tray_icon(is_system_dark: bool) -> Icon {
⋮----
TRAY_ICON_DARK.0.clone()
⋮----
TRAY_ICON_LIGHT.0.clone()
⋮----
pub fn get_window_icon(is_system_dark: bool) -> egui::IconData {
⋮----
include_bytes!("../assets/app-icon-small.png")
⋮----
include_bytes!("../assets/app-icon-small-light.png")
⋮----
let img = image::load_from_memory(icon_bytes).expect("Failed to load app icon");
⋮----
rgba: img_rgba.into_vec(),
</file>

<file path="src/overlay/favorite_bubble/render.rs">
use std::sync::atomic::Ordering;
⋮----
pub fn update_bubble_visual(hwnd: HWND) {
⋮----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
let bubble_size = BUBBLE_SIZE.load(Ordering::SeqCst);
⋮----
CreateDIBSection(Some(hdc_mem), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
let old_bm = SelectObject(hdc_mem, hbm.into());
if !bits.is_null() {
⋮----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
draw_bubble_pixels(pixels, bubble_size, is_hovered || is_expanded);
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(hdc_screen),
Some(&pt_dst),
Some(&size),
Some(hdc_mem),
Some(&pt_src),
COLORREF(0),
Some(&blend),
⋮----
let _ = SelectObject(hdc_mem, old_bm);
let _ = DeleteObject(hbm.into());
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
⋮----
fn draw_bubble_pixels(pixels: &mut [u32], size: i32, _is_active: bool) {
let opacity = CURRENT_OPACITY.load(Ordering::SeqCst);
let is_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
let icon_data = get_icon_data(size, is_dark);
if !icon_data.is_empty() {
⋮----
if src_idx + 3 < icon_data.len() {
⋮----
let dist = (dx * dx + dy * dy).sqrt();
</file>

<file path="src/overlay/favorite_bubble/state.rs">
use std::cell::RefCell;
⋮----
thread_local! {
⋮----
const ICON_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small.png");
const ICON_LIGHT_PNG_BYTES: &[u8] = include_bytes!("../../../assets/app-icon-small-light.png");
pub fn get_icon_data(size: i32, is_dark: bool) -> Vec<u8> {
⋮----
CACHED_ICON.with(|cache| {
let mut cache = cache.borrow_mut();
⋮----
*cache = (size, decode_icon(ICON_PNG_BYTES, size));
⋮----
cache.1.clone()
⋮----
CACHED_ICON_LIGHT.with(|cache| {
⋮----
*cache = (size, decode_icon(ICON_LIGHT_PNG_BYTES, size));
⋮----
fn decode_icon(bytes: &[u8], size: i32) -> Vec<u8> {
⋮----
let resized = img.resize_exact(
⋮----
resized.to_rgba8().into_raw()
⋮----
vec![]
</file>

<file path="src/overlay/html_components/css_main.rs">
pub fn get(glow_color: &str, font_size: u32, is_dark: bool) -> String {
⋮----
format!("{}40", glow_color),
⋮----
format!("{}80", glow_color),
⋮----
format!("0 0 20px {}30", glow_color)
⋮----
format!("0 0 20px {}20", glow_color)
⋮----
format!(
</file>

<file path="src/overlay/html_components/css_modals.rs">
pub fn get(is_dark: bool) -> String {
⋮----
format!(
</file>

<file path="src/overlay/html_components/grid_js.rs">
pub fn get_css() -> &'static str {
⋮----
pub fn get_init_script() -> &'static str {
⋮----
pub fn get_lib_urls() -> (&'static str, &'static str) {
</file>

<file path="src/overlay/html_components/js_logic.rs">
pub fn get(placeholder_text: &str) -> String {
format!(
</file>

<file path="src/overlay/process/types.rs">
use crate::overlay::result::layout::calculate_next_window_rect;
use std::collections::HashMap;
use std::sync::Mutex;
⋮----
pub struct ProcessingState {
⋮----
unsafe impl Send for ProcessingState {}
unsafe impl Sync for ProcessingState {}
impl ProcessingState {
pub fn new(graphics_mode: String) -> Self {
⋮----
pub fn cleanup(&mut self) {
if !self.cache_hbm.is_invalid() {
⋮----
let _ = DeleteObject(self.cache_hbm.into());
⋮----
pub fn generate_chain_id() -> String {
⋮----
.duration_since(UNIX_EPOCH)
.unwrap_or_default()
.as_nanos() as u64;
let count = COUNTER.fetch_add(1, Ordering::Relaxed);
format!("chain-{}-{}", timestamp, count)
⋮----
pub fn get_next_window_position_for_chain(chain_id: &str, initial_rect: RECT) -> RECT {
let mut positions = CHAIN_WINDOW_POSITIONS.lock().unwrap();
⋮----
let h_monitor = MonitorFromRect(&initial_rect, MONITOR_DEFAULTTONEAREST);
⋮----
if GetMonitorInfoW(h_monitor, &mut mi).as_bool() {
⋮----
right: GetSystemMetrics(SM_CXSCREEN),
bottom: GetSystemMetrics(SM_CYSCREEN),
⋮----
let next_rect = match positions.get(chain_id) {
⋮----
calculate_next_window_rect(prev, monitor_rect)
⋮----
positions.insert(chain_id.to_string(), next_rect);
</file>

<file path="src/overlay/realtime_html.rs">
use crate::gui::locale::LocaleText;
pub fn get_realtime_html(
⋮----
format!("{}", title_text)
⋮----
r#"<canvas id="volume-canvas" width="90" height="24"></canvas>"#.to_string()
⋮----
// Build language options HTML - show full name in dropdown, but store code for display
⋮----
.iter()
.map(|lang| {
⋮----
// Get 2-letter ISO 639-1 code
⋮----
.and_then(|l| l.to_639_1())
.map(|c| c.to_uppercase())
.unwrap_or_else(|| lang.chars().take(2).collect::<String>().to_uppercase());
// Option shows full name, but we store code as data attribute for selected display
format!(
⋮----
.join("\n");
⋮----
// Construct CSS and JS from components
let css = format!(
⋮----
let js = format!(
⋮----
// Get local font CSS (cached fonts, no network loading)
</file>

<file path="src/overlay/realtime_webview.rs">
pub mod app_selection;
pub mod manager;
pub mod state;
pub mod webview;
pub mod wndproc;
</file>

<file path="src/overlay/realtime_webview/state.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
⋮----
pub static mut REALTIME_HWND: HWND = HWND(std::ptr::null_mut());
pub static mut TRANSLATION_HWND: HWND = HWND(std::ptr::null_mut());
⋮----
thread_local! {
⋮----
pub struct HwndWrapper(pub HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
</file>

<file path="src/overlay/realtime_webview/wndproc.rs">
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
⋮----
use wry::Rect;
pub unsafe extern "system" fn realtime_wnd_proc(
⋮----
let _ = ReleaseCapture();
let _ = SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
LRESULT(0)
⋮----
MIC_VISIBLE.store(val, Ordering::SeqCst);
⋮----
TRANS_VISIBLE.store(val, Ordering::SeqCst);
⋮----
if !ptr.is_null() {
⋮----
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(&script);
⋮----
if CLOSE_TTS_MODAL_REQUEST.load(Ordering::SeqCst) {
if CLOSE_TTS_MODAL_REQUEST.swap(false, Ordering::SeqCst) {
⋮----
let _ = webview.evaluate_script(script);
⋮----
if let Ok(state) = REALTIME_STATE.lock() {
⋮----
let pos = state.last_committed_pos.min(full.len());
⋮----
let old = old_raw.trim_end();
let new = new_raw.trim_start();
if !old.is_empty() && !new.is_empty() {
(old.to_string(), format!(" {}", new))
⋮----
(old.to_string(), new.to_string())
⋮----
update_webview_text(hwnd, &old_text, &new_text);
⋮----
state.download_title.clone(),
state.download_message.clone(),
⋮----
let script = format!(
⋮----
let rms_bits = REALTIME_RMS.load(Ordering::Relaxed);
⋮----
let script = format!("if(window.updateVolume) window.updateVolume({});", rms);
⋮----
update_webview_theme(hwnd);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_REALTIME_HIDE, WPARAM(0), LPARAM(0));
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
let _ = ShowWindow(hwnd, SW_HIDE);
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
let _ = ShowWindow(TRANSLATION_HWND, SW_HIDE);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
let _ = DestroyWindow(TRANSLATION_HWND);
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
pub unsafe extern "system" fn translation_wnd_proc(
⋮----
let old = state.committed_translation.trim_end();
let new = state.uncommitted_translation.trim_start();
⋮----
let app_selected = SELECTED_APP_PID.load(Ordering::SeqCst) > 0;
⋮----
.lock()
.map(|s| s.is_empty() || s.as_str() == "mic")
.unwrap_or(true);
⋮----
if REALTIME_TTS_ENABLED.load(Ordering::SeqCst) && tts_allowed && !old_text.is_empty() {
let old_len = old_text.len();
if LAST_SPOKEN_LENGTH.load(Ordering::SeqCst) == 0 && old_len > 50 {
let text = old_text.trim_end();
let search_limit = text.len().saturating_sub(1);
⋮----
.rfind(|c| c == '.' || c == '?' || c == '!' || c == '\n');
⋮----
LAST_SPOKEN_LENGTH.store(idx + 1, Ordering::SeqCst);
⋮----
let last_spoken = LAST_SPOKEN_LENGTH.load(Ordering::SeqCst);
⋮----
let new_committed = old_text[last_spoken..].to_string();
if !new_committed.trim().is_empty() {
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.push_back(new_committed.clone());
⋮----
crate::api::tts::TTS_MANAGER.speak_realtime(&new_committed, hwnd_val);
⋮----
LAST_SPOKEN_LENGTH.store(old_len, Ordering::SeqCst);
⋮----
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
WM_DESTROY => LRESULT(0),
</file>

<file path="src/overlay/result/event_handler/click_actions.rs">
use std::mem::size_of;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
⋮----
use windows::core::PCWSTR;
use windows::Win32::Graphics::Gdi::InvalidateRect;
⋮----
use super::misc::WM_CREATE_WEBVIEW;
⋮----
use crate::overlay::utils::to_wstring;
pub unsafe fn handle_lbutton_up(hwnd: HWND) -> LRESULT {
let _ = ReleaseCapture();
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
let was_resizing = matches!(state.interaction_mode, InteractionMode::Resizing(_));
⋮----
if let Some(last) = state.text_history.pop() {
let current_text_for_redo = state.full_text.clone();
prev_text = Some(last.clone());
⋮----
if !current_text_for_redo.is_empty() {
state.redo_history.push(current_text_for_redo);
⋮----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
if let Some(redo_text) = state.redo_history.pop() {
let current_text_for_undo = state.full_text.clone();
next_text = Some(redo_text.clone());
⋮----
if !current_text_for_undo.is_empty() {
state.text_history.push(current_text_for_undo);
⋮----
let text_len = GetWindowTextLengthW(hwnd) + 1;
let mut buf = vec![0u16; text_len as usize];
GetWindowTextW(hwnd, &mut buf);
let text = String::from_utf16_lossy(&buf[..text_len as usize - 1]).to_string();
⋮----
SetTimer(Some(hwnd), 1, 1500, None);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
(state.is_markdown_mode, state.full_text.clone())
⋮----
let _ = PostMessageW(Some(hwnd), WM_CREATE_WEBVIEW, WPARAM(0), LPARAM(0));
SetTimer(Some(hwnd), 2, 30, None);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND::default()),
⋮----
let _ = KillTimer(Some(hwnd), 2);
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
state.full_text.clone()
⋮----
if !full_text.is_empty() {
⋮----
state.full_text.clone(),
⋮----
&& crate::api::tts::TTS_MANAGER.is_speaking(current_tts_id)
⋮----
crate::api::tts::TTS_MANAGER.stop();
⋮----
} else if !full_text.is_empty() {
⋮----
let request_id = crate::api::tts::TTS_MANAGER.speak(&full_text, hwnd.0 as isize);
⋮----
if IsWindow(Some(linked)).as_bool() {
let _ = PostMessageW(Some(linked), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
LRESULT(0)
⋮----
pub unsafe fn handle_rbutton_up(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_mbutton_up() -> LRESULT {
⋮----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_int, _) in states.iter() {
targets.push(HWND(hwnd_int as *mut std::ffi::c_void));
⋮----
if IsWindow(Some(target)).as_bool() {
let _ = PostMessageW(Some(target), WM_CLOSE, WPARAM(0), LPARAM(0));
</file>

<file path="src/overlay/result/event_handler/misc.rs">
use std::sync::Arc;
⋮----
use crate::overlay::result::button_canvas;
use crate::overlay::result::markdown_view;
use crate::overlay::result::paint;
use crate::overlay::result::state::WINDOW_STATES;
⋮----
pub unsafe fn handle_erase_bkgnd(_hwnd: HWND, _wparam: WPARAM) -> LRESULT {
LRESULT(1)
⋮----
pub unsafe fn handle_destroy(hwnd: HWND) -> LRESULT {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.remove(&(hwnd.0 as isize)) {
⋮----
crate::api::tts::TTS_MANAGER.stop_if_active(state.tts_request_id);
⋮----
token_to_signal = state.cancellation_token.clone();
⋮----
token.store(true, std::sync::atomic::Ordering::Relaxed);
⋮----
.iter()
.filter(|(_, s)| {
⋮----
.map(|(k, _)| HWND(*k as *mut core::ffi::c_void))
.collect();
⋮----
if !state.content_bitmap.is_invalid() {
let _ = DeleteObject(state.content_bitmap.into());
⋮----
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
⋮----
let _ = KillTimer(Some(hwnd), 2);
⋮----
let _ = PostMessageW(Some(other_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
LRESULT(0)
⋮----
pub unsafe fn handle_paint(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_keydown() -> LRESULT {
⋮----
pub unsafe fn handle_create_webview(hwnd: HWND) -> LRESULT {
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
(state.full_text.clone(), state.is_hovered)
⋮----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
pub unsafe fn handle_show_markdown(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_hide_markdown(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_resize_markdown(hwnd: HWND) -> LRESULT {
⋮----
.get(&(hwnd.0 as isize))
.map(|s| s.is_hovered)
.unwrap_or(false)
⋮----
pub unsafe fn handle_back_click(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_forward_click(hwnd: HWND) -> LRESULT {
⋮----
pub unsafe fn handle_download_click(hwnd: HWND) -> LRESULT {
⋮----
.map(|s| s.full_text.clone())
.unwrap_or_default()
⋮----
if !text.is_empty() {
</file>

<file path="src/overlay/result/event_handler/mod.rs">
pub mod click_actions;
pub mod misc;
pub mod mouse_input;
pub mod timer_tasks;
⋮----
pub unsafe extern "system" fn result_wnd_proc(
⋮----
if !mmi.is_null() {
⋮----
LRESULT(0)
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
let states = crate::overlay::result::state::WINDOW_STATES.lock().unwrap();
⋮----
.get(&(hwnd.0 as isize))
.map(|s| s.is_markdown_mode)
.unwrap_or(false)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/result/event_handler/mouse_input.rs">
use std::mem::size_of;
use std::sync::Arc;
⋮----
use crate::overlay::result::button_canvas;
⋮----
use crate::overlay::result::markdown_view;
⋮----
pub unsafe fn handle_set_cursor(hwnd: HWND) -> LRESULT {
let mut cursor_id = PCWSTR(std::ptr::null());
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let _ = GetCursorPos(&mut pt);
let _ = ScreenToClient(hwnd, &mut pt);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
SetCursor(Some(LoadCursorW(None, IDC_IBEAM).unwrap()));
return LRESULT(1);
⋮----
let edge = get_resize_edge(rect.right, rect.bottom, pt.x, pt.y);
⋮----
if !is_streaming_active && should_show_buttons(rect.right, rect.bottom) {
let copy_rect = get_copy_btn_rect(rect.right, rect.bottom);
let edit_rect = get_edit_btn_rect(rect.right, rect.bottom);
let undo_rect = get_undo_btn_rect(rect.right, rect.bottom);
⋮----
has_history = !state.text_history.is_empty();
⋮----
let md_rect = get_markdown_btn_rect(rect.right, rect.bottom);
⋮----
let dl_rect = get_download_btn_rect(rect.right, rect.bottom);
⋮----
let speaker_rect = get_speaker_btn_rect(rect.right, rect.bottom);
⋮----
if !cursor_id.0.is_null() {
SetCursor(Some(LoadCursorW(None, cursor_id).unwrap()));
LRESULT(1)
⋮----
SetCursor(Some(HCURSOR(std::ptr::null_mut())));
⋮----
pub unsafe fn handle_lbutton_down(hwnd: HWND, lparam: LPARAM) -> LRESULT {
⋮----
let edge = get_resize_edge(width, height, x, y);
⋮----
let _ = GetWindowRect(hwnd, &mut window_rect);
⋮----
let _ = GetCursorPos(&mut screen_pt);
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let is_markdown = if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
SetCapture(hwnd);
⋮----
LRESULT(0)
⋮----
pub unsafe fn handle_rbutton_down(hwnd: HWND, _lparam: LPARAM) -> LRESULT {
⋮----
token_to_match = state.cancellation_token.clone();
⋮----
for (&h_val, s) in states.iter() {
⋮----
let h = HWND(h_val as *mut std::ffi::c_void);
⋮----
let _ = GetWindowRect(h, &mut r);
group_snapshot.push((h, r));
⋮----
if group_snapshot.len() <= 1 {
group_snapshot.clear();
⋮----
queue.push_back(hwnd);
visited.insert(hwnd.0);
while let Some(current) = queue.pop_front() {
⋮----
let _ = GetWindowRect(current, &mut r);
group_snapshot.push((current, r));
if let Some(s) = states.get(&(current.0 as isize)) {
⋮----
if states.contains_key(&(linked.0 as isize)) {
if !visited.contains(&linked.0) {
visited.insert(linked.0);
queue.push_back(linked);
⋮----
pub unsafe fn handle_mouse_move(hwnd: HWND, lparam: LPARAM) -> LRESULT {
⋮----
let hover_edge = get_resize_edge(rect.right, rect.bottom, x as i32, y as i32);
⋮----
let drag_impulse = if matches!(
⋮----
(dx * 1.5).clamp(-20.0, 20.0)
⋮----
state.physics.current_tilt = state.physics.current_tilt.clamp(-22.5, 22.5);
⋮----
if !state.is_streaming_active && should_show_buttons(rect.right, rect.bottom) {
⋮----
if !state.text_history.is_empty() && !state.is_browsing {
⋮----
let redo_rect = get_redo_btn_rect(rect.right, rect.bottom);
if !state.redo_history.is_empty() && !state.is_browsing {
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
let _ = GetCursorPos(&mut curr_pt);
⋮----
if dx.abs() > 3 || dy.abs() > 3 {
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND::default()),
⋮----
group_moves.push((*h, new_x, new_y));
⋮----
.max(state.drag_start_window_rect.left + min_w);
⋮----
.min(state.drag_start_window_rect.right - min_w);
⋮----
.max(state.drag_start_window_rect.top + min_h);
⋮----
.min(state.drag_start_window_rect.bottom - min_h);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
pub unsafe fn handle_mouse_leave(hwnd: HWND) -> LRESULT {
</file>

<file path="src/overlay/result/paint.rs">
use super::layout::should_show_buttons;
⋮----
use std::mem::size_of;
use windows::core::w;
⋮----
unsafe fn measure_text_bounds(
⋮----
let hfont = CreateFontW(
⋮----
w!("Google Sans Flex"),
⋮----
let old_font = SelectObject(hdc, hfont.into());
⋮----
DrawTextW(
⋮----
SelectObject(hdc, old_font);
let _ = DeleteObject(hfont.into());
⋮----
pub fn create_bitmap_from_pixels(pixels: &[u32], w: i32, h: i32) -> HBITMAP {
⋮----
let hdc = GetDC(None);
⋮----
let hbm = CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut bits, None, 0).unwrap();
if !bits.is_null() {
⋮----
pixels.as_ptr() as *const u8,
⋮----
pixels.len() * 4,
⋮----
ReleaseDC(None, hdc);
⋮----
fn dist_segment(px: f32, py: f32, ax: f32, ay: f32, bx: f32, by: f32) -> f32 {
⋮----
let h = (pax * bax + pay * bay) / (bax * bax + bay * bay).max(0.001);
let h = h.clamp(0.0, 1.0);
⋮----
(dx * dx + dy * dy).sqrt()
⋮----
fn sd_box(px: f32, py: f32, cx: f32, cy: f32, w: f32, h: f32) -> f32 {
let dx = (px - cx).abs() - w;
let dy = (py - cy).abs() - h;
(dx.max(0.0).powi(2) + dy.max(0.0).powi(2)).sqrt() + dx.max(dy).min(0.0)
⋮----
pub fn paint_window(hwnd: HWND) {
⋮----
let hdc = BeginPaint(hwnd, &mut ps);
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
if state.bg_bitmap.is_invalid() || state.bg_w != width || state.bg_h != height {
if !state.bg_bitmap.is_invalid() {
let _ = DeleteObject(state.bg_bitmap.into());
⋮----
CreateDIBSection(Some(hdc), &bmi, DIB_RGB_COLORS, &mut p_bg_bits, None, 0)
.unwrap();
if !p_bg_bits.is_null() {
⋮----
pixels.fill(col);
⋮----
.duration_since(std::time::UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
let time_since_last_resize = now.wrapping_sub(state.last_resize_time);
⋮----
.iter()
.map(|p| (p.x, p.y, p.life, p.size, p.color))
.collect();
⋮----
Some((
⋮----
&& crate::api::tts::TTS_MANAGER.is_speaking(state.tts_request_id);
⋮----
state.text_history.len(),
state.redo_history.len(),
⋮----
state.graphics_mode.clone(),
state.preset_prompt.clone(),
state.input_text.clone(),
⋮----
"standard".to_string(),
⋮----
let mem_dc = CreateCompatibleDC(Some(hdc));
⋮----
let scratch_bitmap = CreateDIBSection(
Some(hdc),
⋮----
let old_scratch = SelectObject(mem_dc, scratch_bitmap.into());
if !cached_bg_bm.is_invalid() {
let cache_dc = CreateCompatibleDC(Some(hdc));
let old_cbm = SelectObject(cache_dc, cached_bg_bm.into());
let _ = BitBlt(mem_dc, 0, 0, width, height, Some(cache_dc), 0, 0, SRCCOPY).ok();
SelectObject(cache_dc, old_cbm);
let _ = DeleteDC(cache_dc);
⋮----
if cache_dirty || cached_text_bm.is_invalid() {
if !cached_text_bm.is_invalid() {
let _ = DeleteObject(cached_text_bm.into());
⋮----
cached_text_bm = CreateCompatibleBitmap(hdc, width, height);
⋮----
let old_cache_bm = SelectObject(cache_dc, cached_text_bm.into());
let dark_brush = CreateSolidBrush(COLORREF(bg_color_u32));
⋮----
FillRect(cache_dc, &fill_rect, dark_brush);
let _ = DeleteObject(dark_brush.into());
SetBkMode(cache_dc, TRANSPARENT);
⋮----
SetTextColor(cache_dc, COLORREF(text_col));
⋮----
vec![0u16; 1]
⋮----
let combined = if input_text.is_empty() {
preset_prompt.clone()
⋮----
format!("{}\n\n{}", preset_prompt, input_text)
⋮----
quote.encode_utf16().collect::<Vec<u16>>()
⋮----
let text_len = GetWindowTextLengthW(hwnd);
let mut b = vec![0u16; text_len as usize + 1];
let actual_len = GetWindowTextW(hwnd, &mut b);
b.truncate(actual_len as usize);
⋮----
let available_w = (width - (h_padding * 2)).max(1);
⋮----
let available_h = (height - v_safety_margin).max(1);
⋮----
18.min(available_h)
⋮----
available_h.max(2).min(150)
⋮----
let (h, w) = measure_text_bounds(cache_dc, &mut buf, mid, available_w);
⋮----
let old_font = SelectObject(cache_dc, hfont.into());
⋮----
let offset_y = ((height - text_h) / 2).max(0);
⋮----
DrawTextW(cache_dc, &mut buf, &mut draw_rect as *mut _, draw_flags);
SelectObject(cache_dc, old_font);
⋮----
SelectObject(cache_dc, old_cache_bm);
⋮----
let old_cbm = SelectObject(cache_dc, cached_text_bm.into());
⋮----
if !scratch_bits.is_null() {
⋮----
let cycle = (anim_offset.abs() % 360.0) / 180.0;
⋮----
margin + ((t * scan_range as f32) as i32).clamp(0, scan_range - 1);
⋮----
if idx < raw_pixels.len() {
⋮----
let time_rad = anim_offset.to_radians();
⋮----
let d = sd_rounded_box(px, py, bx, by, 12.0);
⋮----
let dist = d.abs();
⋮----
let angle = py.atan2(px);
let noise = (angle * 12.0 - time_rad * 2.0).sin() * 0.5;
⋮----
let t = (dist / glow_width).clamp(0.0, 1.0);
let base_intensity = (1.0 - t).powi(3);
⋮----
let noise_mod = (1.0 + noise * 0.3).clamp(0.0, 2.0);
⋮----
(base_intensity * noise_mod).clamp(0.0, 1.0);
⋮----
let deg = angle.to_degrees() + (anim_offset * 2.0);
⋮----
let rgb = hsv_to_rgb(hue, 0.85, 1.0);
⋮----
let min_x = (d_x - radius - 1.0).floor() as i32;
let max_x = (d_x + radius + 1.0).ceil() as i32;
let min_y = (d_y - radius - 1.0).floor() as i32;
let max_y = (d_y + radius + 1.0).ceil() as i32;
let start_x = min_x.max(0);
let end_x = max_x.min(width - 1);
let start_y = min_y.max(0);
let end_y = max_y.min(height - 1);
⋮----
let dist = (dx * dx + dy * dy).sqrt();
let aa_edge = (radius + 0.5 - dist).clamp(0.0, 1.0);
⋮----
&& should_show_buttons(width, height)
⋮----
for y in b_start_y.max(0)..b_end_y.min(height) {
⋮----
let dy = (fy - cy).abs();
⋮----
let dx = (fx - cx_back).abs();
⋮----
let aa = (radius + 0.5 - dist).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist).clamp(0.0, 1.0)
* ((dist - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d_shaft = dist_segment(fx, fy, tip_x, cy, tail_x, cy);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy - 3.0);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x + 3.0, cy + 3.0);
let d_arrow = d_shaft.min(d_wing1).min(d_wing2);
icon_alpha = (1.3 - d_arrow).clamp(0.0, 1.0);
⋮----
let dx = (fx - cx_forward).abs();
⋮----
let d_shaft = dist_segment(fx, fy, tail_x, cy, tip_x, cy);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy - 3.0);
⋮----
dist_segment(fx, fy, tip_x, cy, tip_x - 3.0, cy + 3.0);
⋮----
let dx_c = (fx - cx_copy).abs();
let dist_c = (dx_c * dx_c + dy * dy).sqrt();
let aa_c = (radius + 0.5 - dist_c).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_c).clamp(0.0, 1.0)
* ((dist_c - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d1 = dist_segment(
⋮----
let d2 = dist_segment(
⋮----
icon_alpha = (1.8 - d1.min(d2)).clamp(0.0, 1.0);
⋮----
let back_d = sd_box(fx, fy, cx_copy - 2.0, cy - 2.0, 3.0, 4.0);
let back_outline = (1.25 - back_d.abs()).clamp(0.0, 1.0);
let front_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 3.0, 4.0);
let front_fill = (0.8 - front_d).clamp(0.0, 1.0);
let mask_d = sd_box(fx, fy, cx_copy + 2.0, cy + 2.0, 4.5, 5.5);
⋮----
+ back_outline * mask_d.clamp(0.0, 1.0))
.clamp(0.0, 1.0);
⋮----
let dx_e = (fx - cx_edit).abs();
let dist_e = (dx_e * dx_e + dy * dy).sqrt();
let aa_e = (radius + 0.5 - dist_e).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_e).clamp(0.0, 1.0)
* ((dist_e - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let sx = (fx - cx_edit).abs();
let sy = (fy - cy).abs();
⋮----
(sx.powf(0.6) + sy.powf(0.6)).powf(1.0 / 0.6) - 4.5;
let mut ia = (1.2 - star_dist).clamp(0.0, 1.0);
let sx2 = (fx - (cx_edit + 4.5)).abs();
let sy2 = (fy - (cy - 3.5)).abs();
⋮----
(sx2.powf(0.6) + sy2.powf(0.6)).powf(1.0 / 0.6) - 2.2;
ia = ia.max((1.2 - star2_dist).clamp(0.0, 1.0));
⋮----
let dx_m = (fx - cx_md).abs();
let dist_m = (dx_m * dx_m + dy * dy).sqrt();
let aa_m = (radius + 0.5 - dist_m).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_m).clamp(0.0, 1.0)
* ((dist_m - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let d_m1 = dist_segment(
⋮----
let d_m2 = dist_segment(
⋮----
let d_m3 = dist_segment(
⋮----
let d_m4 = dist_segment(
⋮----
let d_m = d_m1.min(d_m2).min(d_m3).min(d_m4);
icon_alpha = (1.5 - d_m).clamp(0.0, 1.0);
⋮----
let dx_dl = (fx - cx_dl).abs();
let dist_dl = (dx_dl * dx_dl + dy * dy).sqrt();
let aa_dl = (radius + 0.5 - dist_dl).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_dl).clamp(0.0, 1.0)
⋮----
.clamp(0.0, 1.0)))
⋮----
dist_segment(fx, fy, cx_dl, cy - 4.0, cx_dl, cy + 2.0);
let d_arrow1 = dist_segment(
⋮----
let d_arrow2 = dist_segment(
⋮----
let d_tray = dist_segment(
⋮----
let d_icon = d_line.min(d_arrow1).min(d_arrow2).min(d_tray);
icon_alpha = (1.5 - d_icon).clamp(0.0, 1.0);
⋮----
let dx_u = (fx - cx_undo).abs();
let dist_u = (dx_u * dx_u + dy * dy).sqrt();
let aa_u = (radius + 0.5 - dist_u).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_u).clamp(0.0, 1.0)
* ((dist_u - (border_inner_radius - 0.5)).clamp(0.0, 1.0)))
⋮----
let dx_rd = (fx - cx_redo).abs();
let dist_rd = (dx_rd * dx_rd + dy * dy).sqrt();
let aa_rd = (radius + 0.5 - dist_rd).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_rd).clamp(0.0, 1.0)
⋮----
let dx_sp = (fx - cx_speaker).abs();
let dist_sp = (dx_sp * dx_sp + dy * dy).sqrt();
let aa_sp = (radius + 0.5 - dist_sp).clamp(0.0, 1.0);
⋮----
border_alpha = ((radius + 0.5 - dist_sp).clamp(0.0, 1.0)
⋮----
let d_cone = sd_box(
⋮----
let d_bell1 = dist_segment(
⋮----
let d_bell2 = dist_segment(
⋮----
let d_bell3 = dist_segment(
⋮----
let d_bell = d_bell1.min(d_bell2).min(d_bell3);
⋮----
let angle = py_wave.atan2(px);
⋮----
if px > 0.0 && angle.abs() < std::f32::consts::FRAC_PI_3 {
let dist_from_center = (px * px + py_wave * py_wave).sqrt();
let d_wave1 = (dist_from_center - 3.5).abs() - 0.8;
let d_wave2 = (dist_from_center - 6.0).abs() - 0.8;
d_wave = d_wave1.min(d_wave2);
⋮----
let d_speaker = d_cone.min(d_bell).min(d_wave);
icon_alpha = (1.5 - d_speaker).clamp(0.0, 1.0);
⋮----
| ((final_r.min(255.0) as u32) << 16)
| ((final_g.min(255.0) as u32) << 8)
| (final_b.min(255.0) as u32);
⋮----
let pixels = render_procedural_broom(params);
let hbm = create_bitmap_from_pixels(&pixels, BROOM_W, BROOM_H);
Some((bx, by, hbm))
⋮----
if !hbm.is_invalid() {
let broom_dc = CreateCompatibleDC(Some(hdc));
let old_hbm_broom = SelectObject(broom_dc, hbm.into());
⋮----
let _ = GdiAlphaBlend(
⋮----
SelectObject(broom_dc, old_hbm_broom);
let _ = DeleteDC(broom_dc);
let _ = DeleteObject(hbm.into());
⋮----
let _ = BitBlt(hdc, 0, 0, width, height, Some(mem_dc), 0, 0, SRCCOPY).ok();
SelectObject(mem_dc, old_scratch);
let _ = DeleteObject(scratch_bitmap.into());
let _ = DeleteDC(mem_dc);
let _ = EndPaint(hwnd, &mut ps);
</file>

<file path="src/overlay/text_selection_webview/html.rs">
pub fn get_html(is_dark: bool, initial_text: &str) -> String {
⋮----
format!(
</file>

<file path="src/registry_integration.rs">
use winreg::RegKey;
⋮----
pub fn ensure_context_menu_entry() {
⋮----
let exe_path_str = exe_path.to_str().unwrap_or("");
if exe_path_str.is_empty() {
⋮----
// 1. Remove the old global entry if it exists (Cleanup)
if let Ok(classes) = hkcu.open_subkey("Software\\Classes") {
if let Ok(star) = classes.open_subkey("*") {
if let Ok(shell) = star.open_subkey("shell") {
let _ = shell.delete_subkey_all("SGT_Process");
let _ = shell.delete_subkey_all("Process with SGT");
⋮----
.iter()
.chain(IMAGE_EXTENSIONS.iter())
.chain(AUDIO_EXTENSIONS.iter())
.chain(TEXT_EXTENSIONS.iter())
.cloned()
.collect();
⋮----
let path = format!(
⋮----
if let Ok((key, _)) = hkcu.create_subkey(&path) {
let _ = key.set_value("", &"Process with SGT");
let _ = key.set_value("Icon", &exe_path_str);
if let Ok((cmd_key, _)) = key.create_subkey("command") {
let cmd_str = format!("\"{}\" \"%1\"", exe_path_str);
let _ = cmd_key.set_value("", &cmd_str);
</file>

<file path="src/updater.rs">
use std::sync::mpsc::Sender;
use std::thread;
⋮----
pub enum UpdateStatus {
⋮----
pub struct Updater {
⋮----
impl Updater {
pub fn new(tx: Sender<UpdateStatus>) -> Self {
⋮----
pub fn check_for_updates(&self) {
let tx = self.tx.clone();
⋮----
let _ = tx.send(UpdateStatus::Checking);
⋮----
.timeout_global(Some(std::time::Duration::from_secs(10)))
.build();
let agent: ureq::Agent = config.into();
⋮----
.get(url)
.header("User-Agent", "screen-goated-toolbox-checker")
.call();
⋮----
let release_json: String = match resp.body_mut().read_to_string() {
⋮----
let _ = tx.send(UpdateStatus::Error(format!(
⋮----
Ok(mut releases) if !releases.is_empty() => {
let rel = releases.remove(0);
⋮----
rel.get("tag_name").and_then(|v| v.as_str()).unwrap_or("");
let version = tag_name.trim_start_matches('v').to_string();
⋮----
.get("body")
.and_then(|v| v.as_str())
.unwrap_or("")
.to_string();
let current = env!("CARGO_PKG_VERSION");
⋮----
.unwrap_or(false);
⋮----
let _ = tx.send(UpdateStatus::UpdateAvailable { version, body });
⋮----
let _ = tx.send(UpdateStatus::UpToDate(current.to_string()));
⋮----
let _ = tx.send(UpdateStatus::Error(
"No releases found on GitHub".to_string(),
⋮----
tx.send(UpdateStatus::Error(format!("JSON parse error: {}", e)));
⋮----
let err_str = e.to_string();
if err_str.contains("403") {
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later or check your network/VPN.".to_string()
⋮----
format!("Network error: {}", e)
⋮----
pub fn perform_update(&self) {
⋮----
let _ = tx.send(UpdateStatus::Downloading);
⋮----
Ok(exe_path) => match exe_path.parent() {
Some(dir) => dir.to_path_buf(),
⋮----
"Could not find exe directory".to_string(),
⋮----
let _ = tx.send(UpdateStatus::Error("Could not get exe path".to_string()));
⋮----
let temp_path = exe_dir.join("temp_download");
let mut staging_path = exe_dir.join("update_pending.exe");
⋮----
.header("User-Agent", "screen-goated-toolbox-updater")
.call()
⋮----
match response.body_mut().read_to_string() {
⋮----
let _ = tx.send(UpdateStatus::Error(format!("Failed to parse response: {}", e)));
⋮----
"Status 403: GitHub API rate limit reached or access forbidden. Please try again later.".to_string()
⋮----
format!("Failed to fetch release list: {}", e)
⋮----
let _ = tx.send(UpdateStatus::Error(error_msg));
⋮----
.get("name")
⋮----
.to_string(),
⋮----
.get("tag_name")
⋮----
.trim_start_matches('v')
⋮----
.get("published_at")
⋮----
.map(|s| s.to_string()),
⋮----
.get("assets")
.and_then(|a| a.as_array())
.unwrap_or(&vec![])
.iter()
.filter_map(|asset| {
let name = asset.get("name")?.as_str()?.to_string();
⋮----
asset.get("browser_download_url")?.as_str()?.to_string();
Some(self_update::update::ReleaseAsset { name, download_url })
⋮----
.collect(),
⋮----
let _ = tx.send(UpdateStatus::Error("No releases found".to_string()));
⋮----
.find(|a| a.name.ends_with(".exe") || a.name.ends_with(".zip"))
⋮----
"No .exe or .zip found in release assets".to_string(),
⋮----
if asset.name.ends_with(".exe") {
staging_path = exe_dir.join(&asset.name);
⋮----
match ureq::get(&asset.download_url).call() {
⋮----
let mut reader = response.into_body().into_reader();
⋮----
let _ = tx.send(UpdateStatus::Error(format!("Download failed: {}", e)));
⋮----
drop(file);
if asset.name.ends_with(".zip") {
⋮----
Ok(mut archive) => match archive.by_index(0) {
⋮----
.is_ok()
⋮----
let _ = tx.send(
⋮----
"Failed to extract zip".to_string(),
⋮----
let _ = tx.send(UpdateStatus::UpdatedAndRestartRequired);
</file>

<file path="src/api/gemini_live/manager.rs">
use std::collections::VecDeque;
use std::sync::mpsc;
⋮----
pub struct GeminiLiveManager {
⋮----
impl GeminiLiveManager {
pub fn new() -> Self {
⋮----
pub fn request(
⋮----
let id = REQUEST_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
let current_gen = self.interrupt_generation.load(Ordering::SeqCst);
⋮----
let mut queue = self.work_queue.lock().unwrap();
queue.push_back(QueuedLiveRequest {
⋮----
self.work_signal.notify_one();
⋮----
pub fn interrupt(&self) {
self.interrupt_generation.fetch_add(1, Ordering::SeqCst);
⋮----
for req in queue.drain(..) {
⋮----
.send(LiveEvent::Error("Interrupted".to_string()));
⋮----
self.work_signal.notify_all();
⋮----
pub fn is_generation_valid(&self, generation: u64) -> bool {
generation >= self.interrupt_generation.load(Ordering::SeqCst)
⋮----
pub fn shutdown(&self) {
self.shutdown.store(true, Ordering::SeqCst);
self.interrupt();
⋮----
impl Default for GeminiLiveManager {
fn default() -> Self {
</file>

<file path="src/api/realtime_audio/mod.rs">
mod capture;
pub mod model_loader;
pub mod parakeet;
mod state;
mod transcription;
mod translation;
mod utils;
pub mod websocket;
use windows::Win32::UI::WindowsAndMessaging::WM_APP;
⋮----
pub use transcription::start_realtime_transcription;
pub use translation::translate_with_google_gtx;
⋮----
pub fn cancel_download_and_revert_to_gemini() {
⋮----
use std::sync::atomic::Ordering;
crate::overlay::realtime_webview::state::REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
if let Ok(mut state) = REALTIME_STATE.lock() {
⋮----
let mut app = crate::APP.lock().unwrap();
app.config.realtime_transcription_model = "gemini".to_string();
⋮----
if let Ok(mut model) = NEW_TRANSCRIPTION_MODEL.lock() {
*model = "gemini".to_string();
⋮----
TRANSCRIPTION_MODEL_CHANGE.store(true, Ordering::SeqCst);
⋮----
let hwnd = std::ptr::addr_of!(REALTIME_HWND).read();
if !hwnd.is_invalid() {
⋮----
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(script);
⋮----
println!("Parakeet download cancelled, reverting to Gemini Live");
</file>

<file path="src/api/realtime_audio/state.rs">
pub enum TranscriptionMethod {
⋮----
impl Default for TranscriptionMethod {
fn default() -> Self {
⋮----
pub struct RealtimeState {
⋮----
impl RealtimeState {
pub fn new() -> Self {
⋮----
fn update_display_transcript(&mut self) {
self.display_transcript = self.full_transcript.clone();
⋮----
fn update_display_translation(&mut self) {
let full = if self.committed_translation.is_empty() {
self.uncommitted_translation.clone()
} else if self.uncommitted_translation.is_empty() {
self.committed_translation.clone()
⋮----
format!(
⋮----
pub fn append_transcript(&mut self, new_text: &str) {
⋮----
if self.last_committed_pos >= self.full_transcript.len() {
⋮----
let mut text_to_append = new_text.to_string();
⋮----
self.full_transcript.trim().is_empty() || self.source_ends_with_sentence();
⋮----
if let Some(first_char_idx) = text_to_append.find(|c: char| !c.is_whitespace()) {
let c = text_to_append.chars().nth(first_char_idx).unwrap();
⋮----
text_to_append = format!("{}{}{}", pre_space, c.to_uppercase(), rest);
⋮----
self.full_transcript.push_str(&text_to_append);
⋮----
self.update_display_transcript();
⋮----
pub fn set_transcription_method(&mut self, method: TranscriptionMethod) {
⋮----
fn count_uncommitted_words(&self) -> usize {
⋮----
.is_char_boundary(self.last_committed_pos)
⋮----
uncommitted.split_whitespace().count()
⋮----
fn calculate_parakeet_timeout_ms(&self) -> u64 {
let word_count = self.count_uncommitted_words();
⋮----
let segment_len = if self.last_committed_pos >= self.full_transcript.len() {
⋮----
self.full_transcript[self.last_committed_pos..].len()
⋮----
let timeout = PARAKEET_BASE_TIMEOUT_MS.saturating_sub(decay);
timeout.max(PARAKEET_MIN_TIMEOUT_MS)
⋮----
pub fn source_ends_with_sentence(&self) -> bool {
⋮----
.trim()
.chars()
.last()
.map(|c| sentence_delimiters.contains(&c))
.unwrap_or(false)
⋮----
pub fn should_force_commit_on_timeout(&self) -> bool {
⋮----
let user_timeout = self.calculate_parakeet_timeout_ms();
let user_silent = now.duration_since(self.last_transcript_append_time)
⋮----
if self.uncommitted_translation.is_empty() {
⋮----
if self.last_committed_pos < self.full_transcript.len() {
let pending_len = self.full_transcript.len() - self.last_committed_pos;
⋮----
let ai_silent = now.duration_since(self.last_translation_update_time)
⋮----
let source_ready = self.source_ends_with_sentence()
|| self.last_committed_pos < self.full_transcript.len();
⋮----
pub fn force_commit_all(&mut self) {
⋮----
if self.last_committed_pos < self.full_transcript.len()
&& !self.source_ends_with_sentence()
⋮----
self.full_transcript.push_str(". ");
⋮----
let trans_segment = self.uncommitted_translation.trim().to_string();
if !trans_segment.is_empty() {
let source_segment = if self.last_committed_pos < self.full_transcript.len() {
⋮----
.to_string()
⋮----
"[continued]".to_string()
⋮----
self.add_to_history(source_segment, trans_segment.clone());
if self.committed_translation.is_empty() {
⋮----
self.committed_translation.push(' ');
self.committed_translation.push_str(&trans_segment);
⋮----
self.last_committed_pos = self.full_transcript.len();
self.uncommitted_translation.clear();
⋮----
self.update_display_translation();
⋮----
pub fn get_translation_chunk(&self) -> Option<(String, bool, usize)> {
⋮----
if text.trim().is_empty() {
⋮----
for (i, c) in text.char_indices() {
if sentence_delimiters.contains(&c) {
split_idx = Some(i + c.len_utf8());
⋮----
let chunk = text[..idx].to_string();
Some((chunk, true, idx))
⋮----
Some((text.to_string(), false, 0))
⋮----
pub fn is_transcript_unchanged(&self) -> bool {
self.full_transcript.len() == self.last_processed_len
⋮----
pub fn update_last_processed_len(&mut self) {
self.last_processed_len = self.full_transcript.len();
⋮----
pub fn advance_committed_pos(&mut self, amount: usize) {
⋮----
if new_pos <= self.full_transcript.len() && self.full_transcript.is_char_boundary(new_pos) {
⋮----
if new_pos > self.full_transcript.len() {
⋮----
pub fn start_new_translation(&mut self) {
⋮----
pub fn commit_current_translation(&mut self) {
⋮----
pub fn append_translation(&mut self, new_text: &str) {
self.uncommitted_translation.push_str(new_text);
⋮----
pub fn add_to_history(&mut self, source: String, translation: String) {
self.translation_history.push((source, translation));
while self.translation_history.len() > 3 {
self.translation_history.remove(0);
⋮----
pub fn get_history_messages(&self, target_language: &str) -> Vec<serde_json::Value> {
⋮----
messages.push(serde_json::json!({
⋮----
pub type SharedRealtimeState = Arc<Mutex<RealtimeState>>;
</file>

<file path="src/api/realtime_audio/translation.rs">
use isolang;
use std::io::BufRead;
⋮----
use urlencoding;
⋮----
use crate::api::client::UREQ_AGENT;
use crate::config::Preset;
use crate::APP;
use super::state::SharedRealtimeState;
⋮----
pub fn run_translation_loop(
⋮----
let translation_block = match preset.blocks.get(1) {
Some(b) => b.clone(),
⋮----
.lock()
.ok()
.and_then(|lang| {
if lang.is_empty() {
⋮----
Some(lang.clone())
⋮----
from_ui.unwrap_or_else(|| {
if !translation_block.selected_language.is_empty() {
translation_block.selected_language.clone()
⋮----
.get("language")
.cloned()
.or_else(|| translation_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
⋮----
while !stop_signal.load(Ordering::Relaxed) {
if translation_hwnd.0 != 0 as _ && !unsafe { IsWindow(Some(translation_hwnd)).as_bool() } {
⋮----
if crate::overlay::realtime_webview::LANGUAGE_CHANGE.load(Ordering::SeqCst) {
if let Ok(new_lang) = crate::overlay::realtime_webview::NEW_TARGET_LANGUAGE.lock() {
if !new_lang.is_empty() {
target_language = new_lang.clone();
if let Ok(mut s) = state.lock() {
s.translation_history.clear();
⋮----
crate::overlay::realtime_webview::LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
⋮----
if crate::overlay::realtime_webview::TRANSLATION_MODEL_CHANGE.load(Ordering::SeqCst) {
⋮----
.store(false, Ordering::SeqCst);
⋮----
let should_force = { state.lock().unwrap().should_force_commit_on_timeout() };
⋮----
s.force_commit_all();
let display = s.display_translation.clone();
update_translation_text(translation_hwnd, &display);
refresh_transcription_window();
⋮----
if last_run.elapsed() >= interval {
if !crate::overlay::realtime_webview::TRANS_VISIBLE.load(Ordering::SeqCst) {
⋮----
let s = state.lock().unwrap();
if s.is_transcript_unchanged() {
⋮----
match s.get_translation_chunk() {
Some((text, has_finished, len)) => (Some(text), has_finished, len, false),
⋮----
let mut s = state.lock().unwrap();
s.update_last_processed_len();
s.start_new_translation();
⋮----
let app = APP.lock().unwrap();
let groq = app.config.api_key.clone();
let gemini = app.config.gemini_api_key.clone();
let cerebras = app.config.cerebras_api_key.clone();
let model = app.config.realtime_translation_model.clone();
drop(app);
let history = if let Ok(s) = state.lock() {
s.get_history_messages(&target_language)
⋮----
let current_model = translation_model.as_str();
⋮----
if let Some(text) = translate_with_google_gtx(&chunk, &target_language) {
⋮----
s.append_translation(&text);
⋮----
s.commit_current_translation();
s.advance_committed_pos(bytes_to_commit);
⋮----
("https://generativelanguage.googleapis.com/v1beta/openai/chat/completions".to_string(), "gemma-3-27b-it".to_string(), gemini_key.clone())
⋮----
"https://api.cerebras.ai/v1/chat/completions".to_string(),
"gpt-oss-120b".to_string(),
cerebras_key.clone(),
⋮----
let system_instruction = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
⋮----
messages.extend(history_messages.clone());
messages.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", system_instruction, target_language, chunk)}));
⋮----
messages.push(
⋮----
messages.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
⋮----
if !api_key.is_empty() {
⋮----
.post(&url)
.header("Authorization", &format!("Bearer {}", api_key))
.header("Content-Type", "application/json")
.send_json(payload)
⋮----
.headers()
.get("x-ratelimit-remaining-requests-tokens")
.and_then(|v| v.to_str().ok())
⋮----
.get("x-ratelimit-limit-tokens")
⋮----
.unwrap_or("?");
if let Ok(mut app) = APP.lock() {
app.model_usage_stats.insert(
⋮----
format!("{} / {}", remaining, limit),
⋮----
std::io::BufReader::new(resp.into_body().into_reader());
⋮----
for line in reader.lines().flatten() {
if stop_signal.load(Ordering::Relaxed) {
⋮----
if line.starts_with("data: ") {
let json_str = &line["data: ".len()..];
if json_str.trim() == "[DONE]" {
⋮----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|a| a.first())
.and_then(|f| f.get("delta"))
.and_then(|d| d.get("content"))
.and_then(|t| t.as_str())
⋮----
full_translation.push_str(content);
⋮----
s.append_translation(content);
⋮----
update_translation_text(
⋮----
if !full_translation.is_empty() {
⋮----
handle_fallback_translation(
⋮----
fn handle_fallback_translation(
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_nanos();
pool[(nanos as usize) % pool.len()]
⋮----
let mut app = APP.lock().unwrap();
app.config.realtime_translation_model = alt_model.to_string();
⋮----
let _ = PostMessageW(
Some(translation_hwnd),
⋮----
WPARAM(flag),
LPARAM(0),
⋮----
if let Some(text) = translate_with_google_gtx(chunk, target_language) {
⋮----
.to_string(),
"gemma-3-27b-it".to_string(),
gemini_key.to_string(),
⋮----
cerebras_key.to_string(),
⋮----
if !alt_key.is_empty() {
⋮----
let alt_sys = format!("You are a professional translator. Translate text to {} to append suitably to the context. Output ONLY the translation, nothing else.", target_language);
⋮----
alt_msgs.extend(history_messages.iter().cloned());
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("{}\n\nTranslate to {}:\n{}", alt_sys, target_language, chunk)}));
⋮----
alt_msgs.push(serde_json::json!({"role": "system", "content": alt_sys}));
⋮----
alt_msgs.push(serde_json::json!({"role": "user", "content": format!("Translate to {}:\n{}", target_language, chunk)}));
⋮----
.post(&alt_url)
.header("Authorization", &format!("Bearer {}", alt_key))
⋮----
let reader = std::io::BufReader::new(resp.into_body().into_reader());
⋮----
.and_then(|a| a.as_array())
.and_then(|v| v.first())
⋮----
.and_then(|s| s.as_str())
⋮----
full_t.push_str(txt);
⋮----
s.append_translation(txt);
let d = s.display_translation.clone();
update_translation_text(translation_hwnd, &d);
⋮----
if !full_t.is_empty() {
⋮----
pub fn translate_with_google_gtx(text: &str, target_lang: &str) -> Option<String> {
⋮----
.and_then(|lang| lang.to_639_1())
.map(|code| code.to_string())
.unwrap_or_else(|| "en".to_string());
⋮----
let url = format!(
⋮----
.get(&url)
.header("User-Agent", "Mozilla/5.0")
.call()
⋮----
if let Ok(json) = resp.into_body().read_json::<serde_json::Value>() {
if let Some(sentences) = json.get(0).and_then(|v| v.as_array()) {
⋮----
if let Some(segment) = sentence_node.get(0).and_then(|s| s.as_str()) {
full_text.push_str(segment);
⋮----
if !full_text.is_empty() {
return Some(full_text);
</file>

<file path="src/config/config.rs">
fn default_true() -> bool {
⋮----
fn default_history_limit() -> usize {
⋮----
fn default_graphics_mode() -> String {
"standard".to_string()
⋮----
fn default_tts_voice() -> String {
"Aoede".to_string()
⋮----
fn default_tts_speed() -> String {
"Fast".to_string()
⋮----
fn default_tts_method() -> TtsMethod {
⋮----
fn default_edge_tts_settings() -> EdgeTtsSettings {
⋮----
fn default_realtime_translation_model() -> String {
"cerebras-oss".to_string()
⋮----
fn default_realtime_font_size() -> u32 {
⋮----
fn default_realtime_window_size() -> (i32, i32) {
⋮----
fn default_realtime_transcription_model() -> String {
"gemini".to_string()
⋮----
fn default_realtime_target_language() -> String {
"Vietnamese".to_string()
⋮----
fn default_ollama_base_url() -> String {
"http://localhost:11434".to_string()
⋮----
pub struct Config {
⋮----
impl Default for Config {
fn default() -> Self {
⋮----
presets: get_default_presets(),
⋮----
ui_language: get_system_ui_language(),
⋮----
graphics_mode: "standard".to_string(),
⋮----
ollama_base_url: "http://localhost:11434".to_string(),
⋮----
realtime_translation_model: "cerebras-oss".to_string(),
realtime_transcription_model: "gemini".to_string(),
⋮----
realtime_audio_source: "device".to_string(),
realtime_target_language: "Vietnamese".to_string(),
⋮----
tts_voice: "Aoede".to_string(),
tts_speed: "Fast".to_string(),
⋮----
tts_language_conditions: default_tts_language_conditions(),
⋮----
fn default_bubble_size() -> u32 {
</file>

<file path="src/config/preset/block.rs">
use std::collections::HashMap;
use crate::config::types::BlockType;
⋮----
pub struct ProcessingBlock {
⋮----
fn generate_block_id() -> String {
format!(
⋮----
fn default_true() -> bool {
⋮----
fn default_render_mode() -> String {
"markdown_stream".to_string()
⋮----
impl Default for ProcessingBlock {
fn default() -> Self {
⋮----
id: generate_block_id(),
block_type: "text".to_string(),
model: "text_accurate_kimi".to_string(),
prompt: "Translate to {language1}. Output ONLY the translation.".to_string(),
selected_language: "Vietnamese".to_string(),
⋮----
render_mode: "markdown_stream".to_string(),
⋮----
pub struct BlockBuilder {
⋮----
impl BlockBuilder {
pub fn text(model: &str) -> Self {
⋮----
model: model.to_string(),
⋮----
pub fn image(model: &str) -> Self {
⋮----
block_type: "image".to_string(),
⋮----
pub fn audio(model: &str) -> Self {
⋮----
block_type: "audio".to_string(),
⋮----
pub fn input_adapter() -> Self {
⋮----
block_type: "input_adapter".to_string(),
⋮----
pub fn prompt(mut self, prompt: &str) -> Self {
self.block.prompt = prompt.to_string();
⋮----
pub fn language(mut self, lang: &str) -> Self {
self.block.selected_language = lang.to_string();
⋮----
.insert("language1".to_string(), lang.to_string());
⋮----
pub fn streaming(mut self, enabled: bool) -> Self {
⋮----
pub fn markdown(mut self) -> Self {
self.block.render_mode = "markdown".to_string();
⋮----
pub fn markdown_stream(mut self) -> Self {
self.block.render_mode = "markdown_stream".to_string();
⋮----
pub fn show_overlay(mut self, show: bool) -> Self {
⋮----
pub fn auto_copy(mut self) -> Self {
⋮----
pub fn auto_speak(mut self) -> Self {
⋮----
pub fn build(self) -> ProcessingBlock {
⋮----
impl ProcessingBlock {
pub fn is_input_adapter(&self) -> bool {
⋮----
pub fn is_image(&self) -> bool {
⋮----
pub fn is_text(&self) -> bool {
⋮----
pub fn is_audio(&self) -> bool {
⋮----
pub fn block_type_enum(&self) -> BlockType {
</file>

<file path="src/config/preset/defaults/image.rs">
use crate::config::preset::Preset;
use crate::config::types::Hotkey;
pub fn create_image_presets() -> Vec<Preset> {
vec![
⋮----
.prompt("") // QR scanner doesn't need a prompt
⋮----
// Node 1: Format the QR content nicely
</file>

<file path="src/gui/settings_ui/download_manager/utils.rs">
use super::types::InstallStatus;
use std::fs;
⋮----
use std::path::PathBuf;
⋮----
pub fn log(logs: &Arc<Mutex<Vec<String>>>, msg: impl Into<String>) {
logs.lock().unwrap().push(msg.into());
⋮----
pub fn download_file(
⋮----
let resp = ureq::get(url).call().map_err(|e| e.to_string())?;
⋮----
.headers()
.get("Content-Length")
.and_then(|v| v.to_str().ok())
.and_then(|s| s.parse::<u64>().ok())
.unwrap_or(0);
let temp_path = path.with_extension("tmp");
let mut reader = resp.into_body().into_reader();
let mut file = fs::File::create(&temp_path).map_err(|e| e.to_string())?;
⋮----
if cancel.load(Ordering::Relaxed) {
drop(file);
⋮----
return Err("Cancelled".to_string());
⋮----
let bytes_read = reader.read(&mut buffer).map_err(|e| e.to_string())?;
⋮----
file.write_all(&buffer[..bytes_read])
.map_err(|e| e.to_string())?;
⋮----
*status.lock().unwrap() = InstallStatus::Downloading(progress);
⋮----
fs::rename(&temp_path, path).map_err(|e| {
⋮----
format!("Failed to rename temp file: {}", e)
⋮----
Ok(())
⋮----
pub fn extract_ffmpeg(zip_path: &PathBuf, bin_dir: &PathBuf) -> Result<(), String> {
let file = fs::File::open(zip_path).map_err(|e| e.to_string())?;
let mut archive = zip::ZipArchive::new(file).map_err(|e| e.to_string())?;
for i in 0..archive.len() {
let mut file = archive.by_index(i).map_err(|e| e.to_string())?;
let name = file.name();
if name.ends_with("ffmpeg.exe") {
⋮----
fs::File::create(bin_dir.join("ffmpeg.exe")).map_err(|e| e.to_string())?;
io::copy(&mut file, &mut out_file).map_err(|e| e.to_string())?;
return Ok(());
⋮----
Err("ffmpeg.exe not found in archive".to_string())
⋮----
use super::types::CookieBrowser;
⋮----
use std::os::windows::process::CommandExt;
use std::process::Command;
pub fn fetch_video_formats(
⋮----
let ytdlp_path = bin_dir.join("yt-dlp.exe");
if !ytdlp_path.exists() {
return Err("yt-dlp is missing".to_string());
⋮----
let mut args = vec!["--dump-json".to_string(), "--no-playlist".to_string()];
⋮----
args.push("--cookies-from-browser".to_string());
args.push("chrome".to_string());
⋮----
args.push("firefox".to_string());
⋮----
args.push("edge".to_string());
⋮----
args.push("brave".to_string());
⋮----
args.push("opera".to_string());
⋮----
args.push("vivaldi".to_string());
⋮----
args.push("chromium".to_string());
⋮----
args.push("whale".to_string());
⋮----
args.push(url.to_string());
⋮----
cmd.args(&args);
⋮----
cmd.creation_flags(0x08000000);
let output = cmd.output().map_err(|e| e.to_string())?;
if !output.status.success() {
return Err("Failed to fetch info".to_string());
⋮----
for (i, _) in json_str.match_indices(key) {
let after_key = &json_str[i + key.len()..];
let num_start_idx = after_key.find(|c: char| !c.is_whitespace()).unwrap_or(0);
⋮----
.find(|c: char| !c.is_ascii_digit())
.unwrap_or(after_ws.len());
⋮----
heights.insert(h);
⋮----
if heights.is_empty() {
if json_str.len() < 50 {
return Err(format!("No formats found. Output: {}", json_str));
⋮----
return Err("No video resolutions found in metadata.".to_string());
⋮----
let mut sorted_heights: Vec<u32> = heights.into_iter().collect();
sorted_heights.sort_unstable_by(|a, b| b.cmp(a));
⋮----
result.push(format!("{}p", h));
⋮----
Ok(result)
</file>

<file path="src/gui/settings_ui/global/update_section.rs">
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
⋮----
use std::os::windows::process::CommandExt;
pub fn render_update_section_content(
⋮----
ui.horizontal(|ui| {
let ver_string = format!(
⋮----
ui.label(ver_string);
if ui.button(text.check_for_updates_btn).clicked() {
⋮----
u.check_for_updates();
⋮----
ui.spinner();
ui.label(text.checking_github);
⋮----
ui.label(
egui::RichText::new(format!("{} (v{})", text.up_to_date, ver))
.color(egui::Color32::from_rgb(34, 139, 34)),
⋮----
if ui.button(text.check_again_btn).clicked() {
⋮----
ui.colored_label(
⋮----
format!("{} {}", text.new_version_available, version),
⋮----
ui.collapsing(text.release_notes_label, |ui| {
ui.label(body);
⋮----
ui.add_space(5.0);
⋮----
.button(egui::RichText::new(text.download_update_btn).strong())
.clicked()
⋮----
u.perform_update();
⋮----
ui.label(text.downloading_update);
⋮----
ui.colored_label(egui::Color32::RED, format!("{} {}", text.update_failed, e));
ui.label(egui::RichText::new(text.app_folder_writable_hint).size(11.0));
if ui.button(text.retry_btn).clicked() {
⋮----
.color(egui::Color32::GREEN)
.heading(),
⋮----
ui.label(text.restart_to_use_new_version);
if ui.button(text.restart_app_btn).clicked() {
⋮----
if let Some(exe_dir) = exe_path.parent() {
⋮----
.filter_map(|e| e.ok())
.filter(|e| {
let name = e.file_name();
let name_str = name.to_string_lossy();
name_str.starts_with("ScreenGoatedToolbox_v")
&& name_str.ends_with(".exe")
⋮----
.max_by_key(|e| e.metadata().ok().and_then(|m| m.modified().ok()))
⋮----
let path = newest_exe.path();
println!("Attempting to spawn with delay: {:?}", path);
let kill_mutex_cmd = format!("timeout /t 2 /nobreak > NUL");
⋮----
format!("start \"\" \"{}\"", path.to_string_lossy());
⋮----
let batch_content = format!(
⋮----
.join(format!("sgt_restart_{}.bat", std::process::id()));
println!("Writing batch file to: {:?}", bat_path);
⋮----
cmd.args(["/C", &bat_path.to_string_lossy()]);
⋮----
cmd.creation_flags(0x08000000);
let status = cmd.spawn();
⋮----
eprintln!("Failed to spawn batch file: {}", e);
⋮----
eprintln!("Failed to write batch file");
</file>

<file path="src/gui/settings_ui/node_graph/body.rs">
use super::node::ChainNode;
⋮----
use super::viewer::ChainViewer;
⋮----
use eframe::egui;
⋮----
pub fn show_body(
⋮----
.get_node(node_id)
.map(|n| n.id().to_string())
.unwrap_or_default();
⋮----
let node = snarl.get_node_mut(node_id).unwrap();
ui.vertical(|ui| {
ui.set_max_width(320.0);
⋮----
ui.set_min_width(173.0);
⋮----
viewer.preset_type.as_str()
⋮----
block_type.as_str()
⋮----
ui.horizontal(|ui| {
⋮----
if icon_button(ui, icon).clicked() {
⋮----
"plain".to_string()
⋮----
"markdown".to_string()
⋮----
*render_mode = "markdown".to_string();
⋮----
match viewer.ui_language.as_str() {
⋮----
*render_mode = "plain".to_string();
⋮----
let popup_id = ui.make_persistent_id(format!(
⋮----
let btn_bg = if ui.visuals().dark_mode {
⋮----
let btn = ui.add(
⋮----
.fill(btn_bg)
.corner_radius(4.0),
⋮----
if btn.clicked() {
ui.memory_mut(|mem| mem.toggle_popup(popup_id));
⋮----
ui.set_min_width(60.0);
let (lbl_norm, lbl_md) = match viewer.ui_language.as_str() {
⋮----
.selectable_label(render_mode == "plain", lbl_norm)
.clicked()
⋮----
ui.memory_mut(|mem| mem.close_popup(popup_id));
⋮----
.selectable_label(render_mode == "markdown", lbl_md)
⋮----
let _ = icon_button(ui, Icon::Copy)
.on_hover_text(viewer.text.input_auto_copy_tooltip);
⋮----
if icon_button(ui, copy_icon)
.on_hover_text(viewer.text.input_auto_copy_tooltip)
⋮----
if icon_button(ui, speak_icon)
.on_hover_text(viewer.text.input_auto_speak_tooltip)
⋮----
let target_model_type = match viewer.preset_type.as_str() {
⋮----
let model_label = match viewer.ui_language.as_str() {
⋮----
ui.label(model_label);
let model_def = get_model_by_id(model);
⋮----
.as_ref()
.map(|m| match viewer.ui_language.as_str() {
"vi" => m.name_vi.as_str(),
"ko" => m.name_ko.as_str(),
_ => m.name_en.as_str(),
⋮----
.unwrap_or(model.as_str());
let button_response = ui.button(display_name);
if button_response.clicked() {
egui::Popup::toggle_id(ui.ctx(), button_response.id);
⋮----
trigger_ollama_model_scan();
⋮----
egui::Popup::from_toggle_button_response(&button_response).show(|ui| {
ui.style_mut().wrap_mode = Some(egui::TextWrapMode::Extend);
if viewer.use_ollama && is_ollama_scan_in_progress() {
let loading_text = match viewer.ui_language.as_str() {
⋮----
ui.label(egui::RichText::new(loading_text).weak().italics());
ui.separator();
⋮----
for m in get_all_models_with_ollama() {
⋮----
&& viewer.is_provider_enabled(&m.provider)
⋮----
let name = match viewer.ui_language.as_str() {
⋮----
let quota = match viewer.ui_language.as_str() {
⋮----
let provider_icon = match m.provider.as_str() {
⋮----
let search_suffix = if model_supports_search(&m.id) {
⋮----
let label = format!(
⋮----
if ui.selectable_label(is_selected, label).clicked() {
*model = m.id.clone();
⋮----
egui::Popup::toggle_id(ui.ctx(), popup_layer_id);
⋮----
// Only show prompt UI for LLM models (not QR scanner, GTX, Whisper, etc.)
if !model_is_non_llm(model) {
// Row 2: Prompt Label + Add Tag Button
⋮----
let prompt_label = match viewer.ui_language.as_str() {
⋮----
ui.label(prompt_label);
let btn_label = match viewer.ui_language.as_str() {
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
.add(
⋮----
.small()
.color(egui::Color32::WHITE),
⋮----
.fill(lang_btn_bg)
.corner_radius(8.0),
⋮----
insert_next_language_tag(prompt, language_vars);
⋮----
.desired_width(152.0)
.desired_rows(2),
⋮----
.changed()
⋮----
show_language_vars(
⋮----
match (render_mode.as_str(), *streaming_enabled) {
("markdown_stream", _) => match viewer.ui_language.as_str()
⋮----
("markdown", _) => match viewer.ui_language.as_str() {
⋮----
(_, true) => match viewer.ui_language.as_str() {
⋮----
(_, false) => match viewer.ui_language.as_str() {
⋮----
.make_persistent_id(format!("render_mode_popup_{:?}", node_id));
⋮----
ui.set_min_width(80.0);
⋮----
.as_str()
⋮----
.selectable_label(
⋮----
*render_mode = "stream".to_string();
⋮----
*render_mode = "markdown_stream".to_string();
⋮----
// Only show prompt UI for LLM models (not GTX, etc.)
⋮----
for node in snarl.nodes_mut() {
if node.id() != current_node_uuid {
node.set_auto_copy(false);
</file>

<file path="src/overlay/favorite_bubble/html.rs">
use crate::config::Preset;
use crate::gui::settings_ui::get_localized_preset_name;
pub fn generate_panel_html(
⋮----
let css = generate_panel_css(is_dark);
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
⋮----
format!(
⋮----
pub fn generate_panel_css(is_dark: bool) -> String {
⋮----
// Theme-specific colors
⋮----
pub fn get_favorite_presets_html(presets: &[Preset], lang: &str, is_dark: bool) -> String {
⋮----
for (idx, preset) in presets.iter().enumerate() {
⋮----
let name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
⋮----
preset.name.clone()
⋮----
let (icon_svg, color_hex) = match preset.preset_type.as_str() {
⋮----
let item = format!(
⋮----
html_items.push_str(&item);
⋮----
if html_items.is_empty() {
⋮----
html_items = format!(
⋮----
fn html_escape(s: &str) -> String {
s.replace('&', "&amp;")
.replace('<', "&lt;")
.replace('>', "&gt;")
.replace('"', "&quot;")
⋮----
pub fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n")
.replace('\r', "")
</file>

<file path="src/overlay/html_components/font_manager.rs">
use std::collections::HashMap;
⋮----
use std::net::TcpListener;
⋮----
use windows::Win32::Graphics::Gdi::AddFontMemResourceEx;
use wry::WebViewBuilder;
⋮----
pub fn warmup_fonts() {
load_gdi_font();
start_server();
⋮----
fn load_gdi_font() {
⋮----
let len = GOOGLE_SANS_FLEX_TTF.len() as u32;
let handle = AddFontMemResourceEx(
GOOGLE_SANS_FLEX_TTF.as_ptr() as *mut _,
⋮----
if handle.is_invalid() {
eprintln!("Failed to load Google Sans Flex into GDI");
⋮----
fn start_server() {
START_SERVER_ONCE.call_once(|| {
⋮----
eprintln!("Failed to bind font server: {}", e);
⋮----
let port = listener.local_addr().map(|a| a.port()).unwrap_or(0);
let url = format!("http://127.0.0.1:{}", port);
if let Ok(mut guard) = SERVER_URL.lock() {
*guard = Some(url);
⋮----
for stream in listener.incoming() {
⋮----
let _ = handle_request(&mut stream);
⋮----
fn handle_request(stream: &mut std::net::TcpStream) -> std::io::Result<()> {
⋮----
let n = stream.read(&mut buffer)?;
⋮----
let first_line = request.lines().next().unwrap_or("");
let parts: Vec<&str> = first_line.split_whitespace().collect();
let method = parts.get(0).copied().unwrap_or("GET");
let path = parts.get(1).copied().unwrap_or("/");
⋮----
format!("HTTP/1.1 204 No Content\r\n{cors_headers}Connection: close\r\n\r\n");
stream.write_all(response.as_bytes())?;
return Ok(());
⋮----
let path_without_query = path.split('?').next().unwrap_or(path);
⋮----
let headers = format!(
⋮----
stream.write_all(headers.as_bytes())?;
⋮----
stream.write_all(GOOGLE_SANS_FLEX_TTF)?;
⋮----
} else if path.starts_with("/page/") {
let id_str = path.strip_prefix("/page/").unwrap_or("0");
let page_id: u64 = id_str.parse().unwrap_or(0);
⋮----
.lock()
.ok()
.and_then(|mut map| map.remove(&page_id))
.unwrap_or_else(|| "<html><body>Page not found</body></html>".to_string());
let html_bytes = html.as_bytes();
⋮----
stream.write_all(html_bytes)?;
⋮----
stream.write_all(body)?;
⋮----
Ok(())
⋮----
fn get_server_url() -> Option<String> {
⋮----
if let Ok(guard) = SERVER_URL.lock() {
if let Some(url) = guard.as_ref() {
return Some(url.clone());
⋮----
pub fn store_html_page(html: String) -> Option<String> {
let base_url = get_server_url()?;
let page_id = PAGE_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
if let Ok(mut map) = PENDING_PAGES.lock() {
map.insert(page_id, html);
⋮----
Some(format!("{}/page/{}", base_url, page_id))
⋮----
pub fn configure_webview(builder: WebViewBuilder) -> WebViewBuilder {
⋮----
pub fn get_font_css() -> String {
let base_url = get_server_url().unwrap_or_else(|| "http://127.0.0.1:0".to_string());
let cache_buster = SESSION_CACHE_BUSTER.as_str();
format!(
</file>

<file path="src/overlay/result/event_handler/timer_tasks.rs">
use super::super::logic;
use crate::overlay::result::markdown_view;
use crate::overlay::result::state::WINDOW_STATES;
use crate::overlay::utils::to_wstring;
⋮----
use windows::core::PCWSTR;
⋮----
use windows::Win32::Graphics::Gdi::InvalidateRect;
⋮----
pub unsafe fn handle_timer(hwnd: HWND, wparam: WPARAM) -> LRESULT {
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
let _ = GetWindowRect(hwnd, &mut window_rect);
⋮----
let states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&(hwnd.0 as isize)) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
⋮----
return LRESULT(0);
⋮----
.duration_since(UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
⋮----
if state.pending_text.is_some()
⋮----
|| now.wrapping_sub(state.last_text_update_time) > 16)
⋮----
pending_update = state.pending_text.take();
⋮----
let time_since_last_calc = now.wrapping_sub(state.last_font_calc_time);
⋮----
state.full_text = txt.clone();
⋮----
Some(state.full_text.clone()),
⋮----
now.wrapping_sub(state.last_webview_update_time);
⋮----
let wide_text = to_wstring(&txt);
let _ = SetWindowTextW(hwnd, PCWSTR(wide_text.as_ptr()));
⋮----
LRESULT(0)
</file>

<file path="src/overlay/text_selection_webview/mod.rs">
use crate::APP;
⋮----
mod html;
use crate::overlay::realtime_webview::state::HwndWrapper;
struct TextSelectionState {
⋮----
unsafe impl Send for TextSelectionState {}
⋮----
hwnd: HWND(std::ptr::null_mut()),
⋮----
hook_handle: HHOOK(std::ptr::null_mut()),
⋮----
pub fn is_active() -> bool {
!SELECTION_STATE.lock().unwrap().hwnd.is_invalid()
⋮----
pub fn cancel_selection() {
TAG_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = SELECTION_STATE.lock().unwrap().hwnd;
⋮----
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
pub fn try_instant_process(preset_idx: usize) -> bool {
⋮----
let original_clipboard = get_clipboard_text();
if OpenClipboard(Some(HWND::default())).is_ok() {
let _ = EmptyClipboard();
let _ = CloseClipboard();
⋮----
wVk: VIRTUAL_KEY(vk),
⋮----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
⋮----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYEVENTF_KEYUP);
⋮----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
⋮----
clipboard_text = get_clipboard_text();
if !clipboard_text.is_empty() {
⋮----
if clipboard_text.trim().is_empty() {
if !original_clipboard.is_empty() {
⋮----
process_selected_text(preset_idx, clipboard_text);
⋮----
unsafe fn get_clipboard_text() -> String {
⋮----
if let Ok(h_data) = GetClipboardData(13u32) {
⋮----
let ptr = GlobalLock(h_global);
if !ptr.is_null() {
let size = GlobalSize(h_global);
⋮----
if let Some(end) = wide_slice.iter().position(|&c| c == 0) {
⋮----
let _ = GlobalUnlock(h_global);
⋮----
fn process_selected_text(preset_idx: usize, clipboard_text: String) {
⋮----
let app = APP.lock().unwrap();
⋮----
(p.is_master, p.text_input_mode.clone())
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
crate::overlay::preset_wheel::show_preset_wheel("text", Some("select"), cursor_pos);
⋮----
let mut app = APP.lock().unwrap();
⋮----
app.config.clone(),
app.config.presets[final_preset_idx].clone(),
GetSystemMetrics(SM_CXSCREEN),
GetSystemMetrics(SM_CYSCREEN),
⋮----
preset.text_input_mode = "select".to_string();
⋮----
.first()
.map(|h| h.name.clone())
.unwrap_or_default();
⋮----
unsafe extern "system" fn keyboard_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
pub fn show_text_selection_tag(preset_idx: usize) {
⋮----
let mut state = SELECTION_STATE.lock().unwrap();
if !state.hwnd.is_invalid() {
drop(state);
cancel_selection();
⋮----
TAG_ABORT_SIGNAL.store(false, Ordering::SeqCst);
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextTag_Web");
REGISTER_TAG_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(tag_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassExW(&wc);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT Tag Web"),
⋮----
Some(instance.into()),
⋮----
SELECTION_STATE.lock().unwrap().hwnd = hwnd;
⋮----
let hook = SetWindowsHookExW(
⋮----
Some(keyboard_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
SELECTION_STATE.lock().unwrap().hook_handle = h;
⋮----
(is_dark, app.config.ui_language.clone())
⋮----
let initial_text = match lang.as_str() {
⋮----
let page_url = format!("data:text/html,{}", urlencoding::encode(&html));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
.with_bounds(wry::Rect {
⋮----
.with_url(&page_url)
.with_transparent(true)
.build_as_child(&HwndWrapper(hwnd));
⋮----
SELECTION_STATE.lock().unwrap().webview = Some(webview);
⋮----
eprintln!("Failed to create TextSelection WebView");
⋮----
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).into() {
⋮----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
if TAG_ABORT_SIGNAL.load(Ordering::SeqCst) {
cleaned_exit(hwnd);
⋮----
let _ = GetCursorPos(&mut pt);
⋮----
let _ = MoveWindow(hwnd, target_x, target_y, 200, 100, false);
let lbutton_down = (GetAsyncKeyState(VK_LBUTTON.0 as i32) as u16 & 0x8000) != 0;
⋮----
match lang.as_str() {
⋮----
Some(format!(
⋮----
if let Some(webview) = SELECTION_STATE.lock().unwrap().webview.as_ref() {
let _ = webview.evaluate_script(&js);
⋮----
let hwnd = HWND(hwnd_val as *mut _);
if TAG_ABORT_SIGNAL.load(Ordering::Relaxed) {
⋮----
let hwnd_target = HWND(hwnd.0);
if !clipboard_text.trim().is_empty()
&& !TAG_ABORT_SIGNAL.load(Ordering::Relaxed)
⋮----
process_selected_text(preset_idx_for_thread, clipboard_text);
let _ = PostMessageW(Some(hwnd_target), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
unsafe fn cleaned_exit(hwnd: HWND) {
⋮----
if !state.hook_handle.is_invalid() {
let _ = UnhookWindowsHookEx(state.hook_handle);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
unsafe extern "system" fn tag_wnd_proc(
⋮----
LRESULT(0)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
eprintln!("Panic in tag_wnd_proc");
</file>

<file path="src/config/preset/defaults/text.rs">
use crate::config::preset::Preset;
⋮----
pub fn create_text_presets() -> Vec<Preset> {
vec![
</file>

<file path="src/gui/settings_ui/download_manager/mod.rs">
pub mod detection;
pub mod persistence;
pub mod run;
pub mod types;
pub mod ui;
pub mod utils;
⋮----
use std::path::PathBuf;
use std::sync::atomic::AtomicBool;
⋮----
pub struct DownloadManager {
⋮----
impl DownloadManager {
pub fn new() -> Self {
⋮----
.unwrap_or(PathBuf::from("."))
.join("screen-goated-toolbox")
.join("bin");
⋮----
let config_exists = persistence::get_config_path().exists();
⋮----
config.cookie_browser.clone()
⋮----
bin_dir: bin_dir.clone(),
⋮----
manager.check_status();
⋮----
pub fn save_settings(&self) {
⋮----
custom_download_path: self.custom_download_path.clone(),
⋮----
cookie_browser: self.cookie_browser.clone(),
download_type: self.download_type.clone(),
</file>

<file path="src/gui/settings_ui/download_manager/types.rs">
use std::path::PathBuf;
⋮----
pub enum InstallStatus {
⋮----
pub enum DownloadState {
⋮----
pub enum UpdateStatus {
⋮----
pub enum DownloadType {
⋮----
pub enum CookieBrowser {
⋮----
impl CookieBrowser {
pub fn to_string(&self) -> String {
⋮----
CookieBrowser::None => "None".to_string(),
CookieBrowser::Chrome => "Chrome".to_string(),
CookieBrowser::Firefox => "Firefox".to_string(),
CookieBrowser::Edge => "Edge".to_string(),
CookieBrowser::Brave => "Brave".to_string(),
CookieBrowser::Opera => "Opera".to_string(),
CookieBrowser::Vivaldi => "Vivaldi".to_string(),
CookieBrowser::Chromium => "Chromium".to_string(),
CookieBrowser::Whale => "Whale".to_string(),
</file>

<file path="src/gui/settings_ui/download_manager/ui.rs">
use crate::gui::locale::LocaleText;
use eframe::egui;
use std::path::PathBuf;
use super::DownloadManager;
impl DownloadManager {
pub fn render(&mut self, ctx: &egui::Context, text: &LocaleText) {
⋮----
.open(&mut open)
.collapsible(false)
.resizable(false)
.default_width(400.0)
.pivot(egui::Align2::CENTER_CENTER)
.default_pos(ctx.input(|i| i.viewport_rect()).center())
.show(ctx, |ui| {
let ffmpeg_ok = matches!(
⋮----
matches!(*self.ytdlp_status.lock().unwrap(), InstallStatus::Installed);
⋮----
ui.label(text.download_deps_missing);
ui.group(|ui| {
ui.horizontal(|ui| {
ui.label(text.download_deps_ytdlp);
let status = self.ytdlp_status.lock().unwrap().clone();
⋮----
ui.spinner();
⋮----
if ui.button(text.download_deps_download_btn).clicked() {
self.start_download_ytdlp();
⋮----
ui.colored_label(egui::Color32::RED, e);
⋮----
ui.label(format!("{:.0}%", p * 100.0));
ui.add(egui::ProgressBar::new(p).desired_width(120.0));
if ui.button(text.download_cancel_btn).clicked() {
self.cancel_download();
⋮----
ui.label(text.download_status_extracting);
⋮----
ui.label(text.download_status_ready);
⋮----
ui.label(text.download_deps_ffmpeg);
let status = self.ffmpeg_status.lock().unwrap().clone();
⋮----
self.start_download_ffmpeg();
⋮----
egui::Frame::default().inner_margin(8.0).show(ui, |ui| {
⋮----
ui.label(egui::RichText::new("📂").size(14.0));
⋮----
self.custom_download_path.clone().unwrap_or_else(|| {
dirs::download_dir().unwrap_or(PathBuf::from("."))
⋮----
.file_name()
.and_then(|n| n.to_str())
.unwrap_or("...");
ui.label(
egui::RichText::new(format!("...\\{}", path_str))
.strong()
.color(ctx.style().visuals.weak_text_color()),
⋮----
ui.with_layout(
⋮----
ui.menu_button("⚙", |ui| {
if ui.button(text.download_change_folder_btn).clicked() {
self.change_download_folder();
ui.close();
⋮----
ui.separator();
let (ytdlp_size, ffmpeg_size) = self.get_dependency_sizes();
⋮----
.replacen("{}", &ytdlp_size, 1)
.replacen("{}", &ffmpeg_size, 1);
⋮----
.button(
⋮----
.color(egui::Color32::RED),
⋮----
.clicked()
⋮----
self.delete_dependencies();
⋮----
ui.add_space(8.0);
ui.label(egui::RichText::new(text.download_url_label).strong());
let response = ui.add(
⋮----
.hint_text("https://youtube.com/watch?v=...")
.desired_width(f32::INFINITY),
⋮----
response.request_focus();
⋮----
if response.changed() {
self.last_input_change = ctx.input(|i| i.time);
self.available_formats.lock().unwrap().clear();
⋮----
let time_since_edit = ctx.input(|i| i.time) - self.last_input_change;
let is_analyzing = *self.is_analyzing.lock().unwrap();
let url_changed = self.input_url.trim() != self.last_url_analyzed;
⋮----
&& !self.input_url.trim().is_empty()
⋮----
self.start_analysis();
⋮----
ui.label(egui::RichText::new(text.download_format_label).strong());
⋮----
.radio_value(&mut self.download_type, DownloadType::Video, "Video")
.changed()
⋮----
self.save_settings();
⋮----
.radio_value(&mut self.download_type, DownloadType::Audio, "Audio")
⋮----
ui.add_space(10.0);
⋮----
let formats = self.available_formats.lock().unwrap().clone();
let error = self.analysis_error.lock().unwrap().clone();
⋮----
.italics()
.size(11.0),
⋮----
} else if !formats.is_empty() {
ui.label(text.download_quality_label_text);
let best_text = text.download_quality_best.to_string();
⋮----
.clone()
.unwrap_or_else(|| best_text.clone());
⋮----
.selected_text(&current_val)
.width(100.0)
.show_ui(ui, |ui| {
ui.selectable_value(
⋮----
Some(fmt.clone()),
⋮----
ui.colored_label(egui::Color32::RED, "❌");
⋮----
ui.collapsing(
egui::RichText::new(text.download_advanced_header).strong(),
⋮----
.num_columns(2)
.spacing([10.0, 4.0])
.show(ui, |ui| {
⋮----
.checkbox(
⋮----
ui.end_row();
⋮----
ui.add_space(4.0);
⋮----
ui.label(text.download_opt_cookies);
⋮----
.selected_text(match &self.cookie_browser {
⋮----
text.download_no_cookie_option.to_string()
⋮----
other => other.to_string(),
⋮----
.width(140.0)
⋮----
.selectable_value(
⋮----
browser.clone(),
⋮----
ui.add_space(15.0);
let state = self.download_state.lock().unwrap().clone();
⋮----
.heading()
.color(egui::Color32::WHITE),
⋮----
.min_size(egui::vec2(ui.available_width(), 36.0))
.fill(btn_color);
ui.add(btn).clicked()
⋮----
if draw_download_btn(ui) {
if !self.input_url.is_empty() {
self.logs.lock().unwrap().clear();
⋮----
self.start_media_download(
text.download_progress_info_fmt.to_string(),
⋮----
ui.add_space(5.0);
⋮----
egui::RichText::new(format!(
⋮----
.color(egui::Color32::RED)
.small(),
⋮----
.button(egui::RichText::new(btn_text).size(10.0))
⋮----
egui::Frame::group(ui.style())
.fill(if ctx.style().visuals.dark_mode {
⋮----
let logs = self.logs.lock().unwrap();
let mut full_log_str = logs.join("\n");
⋮----
.max_height(120.0)
⋮----
ui.add(
⋮----
.font(egui::FontId::monospace(10.0))
.desired_width(f32::INFINITY)
.interactive(true)
.lock_focus(false),
⋮----
ui.vertical_centered(|ui| {
let success_color = if ctx.style().visuals.dark_mode {
⋮----
.color(success_color)
.heading(),
⋮----
if let Some(name) = path.file_name() {
⋮----
.to_string_lossy()
.replace("\u{29F8}", "/")
.replace("\u{FF0F}", "/")
.replace("\u{FF1A}", ":")
.replace("\u{FF1F}", "?")
.replace("\u{FF0A}", "*")
.replace("\u{FF1C}", "<")
.replace("\u{FF1E}", ">")
.replace("\u{FF5C}", "|")
.replace("\u{FF02}", "\"");
ui.label(egui::RichText::new(display_name).small());
⋮----
let enabled = path.components().next().is_some();
⋮----
.add_enabled(
⋮----
if let Some(parent) = path.parent() {
⋮----
ui.label(text.download_status_starting);
⋮----
msg.replace("[download]", "").trim().to_string();
ui.label(egui::RichText::new(clean_msg).small());
⋮----
ui.add(egui::ProgressBar::new(*progress).animate(true));
</file>

<file path="src/model_config.rs">
pub enum ModelType {
⋮----
pub struct ModelConfig {
⋮----
impl ModelConfig {
pub fn new(
⋮----
id: id.to_string(),
provider: provider.to_string(),
name_vi: name_vi.to_string(),
name_ko: name_ko.to_string(),
name_en: name_en.to_string(),
full_name: full_name.to_string(),
⋮----
quota_limit_vi: quota_limit_vi.to_string(),
quota_limit_ko: quota_limit_ko.to_string(),
quota_limit_en: quota_limit_en.to_string(),
⋮----
pub fn model_is_non_llm(model_id: &str) -> bool {
⋮----
pub fn get_all_models() -> &'static [ModelConfig] {
⋮----
pub fn get_model_by_id(id: &str) -> Option<ModelConfig> {
get_all_models().iter().find(|m| m.id == id).cloned()
⋮----
/// Resolve a fallback model for retry logic
/// Prioritizes:
⋮----
/// Prioritizes:
/// 1. Same provider, same type (Prioritize based on list order - treating list as priority queue)
⋮----
/// 1. Same provider, same type (Prioritize based on list order - treating list as priority queue)
/// 2. Different provider, same type
⋮----
/// 2. Different provider, same type
use crate::config::Config;
⋮----
use crate::config::Config;
⋮----
/// 2. Different provider, same type
/// Checks if the provider is actually configured (has API key) before suggesting it.
⋮----
/// Checks if the provider is actually configured (has API key) before suggesting it.
pub fn resolve_fallback_model(
⋮----
pub fn resolve_fallback_model(
⋮----
let all_models = get_all_models_with_ollama();
let current_model_opt = get_model_by_id(failed_model_id);
⋮----
.as_ref()
.map(|m| m.provider.as_str())
.unwrap_or("");
// Helper to check if a provider is configured
⋮----
"groq" => !config.api_key.is_empty(),
"google" => !config.gemini_api_key.is_empty(),
"openai" => false, // We don't have openai_api_key in config struct (only openrouter/cerebras) - wait, checking Config struct..
"openrouter" => !config.openrouter_api_key.is_empty(),
"cerebras" => !config.cerebras_api_key.is_empty(),
⋮----
let must_support_search = model_supports_search_by_id(failed_model_id);
if !current_provider.is_empty() {
⋮----
.iter()
.filter(|m| {
⋮----
&& !failed_model_ids.contains(&m.id)
&& (!must_support_search || model_supports_search_by_name(&m.full_name))
⋮----
.collect();
if let Some(last) = same_provider_candidates.last() {
return Some((*last).clone());
⋮----
&& is_provider_configured(&m.provider)
⋮----
if let Some(last) = diff_provider_candidates.last() {
⋮----
pub fn get_all_models_with_ollama() -> Vec<ModelConfig> {
let mut models: Vec<ModelConfig> = ALL_MODELS.iter().cloned().collect();
let cached = OLLAMA_MODEL_CACHE.lock().unwrap();
for ollama_model in cached.iter() {
models.push(ollama_model.clone());
⋮----
pub fn model_supports_search_by_name(full_name: &str) -> bool {
if full_name.contains("gemma-3-27b-it") {
⋮----
if full_name.contains("gemini-3-flash-preview") {
⋮----
if full_name.contains("gemini") {
⋮----
if full_name.contains("gemma") {
⋮----
if full_name.contains("compound") {
⋮----
pub fn model_supports_search_by_id(id: &str) -> bool {
if let Some(conf) = get_model_by_id(id) {
return model_supports_search_by_name(&conf.full_name);
⋮----
if id.contains("compound") {
⋮----
pub fn is_ollama_scan_in_progress() -> bool {
OLLAMA_SCAN_IN_PROGRESS.load(Ordering::SeqCst)
⋮----
pub fn trigger_ollama_model_scan() {
let (use_ollama, base_url) = if let Ok(app) = crate::APP.lock() {
(app.config.use_ollama, app.config.ollama_base_url.clone())
⋮----
let last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
if last_scan.elapsed().as_secs() < 5 {
⋮----
if OLLAMA_SCAN_IN_PROGRESS.swap(true, Ordering::SeqCst) {
⋮----
let mut last_scan = OLLAMA_LAST_SCAN.lock().unwrap();
⋮----
let model_id = format!(
⋮----
let display_name = format!("{} (Local)", ollama_model.name);
⋮----
new_models.push(ModelConfig {
id: format!("{}-vision", model_id),
provider: "ollama".to_string(),
name_vi: display_name.clone(),
name_ko: display_name.clone(),
name_en: display_name.clone(),
full_name: ollama_model.name.clone(),
⋮----
quota_limit_vi: "Không giới hạn".to_string(),
quota_limit_ko: "무제한".to_string(),
quota_limit_en: "Unlimited".to_string(),
⋮----
let mut cache = OLLAMA_MODEL_CACHE.lock().unwrap();
⋮----
OLLAMA_SCAN_IN_PROGRESS.store(false, Ordering::SeqCst);
</file>

<file path="src/overlay/continuous_mode.rs">
use std::sync::Mutex;
⋮----
pub fn is_active() -> bool {
CONTINUOUS_MODE_ACTIVE.load(Ordering::SeqCst)
⋮----
pub fn is_pending_start() -> bool {
CONTINUOUS_PENDING_START.load(Ordering::SeqCst)
⋮----
pub fn set_pending_start(preset_idx: usize, hotkey_name: String) {
CONTINUOUS_PRESET_IDX.store(preset_idx, Ordering::SeqCst);
*CONTINUOUS_HOTKEY_NAME.lock().unwrap() = hotkey_name;
CONTINUOUS_PENDING_START.store(true, Ordering::SeqCst);
⋮----
pub fn get_preset_idx() -> usize {
CONTINUOUS_PRESET_IDX.load(Ordering::SeqCst)
⋮----
pub fn get_hotkey_name() -> String {
CONTINUOUS_HOTKEY_NAME.lock().unwrap().clone()
⋮----
pub fn set_latest_hotkey_name(name: String) {
⋮----
*LATEST_HOTKEY_NAME.lock().unwrap() = name;
⋮----
pub fn get_latest_hotkey_name() -> String {
LATEST_HOTKEY_NAME.lock().unwrap().clone()
⋮----
pub fn activate(preset_idx: usize, hotkey_name: String) {
⋮----
CONTINUOUS_MODE_ACTIVE.store(true, Ordering::SeqCst);
CONTINUOUS_PENDING_START.store(false, Ordering::SeqCst);
⋮----
pub fn deactivate() {
CONTINUOUS_MODE_ACTIVE.store(false, Ordering::SeqCst);
⋮----
CONTINUOUS_PRESET_IDX.store(0, Ordering::SeqCst);
*CONTINUOUS_HOTKEY_NAME.lock().unwrap() = String::new();
⋮----
pub fn show_activation_notification(preset_id: &str, hotkey_name: &str) {
⋮----
if let Ok(app) = crate::APP.lock() {
app.config.ui_language.clone()
⋮----
"en".to_string()
⋮----
let suffix = match lang.as_str() {
⋮----
let title = format!("{} - {}", localized_name, suffix);
⋮----
let mut message = locale.continuous_mode_activated.to_string();
message = message.replace("✨ ", "").replace("✨", "");
// Remove Preset Name part (because it's in title now)
⋮----
.replace("\"{preset}\"", "")
.replace("'{preset}'", "")
.replace("{preset}", "");
// 3. Hotkey Logic
// If triggered by UI (Bubble), hotkey_name is typically empty or generic "Hotkey"
if hotkey_name.is_empty()
|| hotkey_name.to_lowercase() == "hotkey"
|| hotkey_name.to_lowercase() == "esc"
⋮----
.replace(" hay {hotkey}", "")
.replace(" or {hotkey}", "")
.replace(" 또는 {hotkey}", "");
// Final cleanup for remaining {hotkey} if the structure was different
message = message.replace("{hotkey}", "");
⋮----
// Specific Hotkey - keep the structure
message = message.replace("{hotkey}", hotkey_name);
⋮----
// Clean up any double spaces introduced by removals
⋮----
let new_msg = message.replace("  ", " ");
⋮----
let message = message.trim();
// Call the detailed notification
⋮----
/// Check if a preset type supports continuous mode (only image and text)
pub fn supports_continuous_mode(preset_type: &str) -> bool {
⋮----
pub fn supports_continuous_mode(preset_type: &str) -> bool {
⋮----
use std::time::Instant;
⋮----
pub fn reset_heartbeat() {
HEARTBEAT_COUNT.store(0, Ordering::SeqCst);
⋮----
pub fn update_last_trigger_time() {
HEARTBEAT_COUNT.fetch_add(1, Ordering::SeqCst);
*LAST_HOTKEY_TRIGGER_TIME.lock().unwrap() = Some(Instant::now());
⋮----
pub fn was_triggered_recently(ms: u128) -> bool {
if let Some(last) = *LAST_HOTKEY_TRIGGER_TIME.lock().unwrap() {
let elapsed = last.elapsed().as_millis();
let count = HEARTBEAT_COUNT.load(Ordering::SeqCst);
⋮----
pub fn set_current_hotkey(modifiers: u32, vk_code: u32) {
*CURRENT_HOTKEY.lock().unwrap() = Some((modifiers, vk_code));
⋮----
pub fn get_current_hotkey_info() -> Option<(u32, u32)> {
*CURRENT_HOTKEY.lock().unwrap()
⋮----
pub fn are_modifiers_still_held() -> bool {
⋮----
let hotkey = CURRENT_HOTKEY.lock().unwrap().clone();
⋮----
let alt_held = (GetAsyncKeyState(VK_MENU.0 as i32) as u16 & 0x8000) != 0;
let ctrl_held = (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0;
let shift_held = (GetAsyncKeyState(VK_SHIFT.0 as i32) as u16 & 0x8000) != 0;
let lwin_held = (GetAsyncKeyState(VK_LWIN.0 as i32) as u16 & 0x8000) != 0;
let rwin_held = (GetAsyncKeyState(VK_RWIN.0 as i32) as u16 & 0x8000) != 0;
⋮----
let key_held = (GetAsyncKeyState(_vk_code as i32) as u16 & 0x8000) != 0;
⋮----
debug_str.push_str(&format!("Key({}):{}, ", _vk_code, key_held));
⋮----
debug_str.push_str(&format!("Alt:{}, ", alt_held));
⋮----
debug_str.push_str(&format!("Ctrl:{}, ", ctrl_held));
⋮----
debug_str.push_str(&format!("Shift:{}, ", shift_held));
⋮----
debug_str.push_str(&format!("Win:{}, ", win_held));
⋮----
println!(
⋮----
println!("[Continuous] No current hotkey stored.");
</file>

<file path="src/overlay/favorite_bubble/window.rs">
use super::render::update_bubble_visual;
⋮----
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
pub fn show_favorite_bubble() {
if BUBBLE_ACTIVE.swap(true, Ordering::SeqCst) {
⋮----
CURRENT_OPACITY.store(0, Ordering::SeqCst);
FADE_OUT_STATE.store(false, Ordering::SeqCst);
⋮----
create_bubble_window();
⋮----
pub fn hide_favorite_bubble() {
if !BUBBLE_ACTIVE.load(Ordering::SeqCst) {
⋮----
let hwnd_val = BUBBLE_HWND.load(Ordering::SeqCst);
⋮----
FADE_OUT_STATE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
let _ = SetTimer(Some(hwnd), OPACITY_TIMER_ID, 16, None);
⋮----
pub fn trigger_blink_animation() {
⋮----
BLINK_STATE.store(1, Ordering::SeqCst);
⋮----
fn create_bubble_window() {
⋮----
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoriteBubble");
REGISTER_BUBBLE_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(bubble_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_HAND).unwrap_or_default(),
⋮----
RegisterClassW(&wc);
⋮----
let (initial_x, initial_y, current_size) = if let Ok(app) = APP.lock() {
⋮----
BUBBLE_SIZE.store(size, Ordering::SeqCst);
let v_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let v_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let v_w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let v_h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let pos = app.config.favorite_bubble_position.unwrap_or_else(|| {
⋮----
let final_x = pos.0.clamp(v_x, v_x + v_w - size);
let final_y = pos.1.clamp(v_y, v_y + v_h - size);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("FavBubble"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
BUBBLE_ACTIVE.store(false, Ordering::SeqCst);
⋮----
BUBBLE_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
update_bubble_visual(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
ensure_panel_created(hwnd, true);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
destroy_panel();
⋮----
BUBBLE_HWND.store(0, Ordering::SeqCst);
let _ = CoUninitialize();
⋮----
unsafe extern "system" fn bubble_wnd_proc(
⋮----
let _ = KillTimer(Some(hwnd), PHYSICS_TIMER_ID);
PHYSICS_STATE.with(|p| *p.borrow_mut() = (0.0, 0.0));
IS_DRAGGING.store(true, Ordering::SeqCst);
IS_DRAGGING_MOVED.store(false, Ordering::SeqCst);
⋮----
DRAG_START_X.store(x as isize, Ordering::SeqCst);
DRAG_START_Y.store(y as isize, Ordering::SeqCst);
let _ = SetCapture(hwnd);
LRESULT(0)
⋮----
let was_dragging_moved = IS_DRAGGING_MOVED.load(Ordering::SeqCst);
IS_DRAGGING.store(false, Ordering::SeqCst);
let _ = ReleaseCapture();
⋮----
if IS_EXPANDED.load(Ordering::SeqCst) {
close_panel();
⋮----
show_panel(hwnd);
⋮----
let _ = SetTimer(Some(hwnd), PHYSICS_TIMER_ID, 16, None);
⋮----
save_bubble_position();
⋮----
if IS_DRAGGING.load(Ordering::SeqCst) && (wparam.0 & 0x0001) != 0 {
⋮----
if !IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
let start_x = DRAG_START_X.load(Ordering::SeqCst) as i32;
let start_y = DRAG_START_Y.load(Ordering::SeqCst) as i32;
let dx = (x - start_x).abs();
let dy = (y - start_y).abs();
⋮----
IS_DRAGGING_MOVED.store(true, Ordering::SeqCst);
⋮----
if IS_DRAGGING_MOVED.load(Ordering::SeqCst) {
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let bubble_size = BUBBLE_SIZE.load(Ordering::SeqCst);
⋮----
(rect.left + x - bubble_size / 2).clamp(v_x, v_x + v_w - bubble_size);
⋮----
(rect.top + y - bubble_size / 2).clamp(v_y, v_y + v_h - bubble_size);
⋮----
PHYSICS_STATE.with(|p| {
let (old_vx, old_vy) = *p.borrow();
⋮----
*p.borrow_mut() = (final_vx, final_vy);
⋮----
let _ = SetWindowPos(
⋮----
move_panel_to_bubble(new_x, new_y);
⋮----
if !IS_HOVERED.load(Ordering::SeqCst) {
IS_HOVERED.store(true, Ordering::SeqCst);
⋮----
let _ = TrackMouseEvent(&mut tme);
⋮----
IS_HOVERED.store(false, Ordering::SeqCst);
⋮----
let is_hovered = IS_HOVERED.load(Ordering::SeqCst);
let is_expanded = IS_EXPANDED.load(Ordering::SeqCst);
let blink_state = BLINK_STATE.load(Ordering::SeqCst);
let is_fading_out = FADE_OUT_STATE.load(Ordering::SeqCst);
⋮----
let current = CURRENT_OPACITY.load(Ordering::SeqCst);
⋮----
(current as u16 + step as u16).min(target as u16) as u8
⋮----
(current as i16 - step as i16).max(target as i16) as u8
⋮----
CURRENT_OPACITY.store(new_opacity, Ordering::SeqCst);
⋮----
let _ = KillTimer(Some(hwnd), OPACITY_TIMER_ID);
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
BLINK_STATE.store(0, Ordering::SeqCst);
⋮----
BLINK_STATE.fetch_add(1, Ordering::SeqCst);
⋮----
let (mut vx, mut vy) = *p.borrow();
⋮----
if vx.abs() < 0.2 && vy.abs() < 0.2 {
⋮----
*p.borrow_mut() = (0.0, 0.0);
⋮----
let min_x = GetSystemMetrics(SM_XVIRTUALSCREEN) as f32;
⋮----
let min_y = GetSystemMetrics(SM_YVIRTUALSCREEN) as f32;
⋮----
*p.borrow_mut() = (vx, vy);
⋮----
move_panel_to_bubble(next_x as i32, next_y as i32);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
PostQuitMessage(0);
⋮----
if !IS_EXPANDED.load(Ordering::SeqCst) {
⋮----
let panel_val = PANEL_HWND.load(Ordering::SeqCst);
⋮----
let panel_hwnd = HWND(panel_val as *mut std::ffi::c_void);
let _ = PostMessageW(Some(panel_hwnd), WM_REFRESH_PANEL, WPARAM(0), LPARAM(0));
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/html_components/icons.rs">
pub fn get_icon_svg(name: &str) -> &'static str {
</file>

<file path="src/overlay/realtime_webview/app_selection.rs">
use std::collections::HashMap;
use std::sync::Mutex;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
use windows::Win32::UI::Shell::ExtractIconExW;
⋮----
thread_local! {
⋮----
fn get_process_exe_path(pid: u32) -> Option<String> {
⋮----
let handle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, false, pid).ok()?;
⋮----
let mut size = buffer.len() as u32;
let result = QueryFullProcessImageNameW(
⋮----
windows::core::PWSTR(buffer.as_mut_ptr()),
⋮----
if result.is_ok() && size > 0 {
Some(String::from_utf16_lossy(&buffer[..size as usize]))
⋮----
fn extract_icon_as_base64(exe_path: &str) -> Option<String> {
⋮----
let wide_path: Vec<u16> = exe_path.encode_utf16().chain(std::iter::once(0)).collect();
⋮----
let count = ExtractIconExW(
windows::core::PCWSTR(wide_path.as_ptr()),
⋮----
Some(&mut large_icon),
⋮----
if count == 0 || large_icon.is_invalid() {
⋮----
if GetIconInfo(large_icon, &mut icon_info).is_err() {
let _ = DestroyIcon(large_icon);
⋮----
if GetObjectW(
icon_info.hbmColor.into(),
⋮----
Some(&mut bmp as *mut _ as *mut std::ffi::c_void),
⋮----
let _ = DeleteObject(icon_info.hbmMask.into());
let _ = DeleteObject(icon_info.hbmColor.into());
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
⋮----
let mut pixels = vec![0u8; (width * height * 4) as usize];
let lines = GetDIBits(
⋮----
Some(pixels.as_mut_ptr() as *mut std::ffi::c_void),
⋮----
let _ = DeleteDC(hdc_mem);
let _ = ReleaseDC(None, hdc_screen);
⋮----
for i in (0..pixels.len()).step_by(4) {
pixels.swap(i, i + 2);
⋮----
for i in (3..pixels.len()).step_by(4) {
⋮----
.write_to(
⋮----
.is_err()
⋮----
use base64::Engine;
Some(base64::engine::general_purpose::STANDARD.encode(&png_data))
⋮----
fn get_app_icon(pid: u32) -> Option<String> {
⋮----
let cache = ICON_CACHE.lock().ok()?;
if let Some(cached) = cache.get(&pid) {
return cached.clone();
⋮----
let icon = get_process_exe_path(pid).and_then(|path| extract_icon_as_base64(&path));
if let Ok(mut cache) = ICON_CACHE.lock() {
cache.insert(pid, icon.clone());
⋮----
pub fn enumerate_audio_apps() -> Vec<(u32, String)> {
⋮----
extern "system" fn enum_callback(hwnd: HWND, lparam: LPARAM) -> windows_core::BOOL {
⋮----
if !IsWindowVisible(hwnd).as_bool() {
⋮----
let len = GetWindowTextW(hwnd, &mut title_buf);
⋮----
if title.is_empty() || title == "Program Manager" || title == "Settings" {
⋮----
GetWindowThreadProcessId(hwnd, Some(&mut pid));
⋮----
if seen_pids.contains(&pid) {
⋮----
seen_pids.insert(pid);
⋮----
apps.push((pid, title));
⋮----
let _ = EnumWindows(
Some(enum_callback),
LPARAM(&mut callback_data as *mut _ as isize),
⋮----
apps.sort_by(|a, b| a.1.to_lowercase().cmp(&b.1.to_lowercase()));
⋮----
pub fn show_app_selection_popup() {
use crate::gui::locale::LocaleText;
use crate::APP;
use std::sync::atomic::Ordering;
⋮----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
⋮----
let apps = enumerate_audio_apps();
if apps.is_empty() {
eprintln!("No audio apps found for selection");
⋮----
.iter()
.map(|(pid, name)| {
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('<', "&lt;")
.replace('>', "&gt;");
let short_name = if escaped_name.chars().count() > 50 {
let truncated: String = escaped_name.chars().take(47).collect();
format!("{}...", truncated)
⋮----
escaped_name.clone()
⋮----
let icon_html = if let Some(base64_icon) = get_app_icon(*pid) {
format!(
⋮----
.collect();
// Determine initial theme
let is_dark = if let Ok(app) = crate::APP.lock() {
⋮----
// Get CSS
let css_content = get_app_selection_css(is_dark);
let html = format!(
⋮----
// Create popup window
⋮----
// Register window class
let class_name = w!("AppSelectPopup");
let h_instance = GetModuleHandleW(None).unwrap_or_default();
⋮----
lpfnWndProc: Some(app_select_wndproc),
hInstance: h_instance.into(),
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(GetStockObject(BLACK_BRUSH).0),
⋮----
RegisterClassExW(&wc);
// Center the window on screen
let screen_width = GetSystemMetrics(SM_CXSCREEN);
let screen_height = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("Select App"),
⋮----
Some(h_instance.into()),
⋮----
.unwrap();
// Store handle for external closing
APP_SELECTION_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
// Apply rounded corners
⋮----
let _ = DwmSetWindowAttribute(
⋮----
// Create WebView2 with shared context for RAM efficiency
let html_clone = html.clone();
⋮----
// Create a WebContext using the shared data directory
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("realtime"));
let mut web_context = wry::WebContext::new(Some(shared_data_dir));
// Store HTML in font server and get URL for same-origin font loading
⋮----
crate::overlay::html_components::font_manager::store_html_page(html_clone.clone())
.unwrap_or_else(|| {
format!("data:text/html,{}", urlencoding::encode(&html_clone))
⋮----
// LOCK SCOPE: Serialized build to prevent resource contention
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
.with_bounds(wry::Rect {
⋮----
.with_url(&page_url)
.with_transparent(true)
.with_ipc_handler(move |req| {
let body = req.body();
if body.starts_with("selectApp:") {
⋮----
if let Some((pid_str, name)) = rest.split_once(':') {
⋮----
// Store selected app
SELECTED_APP_PID.store(pid, Ordering::SeqCst);
if let Ok(mut app_name) = SELECTED_APP_NAME.lock() {
*app_name = name.to_string();
⋮----
// Set audio source to trigger restart (must set this for restart to work!)
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = "device".to_string();
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
// Close native popup
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = PostMessageW(
Some(hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
// Close TTS Modal using shared flag (more robust)
CLOSE_TTS_MODAL_REQUEST.store(true, Ordering::SeqCst);
// Trigger updates on both windows to ensure the flag is checked immediately
⋮----
std::ptr::addr_of!(TRANSLATION_HWND).read();
let real_hwnd = std::ptr::addr_of!(REALTIME_HWND).read();
if !trans_hwnd.is_invalid() {
⋮----
Some(trans_hwnd),
⋮----
if !real_hwnd.is_invalid() {
⋮----
Some(real_hwnd),
⋮----
eprintln!(
⋮----
.build_as_child(&HwndWrapper(hwnd));
⋮----
if result.is_err() {
eprintln!("Failed to create WebView for app selection");
let _ = DestroyWindow(hwnd);
⋮----
// Keep WebView alive in thread-local storage
let webview = result.unwrap();
APP_SELECT_WEBVIEW.with(|w| {
*w.borrow_mut() = Some(webview);
⋮----
// Message loop
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
pub unsafe extern "system" fn app_select_wndproc(
⋮----
use crate::api::realtime_audio::WM_THEME_UPDATE;
⋮----
update_app_selection_theme(hwnd);
LRESULT(0)
⋮----
// Drop WebView before thread exit to ensure clean cleanup
⋮----
*w.borrow_mut() = None;
⋮----
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
PostQuitMessage(0);
⋮----
// Resize child (WebView) to match parent
⋮----
if let Ok(child) = GetWindow(hwnd, GW_CHILD) {
⋮----
let _ = MoveWindow(child, 0, 0, width, height, true);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
eprintln!("Panic in app_select_wndproc");
// Try to provide default processing if panic occurred
⋮----
fn get_app_selection_css(is_dark: bool) -> String {
⋮----
"rgba(20, 20, 30, 0.98)",    // bg
"#fff",                      // text
"#888",                      // hint
"rgba(255, 255, 255, 0.05)", // item bg
"rgba(255, 255, 255, 0.1)",  // item hover
"rgba(100, 180, 255, 0.5)",  // item border hover
"rgba(255, 255, 255, 0.2)",  // scrollbar thumb
⋮----
pub fn update_app_selection_theme(_hwnd: HWND) {
⋮----
let css = get_app_selection_css(is_dark);
let css_escaped = css.replace("`", "\\`");
let script = format!(
⋮----
if let Some(webview) = w.borrow().as_ref() {
let _ = webview.evaluate_script(&script);
</file>

<file path="src/overlay/realtime_webview/manager.rs">
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::Graphics::Gdi::HBRUSH;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
pub fn is_realtime_overlay_active() -> bool {
unsafe { IS_ACTIVE && !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() }
⋮----
pub fn stop_realtime_overlay() {
crate::api::tts::TTS_MANAGER.stop();
crate::overlay::realtime_egui::MINIMAL_ACTIVE.store(false, std::sync::atomic::Ordering::SeqCst);
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
⋮----
let popup_val = APP_SELECTION_HWND.load(std::sync::atomic::Ordering::SeqCst);
⋮----
let popup_hwnd = HWND(popup_val as *mut std::ffi::c_void);
let _ = PostMessageW(Some(popup_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
APP_SELECTION_HWND.store(0, std::sync::atomic::Ordering::SeqCst);
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
pub fn show_realtime_overlay(preset_idx: usize) {
⋮----
internal_create_realtime_loop();
⋮----
if IS_WARMED_UP && !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
⋮----
WPARAM(preset_idx),
⋮----
unsafe fn internal_create_realtime_loop() {
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("RealtimeWebViewOverlay");
REGISTER_REALTIME_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(realtime_wnd_proc_internal);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
⋮----
let trans_class = w!("RealtimeTranslationWebViewOverlay");
REGISTER_TRANSLATION_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(translation_wnd_proc_internal);
⋮----
let main_hwnd = CreateWindowExW(
⋮----
w!("Realtime Transcription"),
⋮----
Some(instance.into()),
⋮----
.unwrap();
let trans_hwnd = CreateWindowExW(
⋮----
w!("Translation"),
⋮----
let _ = DwmSetWindowAttribute(
⋮----
create_realtime_webview(
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
destroy_realtime_webview(REALTIME_HWND);
destroy_realtime_webview(TRANSLATION_HWND);
⋮----
let _ = CoUninitialize();
⋮----
unsafe extern "system" fn realtime_wnd_proc_internal(
⋮----
handle_start_overlay(preset_idx);
return LRESULT(0);
⋮----
realtime_wnd_proc(hwnd, msg, wparam, lparam)
⋮----
unsafe extern "system" fn translation_wnd_proc_internal(
⋮----
translation_wnd_proc(hwnd, msg, wparam, lparam)
⋮----
unsafe fn handle_start_overlay(preset_idx: usize) {
⋮----
let mut preset = APP.lock().unwrap().config.presets[preset_idx].clone();
⋮----
REALTIME_STOP_SIGNAL.store(false, Ordering::SeqCst);
MIC_VISIBLE.store(true, Ordering::SeqCst);
TRANS_VISIBLE.store(true, Ordering::SeqCst);
AUDIO_SOURCE_CHANGE.store(false, Ordering::SeqCst);
LANGUAGE_CHANGE.store(false, Ordering::SeqCst);
TRANSLATION_MODEL_CHANGE.store(false, Ordering::SeqCst);
⋮----
let mut state = REALTIME_STATE.lock().unwrap();
⋮----
let app = APP.lock().unwrap();
⋮----
app.config.realtime_audio_source.clone(),
app.config.realtime_target_language.clone(),
app.config.realtime_translation_model.clone(),
app.config.realtime_transcription_model.clone(),
⋮----
let effective_audio_source = if config_audio_source.is_empty() {
"device".to_string()
⋮----
config_audio_source.clone()
⋮----
preset.audio_source = effective_audio_source.clone();
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = effective_audio_source.clone();
⋮----
let target_language = if !config_language.is_empty() {
⋮----
} else if preset.blocks.len() > 1 {
⋮----
if !trans_block.selected_language.is_empty() {
trans_block.selected_language.clone()
⋮----
.get("language")
.cloned()
.or_else(|| trans_block.language_vars.get("language1").cloned())
.unwrap_or_else(|| "English".to_string())
⋮----
"English".to_string()
⋮----
if !target_language.is_empty() {
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = target_language.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let has_translation = preset.blocks.len() > 1;
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
let _ = ShowWindow(TRANSLATION_HWND, SW_HIDE);
⋮----
notify_webview_settings(
⋮----
resize_webview(REALTIME_HWND, main_w, main_h);
clear_webview_text(REALTIME_HWND);
⋮----
resize_webview(TRANSLATION_HWND, trans_w, trans_h);
clear_webview_text(TRANSLATION_HWND);
⋮----
sync_visibility_to_webviews();
⋮----
Some(TRANSLATION_HWND)
⋮----
start_realtime_transcription(
⋮----
REALTIME_STOP_SIGNAL.clone(),
⋮----
REALTIME_STATE.clone(),
⋮----
fn notify_webview_settings(
⋮----
let script = format!(
⋮----
REALTIME_WEBVIEWS.with(|wvs| {
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script(&script);
⋮----
fn resize_webview(hwnd: HWND, width: i32, height: i32) {
⋮----
let _ = webview.set_bounds(wry::Rect {
</file>

<file path="src/overlay/result/layout.rs">
pub fn should_show_buttons(_window_w: i32, _window_h: i32) -> bool {
⋮----
fn rects_overlap(a: &RECT, b: &RECT, gap: i32) -> bool {
⋮----
fn get_all_active_window_rects() -> Vec<RECT> {
⋮----
if let Ok(states) = WINDOW_STATES.lock() {
for (&hwnd_key, _state) in states.iter() {
let hwnd = HWND(hwnd_key as *mut std::ffi::c_void);
⋮----
if IsWindow(Some(hwnd)).as_bool() && IsWindowVisible(hwnd).as_bool() {
⋮----
if GetWindowRect(hwnd, &mut rect).is_ok() {
rects.push(rect);
⋮----
fn would_overlap_existing(proposed: &RECT, existing: &[RECT], gap: i32) -> bool {
existing.iter().any(|r| rects_overlap(proposed, r, gap))
⋮----
pub fn calculate_next_window_rect(prev: RECT, monitor_rect: RECT) -> RECT {
⋮----
let w = (prev.right - prev.left).abs();
let h = (prev.bottom - prev.top).abs();
let existing_windows = get_all_active_window_rects();
⋮----
&& !would_overlap_existing(&right_candidate, &existing_windows, gap)
⋮----
&& !would_overlap_existing(&bottom_candidate, &existing_windows, gap)
⋮----
&& !would_overlap_existing(&left_candidate, &existing_windows, gap)
⋮----
&& !would_overlap_existing(&top_candidate, &existing_windows, gap)
⋮----
&& !would_overlap_existing(&diag, &existing_windows, gap)
⋮----
&& !would_overlap_existing(&cascade, &existing_windows, gap)
⋮----
pub fn get_copy_btn_rect(window_w: i32, window_h: i32) -> RECT {
⋮----
pub fn get_edit_btn_rect(window_w: i32, window_h: i32) -> RECT {
let speaker_rect = get_speaker_btn_rect(window_w, window_h);
⋮----
pub fn get_markdown_btn_rect(window_w: i32, window_h: i32) -> RECT {
let edit_rect = get_edit_btn_rect(window_w, window_h);
⋮----
pub fn get_download_btn_rect(window_w: i32, window_h: i32) -> RECT {
let md_rect = get_markdown_btn_rect(window_w, window_h);
⋮----
pub fn get_undo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let dl_rect = get_download_btn_rect(window_w, window_h);
⋮----
pub fn get_redo_btn_rect(window_w: i32, window_h: i32) -> RECT {
let undo_rect = get_undo_btn_rect(window_w, window_h);
⋮----
pub fn get_speaker_btn_rect(window_w: i32, window_h: i32) -> RECT {
let copy_rect = get_copy_btn_rect(window_w, window_h);
⋮----
pub fn get_resize_edge(width: i32, height: i32, x: i32, y: i32) -> ResizeEdge {
</file>

<file path="src/overlay/result/mod.rs">
pub mod button_canvas;
mod event_handler;
pub mod layout;
mod logic;
pub mod markdown_view;
pub mod paint;
pub mod state;
mod window;
⋮----
pub fn is_any_refine_active() -> bool {
let states = WINDOW_STATES.lock().unwrap();
states.values().any(|s| s.is_editing)
⋮----
pub fn get_active_refine_parent() -> Option<HWND> {
⋮----
.iter()
.find(|(_, s)| s.is_editing)
.map(|(hwnd, _)| HWND(*hwnd as *mut std::ffi::c_void))
⋮----
pub fn set_refine_text(hwnd: HWND, text: &str, is_insert: bool) {
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd_key) {
state.input_text = text.to_string();
⋮----
pub fn trigger_copy(hwnd: HWND) {
⋮----
.get(&hwnd_key)
.map(|s| s.full_text.clone())
.unwrap_or_default()
⋮----
if !text.is_empty() {
⋮----
if let Some(state) = states.get_mut(&(hwnd_val as isize)) {
⋮----
button_canvas::update_window_position(HWND(hwnd_val as *mut std::ffi::c_void));
⋮----
pub fn trigger_undo(hwnd: HWND) {
⋮----
if let Some(last) = state.text_history.pop() {
let current = state.full_text.clone();
state.redo_history.push(current);
state.full_text = last.clone();
(Some(last), state.is_markdown_mode)
⋮----
windows::core::PCWSTR(wide_text.as_ptr()),
⋮----
let _ = PostMessageW(
Some(hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
pub fn trigger_redo(hwnd: HWND) {
⋮----
if let Some(redo) = state.redo_history.pop() {
⋮----
state.text_history.push(current);
state.full_text = redo.clone();
(Some(redo), state.is_markdown_mode)
⋮----
pub fn trigger_edit(hwnd: HWND) {
⋮----
state.input_text.clear();
⋮----
pub fn trigger_refine_submit(hwnd: HWND, text: &str) {
if text.trim().is_empty() {
⋮----
let text_to_refine = state.full_text.clone();
state.text_history.push(text_to_refine.clone());
state.redo_history.clear();
⋮----
state.pending_text = Some(String::new());
⋮----
start_refinement(hwnd, text);
⋮----
pub fn trigger_refine_cancel(hwnd: HWND) {
⋮----
fn start_refinement(hwnd: HWND, user_prompt: &str) {
⋮----
if let Some(s) = states.get_mut(&hwnd_key) {
let prev = s.full_text.clone();
⋮----
s.context_data.clone(),
s.model_id.clone(),
s.provider.clone(),
⋮----
s.preset_prompt.clone(),
⋮----
let user_input = user_prompt.to_string();
⋮----
if prev_text.trim().is_empty() && !preset_prompt.is_empty() {
⋮----
let capture_hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.api_key.clone(),
app.config.gemini_api_key.clone(),
⋮----
&app.config.ui_language.clone()
⋮----
if let Some(state) = states.get_mut(&(capture_hwnd.0 as isize)) {
⋮----
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
acc_text.clear();
acc_text.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
⋮----
acc_text.push_str(chunk);
⋮----
state.pending_text = Some(acc_text.clone());
state.full_text = acc_text.clone();
⋮----
state.full_text = final_text.clone();
state.pending_text = Some(final_text);
⋮----
.map(|m| m.full_name)
.unwrap_or_else(|| model_id.to_string());
(app.config.ui_language.clone(), full_name)
⋮----
&e.to_string(),
⋮----
Some(&model_full_name),
⋮----
state.pending_text = Some(err_msg.clone());
⋮----
pub fn trigger_markdown_toggle(hwnd: HWND) {
⋮----
.map(|s| !s.is_refining && !s.is_streaming_active)
.unwrap_or(false)
⋮----
pub fn trigger_speaker(hwnd: HWND) {
⋮----
.map(|s| (s.full_text.clone(), s.tts_request_id, s.tts_loading))
⋮----
if current_tts_id != 0 && crate::api::tts::TTS_MANAGER.is_speaking(current_tts_id) {
crate::api::tts::TTS_MANAGER.stop();
⋮----
} else if !full_text.is_empty() {
⋮----
let request_id = crate::api::tts::TTS_MANAGER.speak(&full_text, hwnd_key);
⋮----
pub fn trigger_close_all() {
⋮----
.keys()
.map(|&k| HWND(k as *mut std::ffi::c_void))
.collect()
⋮----
if windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(hwnd)).as_bool() {
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
pub fn trigger_drag_window(hwnd: HWND, dx: i32, dy: i32) {
⋮----
if windows::Win32::UI::WindowsAndMessaging::GetWindowRect(hwnd, &mut rect).is_ok() {
</file>

<file path="src/overlay/result/state.rs">
use std::collections::HashMap;
⋮----
use windows::Win32::Graphics::Gdi::HBITMAP;
pub struct DustParticle {
⋮----
pub enum AnimationMode {
⋮----
pub enum ResizeEdge {
⋮----
pub enum InteractionMode {
⋮----
pub struct CursorPhysics {
⋮----
impl Default for CursorPhysics {
fn default() -> Self {
⋮----
pub enum RefineContext {
⋮----
pub struct WindowState {
⋮----
unsafe impl Send for WindowState {}
unsafe impl Sync for WindowState {}
⋮----
pub enum WindowType {
⋮----
pub fn link_windows(hwnd1: HWND, hwnd2: HWND) {
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(s1) = states.get_mut(&(hwnd1.0 as isize)) {
s1.linked_window = Some(hwnd2);
⋮----
if let Some(s2) = states.get_mut(&(hwnd2.0 as isize)) {
s2.linked_window = Some(hwnd1);
⋮----
pub fn close_windows_with_token(token: &Arc<AtomicBool>) {
token.store(true, Ordering::SeqCst);
⋮----
let states = WINDOW_STATES.lock().unwrap();
for (&h_val, state) in states.iter() {
⋮----
to_close.push(HWND(h_val as *mut std::ffi::c_void));
⋮----
if IsWindow(Some(hwnd)).as_bool() {
⋮----
let _ = PostMessageW(
Some(hwnd),
⋮----
pub fn get_window_group(hwnd: HWND) -> Vec<(HWND, RECT)> {
⋮----
if let Some(state) = states.get(&(hwnd.0 as isize)) {
token_to_match = state.cancellation_token.clone();
⋮----
for (&h_val, s) in states.iter() {
⋮----
let h = HWND(h_val as *mut std::ffi::c_void);
⋮----
group.push((h, r));
⋮----
if group.len() <= 1 {
group.clear();
⋮----
queue.push_back(hwnd);
visited.insert(hwnd.0);
while let Some(current) = queue.pop_front() {
⋮----
group.push((current, r));
if let Some(s) = states.get(&(current.0 as isize)) {
⋮----
if states.contains_key(&(linked.0 as isize)) && !visited.contains(&linked.0)
⋮----
visited.insert(linked.0);
queue.push_back(linked);
⋮----
pub fn set_window_interaction_mode(hwnd: HWND, mode: InteractionMode) {
⋮----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
</file>

<file path="src/overlay/result/window.rs">
use std::mem::size_of;
use std::sync::Once;
⋮----
use super::event_handler::result_wnd_proc;
⋮----
pub fn get_chain_color(visible_index: usize) -> u32 {
⋮----
let cycle_idx = (visible_index - 1) % (palette.len() - 1);
⋮----
pub fn create_result_window(
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("TranslationResult");
REGISTER_RESULT_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(result_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassW(&wc);
⋮----
let width = (target_rect.right - target_rect.left).abs();
let height = (target_rect.bottom - target_rect.top).abs();
⋮----
let hwnd = CreateWindowExW(
⋮----
w!(""),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
// FOR MARKDOWN MODES: Create WebView IMMEDIATELY after window creation
// See docs/WEBVIEW2_INITIALIZATION.md for why this is necessary
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 217, LWA_ALPHA);
⋮----
// Initialize physics with current cursor position to prevent (0,0) glitch
⋮----
let _ = GetCursorPos(&mut pt);
let _ = ScreenToClient(hwnd, &mut pt);
⋮----
// Get graphics mode from config
⋮----
let app = crate::APP.lock().unwrap();
app.config.graphics_mode.clone()
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
states.insert(
⋮----
full_text: initial_text.clone(),
⋮----
pending_text: Some(initial_text),
⋮----
// Markdown mode state
⋮----
let _ = DwmSetWindowAttribute(
⋮----
DWMWINDOWATTRIBUTE(33),
⋮----
let _ = SetForegroundWindow(hwnd);
⋮----
SetTimer(Some(hwnd), 3, 16, None);
⋮----
SetTimer(Some(hwnd), 2, 30, None);
⋮----
let _ = InvalidateRect(Some(hwnd), None, false);
let _ = UpdateWindow(hwnd);
⋮----
pub fn update_window_text(hwnd: HWND, text: &str) {
if !unsafe { IsWindow(Some(hwnd)).as_bool() } {
⋮----
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
state.pending_text = Some(text.to_string());
state.full_text = text.to_string();
</file>

<file path="src/overlay/utils.rs">
pub fn is_text_input_focused() -> bool {
⋮----
if let Ok(focused) = uia.GetFocusedElement() {
if focused.GetCurrentPattern(UIA_ValuePatternId).is_ok() {
⋮----
if focused.GetCurrentPattern(UIA_TextPatternId).is_ok() {
⋮----
let hwnd_foreground = GetForegroundWindow();
if !hwnd_foreground.is_invalid() {
let thread_id = GetWindowThreadProcessId(hwnd_foreground, None);
⋮----
if GetGUIThreadInfo(thread_id, &mut gui_info).is_ok() {
let has_caret = !gui_info.hwndCaret.is_invalid();
⋮----
pub fn to_wstring(s: &str) -> Vec<u16> {
s.encode_utf16().chain(std::iter::once(0)).collect()
⋮----
pub fn get_context_quote(text: &str) -> String {
let words: Vec<&str> = text.split_whitespace().collect();
let len = words.len();
⋮----
format!("\"... {}\"", words[len - 50..].join(" "))
⋮----
format!("\"... {}\"", words.join(" "))
⋮----
pub fn copy_to_clipboard(text: &str, hwnd: HWND) {
⋮----
if OpenClipboard(Some(hwnd)).is_ok() {
let _ = EmptyClipboard();
let wide_text: Vec<u16> = text.encode_utf16().chain(std::iter::once(0)).collect();
let mem_size = wide_text.len() * 2;
if let Ok(h_mem) = GlobalAlloc(GMEM_MOVEABLE, mem_size) {
let ptr = GlobalLock(h_mem) as *mut u16;
std::ptr::copy_nonoverlapping(wide_text.as_ptr(), ptr, wide_text.len());
let _ = GlobalUnlock(h_mem);
let h_mem_handle = HANDLE(h_mem.0);
let _ = SetClipboardData(13u32, Some(h_mem_handle));
⋮----
let _ = CloseClipboard();
⋮----
eprintln!("Failed to copy to clipboard after 5 attempts");
⋮----
pub fn copy_image_to_clipboard(image_bytes: &[u8]) {
⋮----
if img.write_to(&mut cursor, image::ImageFormat::Bmp).is_ok() {
if bmp_data.len() > 14 && bmp_data[0] == 0x42 && bmp_data[1] == 0x4D {
⋮----
if OpenClipboard(None).is_ok() {
⋮----
let mem_size = dib_data.len();
⋮----
let ptr = GlobalLock(h_mem) as *mut u8;
std::ptr::copy_nonoverlapping(dib_data.as_ptr(), ptr, mem_size);
⋮----
let _ = SetClipboardData(8, Some(h_mem_handle));
⋮----
let hdc = GetDC(None);
if !hdc.is_invalid() {
if dib_data.len() >= 4 {
⋮----
dib_data[0..4].try_into().unwrap_or([0; 4]),
⋮----
if (header_size as usize) < dib_data.len() {
⋮----
dib_data.as_ptr().add(header_size as usize);
⋮----
dib_data.as_ptr() as *const BITMAPINFOHEADER;
let pbmi = dib_data.as_ptr() as *const BITMAPINFO;
let hbitmap = CreateDIBitmap(
⋮----
Some(pbmih),
⋮----
Some(bits_ptr as *const std::ffi::c_void),
Some(pbmi),
⋮----
if !hbitmap.is_invalid() {
let _ = SetClipboardData(
⋮----
Some(HANDLE(hbitmap.0 as *mut _)),
⋮----
ReleaseDC(None, hdc);
⋮----
pub fn get_clipboard_image_bytes() -> Option<Vec<u8>> {
use windows::Win32::System::DataExchange::IsClipboardFormatAvailable;
⋮----
let has_dib = IsClipboardFormatAvailable(8).is_ok();
let has_dibv5 = IsClipboardFormatAvailable(17).is_ok();
⋮----
if let Ok(h_data) = GetClipboardData(format_to_try) {
let ptr = GlobalLock(HGLOBAL(h_data.0));
if !ptr.is_null() {
let size = GlobalSize(HGLOBAL(h_data.0));
⋮----
if dib_data.len() >= std::mem::size_of::<BITMAPINFOHEADER>() {
let header = &*(dib_data.as_ptr() as *const BITMAPINFOHEADER);
⋮----
let height = header.biHeight.abs();
⋮----
if dib_data.len() > pixel_offset {
⋮----
if px_start + bytes_per_pixel <= pixel_data.len() {
⋮----
rgba_buffer.push(r);
rgba_buffer.push(g);
rgba_buffer.push(b);
rgba_buffer.push(a);
⋮----
let _ = GlobalUnlock(HGLOBAL(h_data.0));
⋮----
.write_to(&mut cursor, image::ImageFormat::Png)
.is_ok()
⋮----
return Some(png_data);
⋮----
pub fn get_target_window_for_paste() -> Option<HWND> {
⋮----
if hwnd_foreground.is_invalid() {
⋮----
Some(hwnd_foreground)
⋮----
pub fn force_focus_and_paste(hwnd_target: HWND) {
⋮----
if IsWindow(Some(hwnd_target)).as_bool() {
let cur_thread = GetCurrentThreadId();
let target_thread = GetWindowThreadProcessId(hwnd_target, None);
⋮----
let _ = AttachThreadInput(cur_thread, target_thread, true);
let _ = SetForegroundWindow(hwnd_target);
let _ = BringWindowToTop(hwnd_target);
let _ = SetFocus(Some(hwnd_target));
let _ = AttachThreadInput(cur_thread, target_thread, false);
⋮----
if !is_text_input_focused() {
⋮----
.duration_since(UNIX_EPOCH)
.map(|d| d.as_millis() as u64)
.unwrap_or(0);
let last_error_ms = LAST_NO_CARET_ERROR_MS.load(Ordering::Relaxed);
if now_ms.saturating_sub(last_error_ms) >= NO_CARET_ERROR_COOLDOWN_MS {
LAST_NO_CARET_ERROR_MS.store(now_ms, Ordering::Relaxed);
let app = crate::APP.lock().unwrap();
let ui_lang = app.config.ui_language.clone();
⋮----
drop(app);
⋮----
let state = GetAsyncKeyState(vk as i32);
⋮----
wVk: VIRTUAL_KEY(vk),
⋮----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
⋮----
release_if_pressed(VK_MENU.0);
release_if_pressed(VK_SHIFT.0);
release_if_pressed(VK_LWIN.0);
release_if_pressed(VK_RWIN.0);
release_if_pressed(VK_CONTROL.0);
⋮----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(VK_V.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(VK_V.0, KEYEVENTF_KEYUP);
⋮----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
⋮----
pub fn type_text_to_window(hwnd_target_opt: Option<HWND>, text: &str) {
if text.is_empty() {
⋮----
let fg_window = GetForegroundWindow();
⋮----
if IsWindow(Some(hwnd)).as_bool() {
⋮----
if target_window.is_invalid() {
⋮----
let target_thread = GetWindowThreadProcessId(target_window, None);
⋮----
let _ = SetForegroundWindow(target_window);
⋮----
for c in text.chars() {
⋮----
dwFlags: KEYBD_EVENT_FLAGS(0),
⋮----
SendInput(&[input_down], std::mem::size_of::<INPUT>() as i32);
⋮----
SendInput(&[input_up], std::mem::size_of::<INPUT>() as i32);
⋮----
let encoded = c.encode_utf16(&mut buffer);
for utf16_val in encoded.iter() {
⋮----
wVk: VIRTUAL_KEY(0),
⋮----
pub fn get_error_message(error: &str, lang: &str, model_name: Option<&str>) -> String {
if error.starts_with("NO_API_KEY") {
let provider = if error.contains(':') {
let parts: Vec<&str> = error.split(':').collect();
if parts.len() > 1 {
⋮----
"vi" => format!("Bạn chưa nhập {} API key!", provider),
"ko" => format!("{} API 키를 입력하지 않았습니다!", provider),
"ja" => format!("{} APIキーが入力されていません!", provider),
"zh" => format!("您还没有输入 {} API key!", provider),
_ => format!("You haven't entered a {} API key!", provider),
⋮----
if error.starts_with("INVALID_API_KEY") {
⋮----
"vi" => format!("{} API key không hợp lệ!", provider),
"ko" => format!("{} API 키가 유효하지 않습니다!", provider),
"ja" => format!("{} APIキーが無効です!", provider),
"zh" => format!("{} API key 无效!", provider),
_ => format!("Invalid {} API key!", provider),
⋮----
if let Some(status_code) = extract_http_status_code(error) {
let provider = extract_provider_from_error(error);
return format_http_error(status_code, &provider, model_name, lang);
⋮----
"vi" => format!("Lỗi: {}", error),
"ko" => format!("오류: {}", error),
"ja" => format!("エラー: {}", error),
"zh" => format!("错误: {}", error),
_ => format!("Error: {}", error),
⋮----
fn extract_http_status_code(error: &str) -> Option<u16> {
if let Some(pos) = error.find("status code ") {
⋮----
let code_str: String = after.chars().take_while(|c| c.is_ascii_digit()).collect();
return code_str.parse().ok();
⋮----
let trimmed = error.trim();
if trimmed.len() >= 3 {
⋮----
.chars()
.rev()
.take(3)
⋮----
.collect();
if last_3.chars().all(|c| c.is_ascii_digit()) {
⋮----
if (400..=599).contains(&code) {
return Some(code);
⋮----
if error.contains(&code.to_string()) {
⋮----
fn extract_provider_from_error(error: &str) -> String {
if error.contains("api.groq.com") {
"Groq".to_string()
} else if error.contains("generativelanguage.googleapis.com") || error.contains("gemini") {
"Google Gemini".to_string()
} else if error.contains("api.openai.com") {
"OpenAI".to_string()
} else if error.contains("api.anthropic.com") || error.contains("claude") {
"Anthropic".to_string()
⋮----
"API".to_string()
⋮----
fn format_http_error(
⋮----
format!("{} ({})", model, provider)
⋮----
provider.to_string()
⋮----
"vi" => format!("Lỗi 429: Đã vượt quá hạn mức của mô hình {} (Rate Limit). Vui lòng chờ một lát rồi thử lại.", model_info),
"ko" => format!("오류 429: {} 모델의 요청 제한 초과 (Rate Limit). 잠시 후 다시 시도해 주세요.", model_info),
"ja" => format!("エラー 429: {} のレート制限を超えました。しばらくしてから再試行してください。", model_info),
"zh" => format!("错误 429: {} 模型请求超出限制 (Rate Limit)。请稍后再试。", model_info),
_ => format!("Error 429: Rate limit exceeded for model {}. Please wait a moment and try again.", model_info),
⋮----
"vi" => format!("Lỗi 400: Yêu cầu không hợp lệ đến {}. Vui lòng kiểm tra lại cài đặt.", model_info),
"ko" => format!("오류 400: {}에 대한 잘못된 요청입니다. 설정을 확인해 주세요.", model_info),
"ja" => format!("エラー 400: {} へのリクエストが無効です。設定を確認してください。", model_info),
"zh" => format!("错误 400: {} 请求无效。请检查设置。", model_info),
_ => format!("Error 400: Bad request to {}. Please check your settings.", model_info),
⋮----
"vi" => format!("Lỗi 401: API key của {} không hợp lệ hoặc đã hết hạn.", provider),
"ko" => format!("오류 401: {} API 키가 유효하지 않거나 만료되었습니다.", provider),
"ja" => format!("エラー 401: {} の API キーが無効または期限切れです。", provider),
"zh" => format!("错误 401: {} API 密钥无效或已过期。", provider),
_ => format!("Error 401: {} API key is invalid or expired.", provider),
⋮----
"vi" => format!("Lỗi 403: Không có quyền truy cập {}. Vui lòng kiểm tra API key.", provider),
"ko" => format!("오류 403: {}에 대한 접근 권한이 없습니다. API 키를 확인해 주세요.", provider),
"ja" => format!("エラー 403: {} へのアクセス権限がありません。API キーを確認してください。", provider),
"zh" => format!("错误 403: 无权访问 {}。请检查 API 密钥。", provider),
_ => format!("Error 403: Access forbidden to {}. Please check your API key.", provider),
⋮----
"vi" => format!("Lỗi 404: Không tìm thấy mô hình {} trên {}.", model_name.unwrap_or("này"), provider),
"ko" => format!("오류 404: {}에서 {} 모델을 찾을 수 없습니다.", provider, model_name.unwrap_or("해당")),
"ja" => format!("エラー 404: {} で {} が見つかりません。", provider, model_name.unwrap_or("このモデル")),
"zh" => format!("错误 404: 在 {} 上找不到模型 {}。", provider, model_name.unwrap_or("此")),
_ => format!("Error 404: Model {} not found on {}.", model_name.unwrap_or("this"), provider),
⋮----
"vi" => format!("Lỗi 500: Máy chủ {} gặp lỗi nội bộ. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 500: {} 서버 내부 오류입니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 500: {} サーバー内部エラー。後で再試行してください。", provider),
"zh" => format!("错误 500: {} 服务器内部错误。请稍后再试。", provider),
_ => format!("Error 500: {} internal server error. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 502: Bad Gateway - {} đang gặp sự cố. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 502: Bad Gateway - {}에 문제가 발생했습니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 502: Bad Gateway - {} に問題が発生しています。後で再試行してください。", provider),
"zh" => format!("错误 502: Bad Gateway - {} 遇到问题。请稍后再试。", provider),
_ => format!("Error 502: Bad Gateway - {} is having issues. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 503: Dịch vụ {} đang quá tải hoặc bảo trì. Vui lòng thử lại sau.", provider),
"ko" => format!("오류 503: {} 서비스가 과부하 상태이거나 점검 중입니다. 나중에 다시 시도해 주세요.", provider),
"ja" => format!("エラー 503: {} サービスが過負荷またはメンテナンス中です。後で再試行してください。", provider),
"zh" => format!("错误 503: {} 服务过载或维护中。请稍后再试。", provider),
_ => format!("Error 503: {} service is overloaded or under maintenance. Please try again later.", provider),
⋮----
"vi" => format!("Lỗi 504: Hết thời gian chờ phản hồi từ {}. Vui lòng thử lại.", model_info),
"ko" => format!("오류 504: {} 응답 시간 초과. 다시 시도해 주세요.", model_info),
"ja" => format!("エラー 504: {} からの応答がタイムアウトしました。再試行してください。", model_info),
"zh" => format!("错误 504: {} 响应超时。请重试。", model_info),
_ => format!("Error 504: Gateway timeout from {}. Please try again.", model_info),
⋮----
"vi" => format!("Lỗi {}: Có lỗi xảy ra với {} (HTTP {}).", status_code, model_info, status_code),
"ko" => format!("오류 {}: {}에서 오류가 발생했습니다 (HTTP {}).", status_code, model_info, status_code),
"ja" => format!("エラー {}: {} でエラーが発生しました (HTTP {}).", status_code, model_info, status_code),
"zh" => format!("错误 {}: {} 发生错误 (HTTP {}).", status_code, model_info, status_code),
_ => format!("Error {}: An error occurred with {} (HTTP {}).", status_code, model_info, status_code),
⋮----
pub fn is_retryable_error(error: &str) -> bool {
if error.contains("NO_API_KEY") || error.contains("INVALID_API_KEY") {
⋮----
if let Some(code) = extract_http_status_code(error) {
⋮----
let lower_err = error.to_lowercase();
if lower_err.contains("rate limit")
|| lower_err.contains("too many requests")
|| lower_err.contains("quota exceeded")
</file>

<file path="src/gui/app/logic.rs">
use crate::gui::app::utils::simple_rand;
⋮----
use crate::gui::locale::LocaleText;
use crate::icon_gen;
⋮----
use eframe::egui;
use std::sync::atomic::Ordering;
⋮----
use windows::Win32::Foundation::POINT;
⋮----
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
impl SettingsApp {
pub(crate) fn check_updater(&mut self) {
while let Ok(status) = self.update_rx.try_recv() {
⋮----
let ui_lang = self.config.ui_language.clone();
⋮----
format!("{} v{}", locale.update_available_notification, version);
⋮----
pub(crate) fn update_theme_and_tray(&mut self, ctx: &egui::Context) {
let now = ctx.input(|i| i.time);
⋮----
ctx.set_visuals(egui::Visuals::dark());
⋮----
ctx.set_visuals(egui::Visuals::light());
⋮----
let _ = tray.set_icon(Some(new_icon));
⋮----
use crate::api::realtime_audio::WM_THEME_UPDATE;
⋮----
use windows::Win32::UI::WindowsAndMessaging::PostMessageW;
let realtime_hwnd = std::ptr::addr_of!(REALTIME_HWND).read();
if !realtime_hwnd.is_invalid() {
⋮----
PostMessageW(Some(realtime_hwnd), WM_THEME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
let translation_hwnd = std::ptr::addr_of!(TRANSLATION_HWND).read();
if !translation_hwnd.is_invalid() {
let _ = PostMessageW(
Some(translation_hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
use crate::overlay::realtime_webview::state::APP_SELECTION_HWND;
let app_sel_val = APP_SELECTION_HWND.load(std::sync::atomic::Ordering::SeqCst);
⋮----
let _ = PostMessageW(Some(hwnd), WM_THEME_UPDATE, WPARAM(0), LPARAM(0));
⋮----
self.last_ui_language = self.config.ui_language.clone();
⋮----
self.tray_settings_item.set_text(new_locale.tray_settings);
self.tray_quit_item.set_text(new_locale.tray_quit);
⋮----
if self.tray_icon.is_none() {
⋮----
.with_tooltip("Screen Goated Toolbox (nganlinh4)")
.with_icon(icon)
.build()
⋮----
self.tray_icon = Some(tray);
⋮----
pub(crate) fn update_startup(&mut self, ctx: &egui::Context) {
⋮----
let _ = GetCursorPos(&mut cursor_pos);
let h_monitor = MonitorFromPoint(cursor_pos, MONITOR_DEFAULTTONEAREST);
⋮----
let _ = GetMonitorInfoW(h_monitor, &mut mi);
⋮----
let pixels_per_point = ctx.pixels_per_point();
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::OuterPosition(egui::pos2(
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::vec2(
⋮----
ctx.request_repaint();
⋮----
let has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
⋮----
updater.check_for_updates();
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(false));
⋮----
if self.splash.is_none() {
self.splash = Some(crate::gui::splash::SplashScreen::new(ctx));
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::Visible(true));
⋮----
fn on_splash_finished(&mut self) {
⋮----
pub(crate) fn update_bubble_sync(&mut self) {
let current_has_favorites = self.config.presets.iter().any(|p| p.is_favorite);
⋮----
.set_enabled(current_has_favorites);
⋮----
pub(crate) fn update_splash(&mut self, ctx: &egui::Context) {
⋮----
match splash.update(ctx) {
⋮----
self.on_splash_finished();
⋮----
pub(crate) fn check_restore_signal(&mut self, ctx: &egui::Context) {
if RESTORE_SIGNAL.swap(false, Ordering::SeqCst) {
self.restore_window(ctx);
⋮----
pub(crate) fn update_tips_logic(&mut self, ctx: &egui::Context) {
⋮----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
let display_duration = (2.0 + (current_tip.len() as f64 * 0.06)) as f32;
⋮----
// Fading In
self.tip_fade_state = (elapsed / fade_duration as f32).min(1.0);
⋮----
// Fully visible, wait for duration
⋮----
self.tip_is_fading_in = false; // Start fading out
self.tip_timer = now; // Reset timer for fade-out
⋮----
// Fading Out
self.tip_fade_state = (1.0 - (elapsed / fade_duration as f32)).max(0.0);
⋮----
// Switch to next random tip
self.rng_seed = simple_rand(self.rng_seed);
if !text.tips_list.is_empty() {
let next = (self.rng_seed as usize) % text.tips_list.len();
// Avoid repeating same tip if possible
if next == self.current_tip_idx && text.tips_list.len() > 1 {
self.current_tip_idx = (next + 1) % text.tips_list.len();
⋮----
self.tip_timer = now; // Reset timer
self.tip_is_fading_in = true; // Start fading in
⋮----
pub(crate) fn update_hotkey_recording(&mut self, ctx: &egui::Context) {
⋮----
ctx.input(|i| {
if i.key_pressed(egui::Key::Escape) {
⋮----
// Check Keyboard Events
⋮----
if let Some(vk) = egui_key_to_vk(key) {
if !matches!(vk, 16 | 17 | 18 | 91 | 92) {
⋮----
format!("{:?}", key).trim_start_matches("Key").to_string();
key_recorded = Some((vk, modifiers_bitmap, key_name));
⋮----
if key_recorded.is_none() {
⋮----
if i.pointer.button_pressed(btn) {
if let Some(vk) = egui_pointer_to_vk(&btn) {
⋮----
key_recorded = Some((vk, modifiers_bitmap, name));
⋮----
if let Some(msg) = self.check_hotkey_conflict(vk, mods, preset_idx) {
self.hotkey_conflict_msg = Some(msg);
⋮----
name_parts.push("Ctrl".to_string());
⋮----
name_parts.push("Alt".to_string());
⋮----
name_parts.push("Shift".to_string());
⋮----
name_parts.push("Win".to_string());
⋮----
name_parts.push(key_name);
⋮----
name: name_parts.join(" + "),
⋮----
if let Some(preset) = self.config.presets.get_mut(preset_idx) {
⋮----
.iter()
.any(|h| h.code == vk && h.modifiers == mods)
⋮----
preset.hotkeys.push(new_hotkey);
self.save_and_sync();
⋮----
pub(crate) fn handle_events(&mut self, ctx: &egui::Context) {
while let Ok(event) = self.event_rx.try_recv() {
⋮----
match menu_event.id.0.as_str() {
⋮----
.set_checked(self.config.show_favorite_bubble);
⋮----
pub(crate) fn handle_close_request(&mut self, ctx: &egui::Context) {
if ctx.input(|i| i.viewport().close_requested()) {
⋮----
ctx.send_viewport_cmd(egui::ViewportCommand::CancelClose);
</file>

<file path="src/gui/app/types.rs">
use crate::config::Config;
use crate::gui::settings_ui::node_graph::ChainNode;
use crate::gui::settings_ui::ViewMode;
⋮----
use auto_launch::AutoLaunch;
use eframe::egui;
use egui_snarl::Snarl;
use std::sync::atomic::AtomicBool;
use std::sync::mpsc::Receiver;
⋮----
pub enum UserEvent {
⋮----
pub struct SettingsApp {
</file>

<file path="src/gui/settings_ui/download_manager/detection.rs">
use super::types::CookieBrowser;
use std::collections::HashSet;
⋮----
use std::os::windows::process::CommandExt;
use std::path::PathBuf;
use std::process::Command;
pub fn detect_installed_browsers() -> Vec<CookieBrowser> {
let mut found = vec![CookieBrowser::None];
⋮----
found_set.insert(CookieBrowser::None);
⋮----
if !f_set.contains(&browser) {
f_set.insert(browser.clone());
f_list.push(browser);
⋮----
let hklm_exists = check_registry_key("HKLM", exe_name);
⋮----
add_if_new(browser.clone(), &mut found, &mut found_set);
⋮----
let hkcu_exists = check_registry_key("HKCU", exe_name);
⋮----
cmd.args(&["query", "HKLM\\SOFTWARE\\Clients\\StartMenuInternet"]);
⋮----
cmd.creation_flags(0x08000000);
let output = cmd.output();
⋮----
for line in stdout.lines() {
let lower = line.to_lowercase();
if lower.contains("chrome") {
add_if_new(CookieBrowser::Chrome, &mut found, &mut found_set);
} else if lower.contains("firefox") {
add_if_new(CookieBrowser::Firefox, &mut found, &mut found_set);
} else if lower.contains("edge") {
add_if_new(CookieBrowser::Edge, &mut found, &mut found_set);
} else if lower.contains("brave") {
add_if_new(CookieBrowser::Brave, &mut found, &mut found_set);
} else if lower.contains("opera") {
add_if_new(CookieBrowser::Opera, &mut found, &mut found_set);
} else if lower.contains("vivaldi") {
add_if_new(CookieBrowser::Vivaldi, &mut found, &mut found_set);
} else if lower.contains("chromium") {
add_if_new(CookieBrowser::Chromium, &mut found, &mut found_set);
} else if lower.contains("whale") {
add_if_new(CookieBrowser::Whale, &mut found, &mut found_set);
⋮----
if found_set.contains(&browser) {
⋮----
std::env::var("ProgramFiles").ok(),
std::env::var("ProgramFiles(x86)").ok(),
std::env::var("LocalAppData").ok(),
⋮----
for root in roots.iter().flatten() {
if PathBuf::from(root).join(sub_path).exists() {
⋮----
check_exe(
⋮----
check_exe(CookieBrowser::Firefox, &["Mozilla Firefox\\firefox.exe"]);
⋮----
fn check_registry_key(root: &str, exe_name: &str) -> bool {
let key = format!(
⋮----
cmd.args(&["query", &key, "/ve"]);
⋮----
Ok(o) => o.status.success(),
</file>

<file path="src/gui/settings_ui/global/mod.rs">
use super::node_graph::request_node_graph_view_reset;
use crate::config::Config;
⋮----
use crate::gui::locale::LocaleText;
⋮----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::collections::HashMap;
mod downloaded_tools;
mod tts_settings;
mod update_section;
mod usage_stats;
use crate::gui::settings_ui::download_manager::DownloadManager;
use downloaded_tools::render_downloaded_tools_modal;
use tts_settings::render_tts_settings_modal;
use update_section::render_update_section_content;
use usage_stats::render_usage_modal;
⋮----
pub fn render_global_settings(
⋮----
let is_dark = ui.visuals().dark_mode;
⋮----
ui.add_space(5.0);
⋮----
.fill(card_bg)
.stroke(card_stroke)
.inner_margin(12.0)
.corner_radius(10.0)
.show(ui, |ui| {
ui.horizontal(|ui| {
ui.label(
⋮----
.strong()
.size(14.0),
⋮----
ui.add_space(16.0);
⋮----
.checkbox(&mut config.use_groq, text.use_groq_checkbox)
.changed()
⋮----
.checkbox(&mut config.use_cerebras, text.use_cerebras_checkbox)
⋮----
.checkbox(&mut config.use_gemini, text.use_gemini_checkbox)
⋮----
.checkbox(&mut config.use_openrouter, text.use_openrouter_checkbox)
⋮----
if ui.checkbox(&mut config.use_ollama, "Ollama").changed() {
⋮----
ui.add_space(6.0);
⋮----
ui.label(text.groq_label);
if ui.link(text.get_key_link).clicked() {
⋮----
.add(
⋮----
.id(egui::Id::new("settings_api_key_groq"))
.password(!*show_api_key)
.desired_width(API_KEY_FIELD_WIDTH),
⋮----
if icon_button(ui, eye_icon).clicked() {
⋮----
ui.label(text.cerebras_api_key_label);
if ui.link(text.cerebras_get_key_link).clicked() {
⋮----
.id(egui::Id::new("settings_api_key_cerebras"))
.password(!*show_cerebras_api_key)
⋮----
ui.label(text.gemini_api_key_label);
if ui.link(text.gemini_get_key_link).clicked() {
⋮----
.id(egui::Id::new("settings_api_key_gemini"))
.password(!*show_gemini_api_key)
⋮----
ui.label(text.openrouter_api_key_label);
if ui.link(text.openrouter_get_key_link).clicked() {
⋮----
.id(egui::Id::new("settings_api_key_openrouter"))
.password(!*show_openrouter_api_key)
⋮----
ui.label("Ollama URL:");
if ui.link(text.ollama_url_guide).clicked() {
⋮----
.id(egui::Id::new("settings_api_key_ollama_url"))
⋮----
.ctx()
.memory(|mem| mem.data.get_temp::<String>(egui::Id::new("ollama_status")))
⋮----
ui.label(egui::RichText::new(&status).size(11.0));
⋮----
ui.add_space(10.0);
⋮----
egui::RichText::new(format!("📊 {}", text.usage_statistics_title))
.color(egui::Color32::WHITE)
.strong(),
⋮----
.fill(stats_bg)
.corner_radius(10.0),
⋮----
.on_hover_cursor(egui::CursorIcon::PointingHand)
.on_hover_text(text.usage_statistics_tooltip)
.clicked()
⋮----
egui::RichText::new(format!("🔊 {}", text.tts_settings_button))
⋮----
.fill(tts_bg)
⋮----
egui::RichText::new(format!("📦 {}", text.downloaded_tools_button))
⋮----
.fill(tools_bg)
⋮----
render_usage_modal(
⋮----
let ctx = ui.ctx().clone();
render_downloaded_tools_modal(&ctx, ui, show_tools_modal, download_manager, text);
if render_tts_settings_modal(ui, config, text, show_tts_modal) {
⋮----
render_update_section_content(ui, updater, update_status, text);
⋮----
.checkbox(&mut startup_toggle, text.startup_label)
⋮----
if let Some(exe_str) = exe_path.to_str() {
config.authorized_startup_path = exe_str.to_string();
⋮----
let _ = launcher.disable();
⋮----
let _ = launcher.enable();
⋮----
ui.indent("admin_indent", |ui| {
⋮----
if ui.checkbox(&mut is_admin_mode, checkbox_label).clicked() {
⋮----
ui.add_enabled_ui(false, |ui| {
ui.checkbox(&mut _is_admin_mode_disabled, checkbox_label);
⋮----
.size(11.0)
.color(egui::Color32::from_rgb(200, 100, 50)),
⋮----
.color(egui::Color32::from_rgb(34, 139, 34)),
⋮----
.checkbox(&mut config.start_in_tray, text.start_in_tray_label)
⋮----
ui.add_space(8.0);
⋮----
ui.label(text.graphics_mode_label);
let current_label = match config.ui_language.as_str() {
⋮----
.selected_text(current_label)
.show_ui(ui, |ui| {
⋮----
.selectable_label(
⋮----
config.graphics_mode = "standard".to_string();
⋮----
config.graphics_mode = "minimal".to_string();
⋮----
ui.add_space(40.0);
⋮----
egui::RichText::new(text.force_quit).color(egui::Color32::WHITE),
⋮----
.fill(quite_bg)
.corner_radius(8.0),
⋮----
.color(egui::Color32::WHITE),
⋮----
.fill(reset_bg)
⋮----
let saved_groq_key = config.api_key.clone();
let saved_gemini_key = config.gemini_api_key.clone();
let saved_openrouter_key = config.openrouter_api_key.clone();
let saved_cerebras_key = config.cerebras_api_key.clone();
let saved_language = config.ui_language.clone();
⋮----
let saved_ollama_base_url = config.ollama_base_url.clone();
⋮----
request_node_graph_view_reset(ui.ctx());
</file>

<file path="src/gui/utils.rs">
use eframe::egui;
⋮----
use std::os::windows::process::CommandExt;
use std::process::Command;
use windows::core::w;
⋮----
use windows::Win32::UI::Controls::MARGINS;
⋮----
use windows_core::BOOL;
struct MonitorEnumContext {
⋮----
unsafe extern "system" fn monitor_enum_proc(
⋮----
if GetMonitorInfoW(hmonitor, &mut mi as *mut _ as *mut _).as_bool() {
⋮----
let trimmed_name = device_name.trim_matches(char::from(0)).to_string();
context.monitors.push(trimmed_name);
⋮----
pub fn get_monitor_names() -> Vec<String> {
⋮----
let _ = EnumDisplayMonitors(
⋮----
Some(monitor_enum_proc),
LPARAM(&mut ctx as *mut _ as isize),
⋮----
pub fn copy_to_clipboard_text(text: &str) {
⋮----
pub fn is_running_as_admin() -> bool {
⋮----
if OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &mut h_token).is_ok() {
⋮----
if GetTokenInformation(
⋮----
Some(&mut elevation as *mut _ as *mut std::ffi::c_void),
⋮----
.is_ok()
⋮----
pub fn is_system_in_dark_mode() -> bool {
⋮----
use winreg::RegKey;
⋮----
hkcu.open_subkey("Software\\Microsoft\\Windows\\CurrentVersion\\Themes\\Personalize")
⋮----
pub fn configure_fonts(ctx: &egui::Context) {
⋮----
fonts.font_data.insert(
gs_font_name.to_owned(),
⋮----
let windir = std::env::var("WINDIR").unwrap_or_else(|_| "C:\\Windows".to_string());
let font_dir = std::path::Path::new(&windir).join("Fonts");
let viet_font_path = font_dir.join("segoeui.ttf");
let viet_fallback_path = font_dir.join("arial.ttf");
let viet_data = std::fs::read(&viet_font_path).or_else(|_| std::fs::read(&viet_fallback_path));
⋮----
let korean_font_path = font_dir.join("malgun.ttf");
⋮----
viet_font_name.to_owned(),
⋮----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Proportional) {
vec.insert(0, viet_font_name.to_owned());
⋮----
if let Some(vec) = fonts.families.get_mut(&egui::FontFamily::Monospace) {
⋮----
korean_font_name.to_owned(),
⋮----
let idx = if vec.contains(&viet_font_name.to_string()) {
⋮----
vec.insert(idx, korean_font_name.to_owned());
⋮----
vec.insert(0, gs_font_name.to_owned());
⋮----
ctx.set_fonts(fonts);
⋮----
pub fn set_admin_startup(enable: bool) -> bool {
⋮----
let exe_str = match exe_path.to_str() {
⋮----
if exe_str.is_empty() {
⋮----
cmd.args(&[
⋮----
&format!("\"{}\"", exe_str),
⋮----
cmd.creation_flags(0x08000000);
let output = cmd.output();
⋮----
Ok(o) => o.status.success(),
⋮----
cmd.args(&["/delete", "/tn", TASK_NAME, "/f"]);
⋮----
pub fn is_admin_startup_enabled() -> bool {
⋮----
cmd.args(&["/query", "/tn", TASK_NAME]);
⋮----
is_admin_startup_pointing_to_current_exe()
⋮----
pub fn is_admin_startup_pointing_to_current_exe() -> bool {
⋮----
cmd.args(&["/query", "/tn", TASK_NAME, "/xml"]);
⋮----
if let Ok(output) = cmd.output() {
if output.status.success() {
⋮----
return xml_content.to_lowercase().contains(&exe_str.to_lowercase());
⋮----
fn rgba_to_bgra(data: &[u8]) -> Vec<u8> {
let mut bgra = data.to_vec();
for chunk in bgra.chunks_exact_mut(4) {
chunk.swap(0, 2);
⋮----
unsafe fn create_hicon_from_bytes(bytes: &[u8], target_w: i32, target_h: i32) -> Option<HANDLE> {
let img = image::load_from_memory(bytes).ok()?;
let resized = img.resize_exact(
⋮----
let rgba = resized.to_rgba8();
let bgra_data = rgba_to_bgra(rgba.as_raw());
⋮----
let mask_bits = vec![0u8; mask_len];
let hicon_result = CreateIcon(
⋮----
mask_bits.as_ptr(),
bgra_data.as_ptr(),
⋮----
if hicon.is_invalid() {
⋮----
Some(std::mem::transmute::<_, HANDLE>(hicon))
⋮----
pub fn set_window_icon(hwnd: HWND, is_dark_mode: bool) {
⋮----
include_bytes!("../../assets/app-icon-small.png")
⋮----
include_bytes!("../../assets/app-icon-small-light.png")
⋮----
if !hwnd.is_invalid() {
let small_w = GetSystemMetrics(SM_CXSMICON);
let small_h = GetSystemMetrics(SM_CYSMICON);
let big_w = GetSystemMetrics(SM_CXICON);
let big_h = GetSystemMetrics(SM_CYICON);
if let Some(hicon_small) = create_hicon_from_bytes(icon_bytes, small_w, small_h) {
⋮----
Some(hwnd),
⋮----
WPARAM(ICON_SMALL as usize),
LPARAM(hicon_small.0 as isize),
⋮----
if let Some(hicon_big) = create_hicon_from_bytes(icon_bytes, big_w, big_h) {
⋮----
WPARAM(ICON_BIG as usize),
LPARAM(hicon_big.0 as isize),
⋮----
pub fn update_window_icon_native(is_dark_mode: bool) {
⋮----
let class_name = w!("eframe");
let title_name = w!("Screen Goated Toolbox (SGT by nganlinh4)");
let mut hwnd = FindWindowW(class_name, title_name).unwrap_or_default();
if hwnd.is_invalid() {
hwnd = FindWindowW(None, title_name).unwrap_or_default();
⋮----
set_window_icon(hwnd, is_dark_mode);
apply_window_shadow_native(hwnd);
⋮----
pub fn apply_window_shadow_native(hwnd: HWND) {
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let _ = SetWindowPos(
</file>

<file path="src/overlay/process/pipeline.rs">
use crate::win_types::SendHwnd;
⋮----
use crate::model_config::model_is_non_llm;
use crate::overlay::preset_wheel;
⋮----
use crate::overlay::text_input;
⋮----
use super::types::generate_chain_id;
use super::window::create_processing_window;
⋮----
pub fn start_text_processing(
⋮----
.first()
.map(|b| b.prompt.as_str())
.unwrap_or("");
// Also check if model is non-LLM (doesn't use prompts)
⋮----
.map(|b| b.model.as_str())
⋮----
let guide_text = if first_block_prompt.is_empty() || model_is_non_llm(first_block_model) {
⋮----
format!("{}...", localized_preset_name)
⋮----
let config_shared = Arc::new(config.clone());
let preset_shared = Arc::new(preset.clone());
let ui_lang = config.ui_language.clone();
// For MASTER presets: always keep window open initially (continuous_mode=true)
// We'll decide whether to close based on the SELECTED preset after wheel selection
⋮----
// For continuous mode: store the previous chain's cancellation token so we can close old windows
⋮----
let last_cancel_token_clone = last_cancel_token.clone();
// Check if this is a MASTER preset
⋮----
// CRITICAL: For MASTER presets, store the selected preset index after first wheel selection.
// Subsequent Enter presses will use this stored preset directly (no wheel).
// The text input window "transfers" to the selected preset.
⋮----
let selected_preset_idx_clone = selected_preset_idx.clone();
*LAST_RESULT_RECT.lock().unwrap() = None;
⋮----
let already_selected = selected_preset_idx_clone.lock().unwrap().clone();
⋮----
let app = crate::APP.lock().unwrap();
let p = app.config.presets[preset_idx].clone();
let c = app.config.clone();
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
preset_wheel::show_preset_wheel("text", Some("type"), cursor_pos);
⋮----
*selected_preset_idx_clone.lock().unwrap() = Some(idx);
⋮----
let mut app = crate::APP.lock().unwrap();
⋮----
let p = app.config.presets[idx].clone();
⋮----
.map(|h| h.name.clone())
.unwrap_or_default();
let new_guide_text = if !hk_name.is_empty() {
format!("{} [{}]", localized_name, hk_name)
⋮----
(*preset_shared).clone(),
(*config_shared).clone(),
⋮----
let _ = PostMessageW(Some(input_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
if let Ok(token_guard) = last_cancel_token_clone.lock() {
⋮----
let h_monitor = MonitorFromRect(&input_rect, MONITOR_DEFAULTTONEAREST);
⋮----
if GetMonitorInfoW(h_monitor, &mut mi).as_bool() {
⋮----
right: GetSystemMetrics(SM_CXSCREEN),
bottom: GetSystemMetrics(SM_CYSCREEN),
⋮----
if let Some(last_rect) = LAST_RESULT_RECT.lock().unwrap().clone() {
⋮----
*LAST_RESULT_RECT.lock().unwrap() = Some(final_rect);
⋮----
let last_token_update = last_cancel_token_clone.clone();
let input_hwnd_send = SendHwnd(input_hwnd);
⋮----
if let Ok(mut token_guard) = last_token_update.lock() {
*token_guard = Some(new_token.clone());
⋮----
execute_chain_pipeline_with_token(
⋮----
Some(input_hwnd_send),
⋮----
let guide_text = localized_preset_name.clone();
⋮----
let mut modified_preset = (*preset).clone();
if let Some(block0) = modified_preset.blocks.get_mut(0) {
if block0.prompt.is_empty() {
block0.prompt = user_prompt.clone();
⋮----
format!("{}\n\nUser request: {}", block0.prompt, user_prompt);
⋮----
let config_clone = (*config).clone();
let initial_text_clone = (*initial_text).clone();
⋮----
execute_chain_pipeline(
⋮----
pub fn show_audio_result(
⋮----
app.config.clone()
⋮----
windows::Win32::UI::WindowsAndMessaging::IsWindow(Some(recording_hwnd)).as_bool()
⋮----
Some(recording_hwnd)
⋮----
let chain_id = generate_chain_id();
run_chain_step(
⋮----
preset.blocks.clone(),
preset.block_connections.clone(),
⋮----
processing_hwnd.map(SendHwnd),
⋮----
preset.id.clone(),
⋮----
pub fn start_processing_pipeline(
⋮----
if preset.prompt_mode == "dynamic" && !preset.blocks.is_empty() {
⋮----
let _ = cropped_img.write_to(
⋮----
let guide_text = format!("{}...", localized_name);
⋮----
.iter_mut()
.find(|b| b.block_type != "input_adapter")
⋮----
if target_block.prompt.is_empty() {
target_block.prompt = user_prompt.clone();
⋮----
format!("{}\n\nUser request: {}", target_block.prompt, user_prompt);
⋮----
let context = RefineContext::Image((*png_data).clone());
⋮----
let graphics_mode = config_clone.graphics_mode.clone();
⋮----
unsafe { create_processing_window(screen_rect, graphics_mode) };
⋮----
SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let blocks = modified_preset.blocks.clone();
let connections = modified_preset.block_connections.clone();
let preset_id = modified_preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
⋮----
Some(processing_hwnd_send),
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
⋮----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(screen_rect, graphics_mode) };
⋮----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
⋮----
let processing_hwnd = HWND(processing_hwnd_val as *mut std::ffi::c_void);
⋮----
Some(SendHwnd(processing_hwnd)),
⋮----
pub fn start_processing_pipeline_parallel(
⋮----
if let Ok(Some((img, _))) = rx.recv() {
start_processing_pipeline(img, screen_rect, config, preset);
⋮----
if let Ok(Some((_cropped_img, original_bytes))) = rx.recv() {
⋮----
let _ = PostMessageW(Some(processing_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
</file>

<file path="src/overlay/prompt_dj/mod.rs">
use std::borrow::Cow;
use std::num::NonZeroIsize;
⋮----
use windows::Win32::Graphics::Gdi::HBRUSH;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::System::Threading::GetCurrentProcessId;
⋮----
use crate::win_types::SendHwnd;
⋮----
static mut PDJ_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
thread_local! {
⋮----
const INDEX_HTML: &[u8] = include_bytes!("dist/index.html");
const ASSET_INDEX_JS: &[u8] = include_bytes!("dist/assets/index.js");
const ASSET_INDEX_CSS: &[u8] = include_bytes!("dist/assets/index.css");
const ASSET_CUBIC_JS: &[u8] = include_bytes!("dist/assets/cubic.js");
const ASSET_MORPH_JS: &[u8] = include_bytes!("dist/assets/morph-fixed.js");
const ASSET_ROUNDED_JS: &[u8] = include_bytes!("dist/assets/roundedPolygon.js");
const ASSET_UTILS_JS: &[u8] = include_bytes!("dist/assets/utils.js");
⋮----
fn update_child_pids() {
let current_pid = unsafe { GetCurrentProcessId() };
⋮----
use std::os::windows::process::CommandExt;
⋮----
cmd.args(&["process", "get", "ProcessId,ParentProcessId", "/format:csv"]);
⋮----
cmd.creation_flags(0x08000000);
let output = cmd.output();
⋮----
for line in s.lines() {
if line.trim().is_empty() {
⋮----
let parts: Vec<&str> = line.split(',').collect();
if parts.len() >= 3 {
⋮----
parts[1].trim().parse::<u32>(),
parts[2].trim().parse::<u32>(),
⋮----
tree.entry(ppid).or_insert_with(Vec::new).push(pid);
⋮----
let mut queue = vec![current_pid];
⋮----
visited.insert(current_pid);
while let Some(pid) = queue.pop() {
if let Some(children) = tree.get(&pid) {
⋮----
if visited.insert(child) {
descendants.push(child);
queue.push(child);
⋮----
if let Ok(mut lock) = CHILD_PIDS.lock() {
⋮----
unsafe fn set_app_volume(volume: f32) -> Result<()> {
let current_pid = GetCurrentProcessId();
let child_pids = CHILD_PIDS.lock().unwrap_or_else(|e| e.into_inner()).clone();
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
⋮----
CoCreateInstance(&MMDeviceEnumerator, None, CLSCTX_ALL)?;
let device = device_enumerator.GetDefaultAudioEndpoint(eRender, eMultimedia)?;
let session_manager: IAudioSessionManager2 = device.Activate(CLSCTX_ALL, None)?;
let session_enumerator = session_manager.GetSessionEnumerator()?;
let count = session_enumerator.GetCount()?;
⋮----
if let Ok(session_control) = session_enumerator.GetSession(i) {
⋮----
if let Ok(pid) = session_control2.GetProcessId() {
if pid == current_pid || child_pids.contains(&pid) {
⋮----
let _ = simple_volume.SetMasterVolume(volume, std::ptr::null());
⋮----
Ok(())
⋮----
unsafe extern "system" fn pdj_wnd_proc(
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.gemini_api_key.clone(),
app.config.ui_language.clone(),
app.config.theme_mode.clone(),
⋮----
PDJ_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
LRESULT(0)
⋮----
.evaluate_script("window.postMessage({ type: 'pm-dj-stop-audio' }, '*')");
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
⋮----
PostQuitMessage(0);
⋮----
WM_ERASEBKGND => LRESULT(1),
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
let _ = GetClientRect(hwnd, &mut r);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
⋮----
return Err(HandleError::Unavailable);
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
fn wnd_http_response(
⋮----
.status(status)
.header("Content-Type", content_type)
.header("Access-Control-Allow-Origin", "*")
.body(body)
.unwrap_or_else(|_| {
⋮----
.status(500)
.body(Cow::Borrowed(b"Internal Error".as_slice()))
.unwrap()
⋮----
pub fn show_prompt_dj() {
⋮----
// Initialize on-demand if not warmed up
⋮----
internal_create_pdj_loop();
⋮----
// Polling thread to auto-show once ready
⋮----
// Poll for 10 seconds (100 * 100ms)
⋮----
let hwnd_wrapper = std::ptr::addr_of!(PDJ_HWND).read();
if IS_WARMED_UP && !hwnd_wrapper.is_invalid() {
⋮----
PostMessageW(Some(hwnd_wrapper.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
if !hwnd_wrapper.is_invalid() {
let _ = PostMessageW(Some(hwnd_wrapper.0), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
pub fn update_settings() {
⋮----
if !std::ptr::addr_of!(PDJ_HWND).read().is_invalid() {
let _ = PostMessageW(
Some(PDJ_HWND.0),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
unsafe fn internal_create_pdj_loop() {
// 1. Create Window
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("PromptDJ_Class_Persistent");
REGISTER_PDJ_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(pdj_wnd_proc);
wc.hInstance = instance.into();
⋮----
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
wc.hbrBackground = HBRUSH(std::ptr::null_mut()); // Transparent background
let _ = RegisterClassW(&wc);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
// Adaptive sizing based on screen aspect ratio:
// - Width: Use 70% of screen width, capped between 1200 and 1600 pixels
// - Height: Scales inversely with aspect ratio for consistent UI appearance
//   - At 16:9 (1.78:1): ~72% of screen height → 775px on 1080p
//   - At 21:9 (2.37:1): ~60% of screen height → 650px on 1080p ultrawide
⋮----
let base_aspect = 16.0 / 9.0; // 1.778
let height_pct = (0.72 - (aspect_ratio - base_aspect) * 0.20).clamp(0.50, 0.80);
let width = ((screen_w as f64 * 0.70) as i32).clamp(1200, 1600);
let height = ((screen_h as f64 * height_pct) as i32).clamp(550, 900);
⋮----
let hwnd = CreateWindowExW(
⋮----
PCWSTR(title_wide.as_ptr()),
WS_POPUP | WS_THICKFRAME | WS_MINIMIZEBOX | WS_SYSMENU, // Start hidden (no WS_VISIBLE)
⋮----
Some(instance.into()),
⋮----
.unwrap();
PDJ_HWND = SendHwnd(hwnd);
// Enable rounded corners
⋮----
let _ = DwmSetWindowAttribute(
⋮----
// Set Window Icon
⋮----
// 2. Create WebView
let wrapper = HwndWrapper(hwnd);
⋮----
let init_script = format!(
⋮----
PDJ_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = PDJ_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let mut builder = WebViewBuilder::new_with_web_context(ctx_ref.as_mut().unwrap())
.with_custom_protocol("promptdj".to_string(), move |_id, request| {
let path = request.uri().path();
⋮----
} else if path.ends_with("index.js") {
⋮----
} else if path.ends_with("index.css") {
⋮----
} else if path.ends_with("cubic.js") {
⋮----
} else if path.ends_with("morph-fixed.js") {
⋮----
} else if path.ends_with("roundedPolygon.js") {
⋮----
} else if path.ends_with("utils.js") {
⋮----
return wnd_http_response(
⋮----
Cow::Borrowed(b"Not Found".as_slice()),
⋮----
wnd_http_response(200, mime, content)
⋮----
.with_initialization_script(&init_script)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body().as_str();
⋮----
let _ = ReleaseCapture();
let _ = SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
let _ = ShowWindow(hwnd_ipc, SW_MINIMIZE);
⋮----
let _ = ShowWindow(hwnd_ipc, SW_HIDE);
} else if body.starts_with("set_volume:") {
if let Ok(val) = body.trim_start_matches("set_volume:").parse::<f32>() {
let _ = set_app_volume(val);
⋮----
.with_url("promptdj://localhost/index.html");
⋮----
builder.build_as_child(&wrapper)
⋮----
eprintln!("Failed to create PromptDJ WebView: {:?}", e);
let _ = DestroyWindow(hwnd);
⋮----
let _ = webview_arc.set_bounds(Rect {
⋮----
*wv.borrow_mut() = Some(webview_arc);
⋮----
update_child_pids();
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
*wv.borrow_mut() = None;
</file>

<file path="src/overlay/realtime_webview/webview.rs">
use crate::api::realtime_audio::WM_COPY_TEXT;
⋮----
use crate::config::get_all_languages;
use crate::gui::locale::LocaleText;
use crate::overlay::realtime_html::get_realtime_html;
use crate::APP;
use std::sync::atomic::Ordering;
⋮----
pub fn create_realtime_webview(
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
let languages = get_all_languages();
⋮----
let app = APP.lock().unwrap();
let lang = app.config.ui_language.clone();
⋮----
let is_dark = if let Ok(app) = crate::APP.lock() {
⋮----
let html = get_realtime_html(
⋮----
let wrapper = HwndWrapper(hwnd);
⋮----
REALTIME_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(wry::WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = REALTIME_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| format!("data:text/html,{}", urlencoding::encode(&html)));
⋮----
.with_bounds(Rect {
⋮----
.with_url(&page_url)
.with_transparent(false)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
} else if body.starts_with("toggleMic:") {
⋮----
MIC_VISIBLE.store(visible, Ordering::SeqCst);
⋮----
if !std::ptr::addr_of!(REALTIME_HWND).read().is_invalid() {
⋮----
update_webview_theme(REALTIME_HWND);
⋮----
let _ = ShowWindow(
⋮----
sync_visibility_to_webviews();
if !MIC_VISIBLE.load(Ordering::SeqCst)
&& !TRANS_VISIBLE.load(Ordering::SeqCst)
⋮----
REALTIME_STOP_SIGNAL.store(true, Ordering::SeqCst);
crate::api::tts::TTS_MANAGER.stop();
⋮----
let _ = PostMessageW(
Some(REALTIME_HWND),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
} else if body.starts_with("toggleTrans:") {
⋮----
TRANS_VISIBLE.store(visible, Ordering::SeqCst);
⋮----
if !std::ptr::addr_of!(TRANSLATION_HWND).read().is_invalid() {
⋮----
update_webview_theme(TRANSLATION_HWND);
⋮----
Some(TRANSLATION_HWND),
⋮----
} else if body.starts_with("groupDragMove:") {
⋮----
if let Some((dx_str, dy_str)) = coords.split_once(',') {
⋮----
let _ = GetWindowRect(REALTIME_HWND, &mut rect);
let _ = SetWindowPos(
⋮----
let _ = GetWindowRect(TRANSLATION_HWND, &mut rect);
⋮----
} else if body.starts_with("copyText:") {
let text = body[9..].to_string();
⋮----
Some(hwnd_for_ipc),
⋮----
LPARAM(ptr as isize),
⋮----
PostMessageW(Some(hwnd_for_ipc), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = GetWindowRect(hwnd_for_ipc, &mut rect);
⋮----
let mut app = APP.lock().unwrap();
⋮----
} else if body.starts_with("fontSize:") {
⋮----
} else if body.starts_with("audioSource:") {
let source = body[12..].to_string();
if let Ok(mut new_source) = NEW_AUDIO_SOURCE.lock() {
*new_source = source.clone();
⋮----
SELECTED_APP_PID.store(0, Ordering::SeqCst);
if let Ok(mut name) = SELECTED_APP_NAME.lock() {
name.clear();
⋮----
let tts_enabled = REALTIME_TTS_ENABLED.load(Ordering::SeqCst);
⋮----
show_app_selection_popup();
⋮----
AUDIO_SOURCE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("language:") {
let lang = body[9..].to_string();
if let Ok(mut new_lang) = NEW_TARGET_LANGUAGE.lock() {
*new_lang = lang.clone();
⋮----
LANGUAGE_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("translationModel:") {
let model = body[17..].to_string();
if let Ok(mut new_model) = NEW_TRANSLATION_MODEL.lock() {
*new_model = model.clone();
⋮----
TRANSLATION_MODEL_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("transcriptionModel:") {
let model = body[19..].to_string();
if let Ok(mut new_model) = NEW_TRANSCRIPTION_MODEL.lock() {
⋮----
TRANSCRIPTION_MODEL_CHANGE.store(true, Ordering::SeqCst);
} else if body.starts_with("resize:") {
⋮----
let new_width = (rect.right - rect.left + dx).max(200);
let new_height = (rect.bottom - rect.top + dy).max(100);
⋮----
} else if body.starts_with("ttsEnabled:") {
⋮----
REALTIME_TTS_ENABLED.store(enabled, Ordering::SeqCst);
⋮----
let popup_hwnd_val = APP_SELECTION_HWND.load(Ordering::SeqCst);
⋮----
Some(popup_hwnd),
⋮----
APP_SELECTION_HWND.store(0, Ordering::SeqCst);
⋮----
LAST_SPOKEN_LENGTH.store(0, Ordering::SeqCst);
if let Ok(mut queue) = COMMITTED_TRANSLATION_QUEUE.lock() {
queue.clear();
⋮----
app.config.realtime_audio_source.clone()
⋮----
} else if body.starts_with("ttsSpeed:") {
⋮----
REALTIME_TTS_SPEED.store(speed, Ordering::SeqCst);
REALTIME_TTS_AUTO_SPEED.store(false, Ordering::SeqCst);
⋮----
} else if body.starts_with("ttsAutoSpeed:") {
⋮----
REALTIME_TTS_AUTO_SPEED.store(enabled, Ordering::SeqCst);
⋮----
.build_as_child(&wrapper)
⋮----
REALTIME_WEBVIEWS.with(|wvs| {
wvs.borrow_mut().insert(hwnd_key, webview);
⋮----
pub fn destroy_realtime_webview(hwnd: HWND) {
⋮----
wvs.borrow_mut().remove(&hwnd_key);
⋮----
pub fn sync_visibility_to_webviews() {
let mic_vis = MIC_VISIBLE.load(Ordering::SeqCst);
let trans_vis = TRANS_VISIBLE.load(Ordering::SeqCst);
let script = format!(
⋮----
for webview in wvs.borrow().values() {
let _ = webview.evaluate_script(&script);
⋮----
pub fn update_webview_text(hwnd: HWND, old_text: &str, new_text: &str) {
⋮----
fn escape_js(text: &str) -> String {
text.replace('\\', "\\\\")
.replace('\'', "\\'")
.replace('\n', "\\n")
.replace('\r', "")
⋮----
let escaped_old = escape_js(old_text);
let escaped_new = escape_js(new_text);
let script = format!("window.updateText('{}', '{}');", escaped_old, escaped_new);
⋮----
if let Some(webview) = wvs.borrow().get(&hwnd_key) {
⋮----
/// Clear/reset the WebView text to initial "Đang chờ nói..." state
pub fn clear_webview_text(hwnd: HWND) {
⋮----
pub fn clear_webview_text(hwnd: HWND) {
⋮----
let _ = webview.evaluate_script(script);
⋮----
use super::app_selection::show_app_selection_popup;
pub fn update_webview_theme(hwnd: HWND) {
⋮----
let font_size = if let Ok(app) = crate::APP.lock() {
⋮----
// Determine glow color based on whether this is a translation window
⋮----
let css = format!(
⋮----
let css_escaped = css.replace("`", "\\`");
</file>

<file path="src/overlay/recording.rs">
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::Win32::UI::Controls::MARGINS;
⋮----
pub fn update_audio_viz(rms: f32) {
let bits = rms.to_bits();
CURRENT_RMS.store(bits, Ordering::Relaxed);
⋮----
thread_local! {
⋮----
fn get_ui_dimensions() -> (i32, i32) {
⋮----
let screen_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let screen_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
⋮----
let width = (450.0 - (aspect_ratio - base_aspect) * 127.0).clamp(350.0, 500.0) as i32;
⋮----
pub fn is_recording_overlay_active() -> bool {
RECORDING_STATE.load(Ordering::SeqCst) == 2
⋮----
pub fn stop_recording_and_submit() {
if is_recording_overlay_active() {
let was_stopped = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
⋮----
AUDIO_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd_val = RECORDING_HWND_VAL.load(Ordering::SeqCst);
⋮----
let hwnd = HWND(hwnd_val as *mut _);
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
AUDIO_STOP_SIGNAL.store(true, Ordering::SeqCst);
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_UPDATE_STATE, WPARAM(0), LPARAM(0));
⋮----
pub fn warmup_recording_overlay() {
⋮----
.compare_exchange(0, 1, Ordering::SeqCst, Ordering::SeqCst)
.is_ok()
⋮----
internal_create_recording_window();
⋮----
pub fn show_recording_overlay(preset_idx: usize) {
let current = RECORDING_STATE.load(Ordering::SeqCst);
if current == 0 || (current == 1 && RECORDING_HWND_VAL.load(Ordering::SeqCst) == 0) {
⋮----
RECORDING_STATE.store(0, Ordering::SeqCst);
⋮----
warmup_recording_overlay();
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
⋮----
if RECORDING_HWND_VAL.load(Ordering::SeqCst) != 0 {
⋮----
let hwnd = HWND(RECORDING_HWND_VAL.load(Ordering::SeqCst) as *mut _);
⋮----
PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(preset_idx), LPARAM(0));
⋮----
AUDIO_STOP_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_PAUSE_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_ABORT_SIGNAL.store(false, Ordering::SeqCst);
AUDIO_WARMUP_COMPLETE.store(false, Ordering::SeqCst);
CURRENT_RMS.store(0, Ordering::Relaxed);
⋮----
let _ = PostMessageW(
Some(HWND(hwnd_val as *mut _)),
⋮----
WPARAM(preset_idx),
LPARAM(0),
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
fn internal_create_recording_window() {
⋮----
let coinit = CoInitialize(None); // Required for WebView
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_Recording_Persistent");
REGISTER_RECORDING_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(recording_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
RegisterClassW(&wc);
⋮----
// Get adaptive UI dimensions
let (ui_width, ui_height) = get_ui_dimensions();
// Create window OFF-SCREEN initially (-4000, -4000)
// WS_POPUP | WS_VISIBLE (so WebView renders) but off-screen.
// Using Layered window for transparency
let hwnd = CreateWindowExW(
⋮----
w!("SGT Recording Web"),
⋮----
Some(instance.into()),
⋮----
.unwrap();
⋮----
RECORDING_HWND_VAL.store(hwnd.0 as isize, Ordering::SeqCst);
// Windows 11 Rounded Corners - Disable native rounding to hide native border/shadow
// We rely on CSS for rounded corners + transparency
let corner_pref = 1u32; // DWMWCP_DONOTROUND
let _ = DwmSetWindowAttribute(
⋮----
// Glass Frame Extension (critical for per-pixel alpha with WebView)
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
// --- WEBVIEW CREATION ---
let wrapper = HwndWrapper(hwnd);
let html = generate_html();
RECORDING_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
// LOCK SCOPE: Serialized build to prevent resource contention
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = RECORDING_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let mut builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
// Store HTML in font server and get URL for same-origin font loading
⋮----
crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| {
format!("data:text/html,{}", urlencoding::encode(&html))
⋮----
.with_bounds(Rect {
⋮----
.with_transparent(true)
.with_background_color((0, 0, 0, 0)) // Fully transparent background
.with_url(&page_url)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let hwnd = HWND(ipc_hwnd_val as *mut std::ffi::c_void);
let body = msg.body().as_str();
⋮----
let paused = AUDIO_PAUSE_SIGNAL.load(Ordering::SeqCst);
AUDIO_PAUSE_SIGNAL.store(!paused, Ordering::SeqCst);
⋮----
// Handshake: WebView is ready (from resetState), so now we can REAL_SHOW
// Kill fallback timer 99
let _ = KillTimer(Some(hwnd), 99);
// Add a tiny delay to ensure paint catch-up
if !CURRENT_RECORDING_HIDDEN.load(Ordering::SeqCst) {
let _ = SetTimer(Some(hwnd), 2, 20, None);
⋮----
let _ = ReleaseCapture();
⋮----
Some(hwnd),
⋮----
WPARAM(2 as usize), // HTCAPTION = 2
LPARAM(0 as isize),
⋮----
.build(&wrapper)
⋮----
RECORDING_WEBVIEW.with(|cell| *cell.borrow_mut() = Some(wv));
// Setup Global Key Hook for ESC (This needs to be persistent or installed/uninstalled on show/hide)
// Better to install once and check `is_recording_overlay_active()` inside hook.
let hook = SetWindowsHookExW(
⋮----
Some(recording_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
// Message Loop
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
let _ = UnhookWindowsHookEx(h);
⋮----
// Cleanup on FULL EXIT
RECORDING_WEBVIEW.with(|cell| *cell.borrow_mut() = None);
⋮----
let _ = CoUninitialize();
⋮----
fn start_audio_thread(hwnd: HWND, preset_idx: usize) {
⋮----
let app = APP.lock().unwrap();
⋮----
app.config.presets[preset_idx].clone(),
app.last_active_window, // Keep as SendHwnd for safety across threads
⋮----
// Check audio streaming modes
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
let target = last_active_window.map(|h| h.0);
⋮----
// Use real-time streaming for Gemini Live
⋮----
AUDIO_STOP_SIGNAL.clone(),
AUDIO_PAUSE_SIGNAL.clone(),
AUDIO_ABORT_SIGNAL.clone(),
⋮----
// Use real-time streaming for Parakeet (Local)
⋮----
// Use standard record-then-transcribe flow
⋮----
unsafe extern "system" fn recording_wnd_proc(
⋮----
// 1. Prepare Content (while still off-screen)
⋮----
// Reset JS state
RECORDING_WEBVIEW.with(|cell| {
if let Some(wv) = cell.borrow().as_ref() {
let _ = wv.evaluate_script("resetState();");
⋮----
// 2. Start Audio Logic
start_audio_thread(hwnd, preset_idx);
// 3. Mark state as Active (Visible)
RECORDING_STATE.store(2, Ordering::SeqCst);
// 4. Check if we should hide the UI
⋮----
if preset_idx < app.config.presets.len() {
⋮----
CURRENT_RECORDING_HIDDEN.store(is_hidden, Ordering::SeqCst);
// 5. Fallback Timer (99) - If IPC ready signal doesn't come in 500ms, show anyway
⋮----
SetTimer(Some(hwnd), 99, 500, None);
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap_or_default()
.as_millis() as u64;
LAST_SHOW_TIME.store(now, Ordering::SeqCst);
LRESULT(0)
⋮----
let _ = KillTimer(Some(hwnd), 2);
let _ = PostMessageW(Some(hwnd), WM_APP_REAL_SHOW, WPARAM(0), LPARAM(0));
⋮----
println!("Warning: Recording overlay IPC timed out, forcing show");
⋮----
let is_processing = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
let is_paused = AUDIO_PAUSE_SIGNAL.load(Ordering::SeqCst);
let is_initializing = AUDIO_INITIALIZING.load(Ordering::SeqCst);
let warming_up = !AUDIO_WARMUP_COMPLETE.load(Ordering::SeqCst);
let rms_bits = CURRENT_RMS.load(Ordering::Relaxed);
⋮----
let script = format!("updateState('{}', {});", state_str, rms);
⋮----
let _ = wv.evaluate_script(&script);
⋮----
if let Ok(app) = APP.try_lock() {
⋮----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
⋮----
LAST_THEME_IS_DARK.store(current_is_dark, Ordering::SeqCst);
⋮----
let theme_script = format!(
⋮----
let _ = wv.evaluate_script(&theme_script);
⋮----
if CURRENT_RECORDING_HIDDEN.load(Ordering::SeqCst) {
return LRESULT(0);
⋮----
let screen_x = GetSystemMetrics(SM_CXSCREEN);
let screen_y = GetSystemMetrics(SM_CYSCREEN);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
let _ = SetTimer(Some(hwnd), 1, 16, None);
⋮----
let _ = wv.evaluate_script(
⋮----
let _ = KillTimer(Some(hwnd), 1);
⋮----
let _ = wv.evaluate_script("hideState();");
⋮----
RECORDING_STATE.store(1, Ordering::SeqCst);
⋮----
let is_stop = AUDIO_STOP_SIGNAL.load(Ordering::SeqCst);
let is_abort = AUDIO_ABORT_SIGNAL.load(Ordering::SeqCst);
⋮----
let last = LAST_SHOW_TIME.load(Ordering::SeqCst);
⋮----
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe extern "system" fn recording_hook_proc(
⋮----
stop_recording_and_submit();
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
fn generate_html() -> String {
⋮----
let lang = app.config.ui_language.as_str();
⋮----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
⋮----
format!(
</file>

<file path="src/gui/app/rendering.rs">
use super::types::SettingsApp;
use crate::gui::locale::LocaleText;
⋮----
use eframe::egui;
⋮----
use image;
impl SettingsApp {
pub(crate) fn render_footer_and_tips_modal(&mut self, ctx: &egui::Context) {
⋮----
let visuals = ctx.style().visuals.clone();
⋮----
.get(self.current_tip_idx)
.unwrap_or(&"")
.to_string();
⋮----
.resizable(false)
.show_separator_line(false)
.frame(
⋮----
.inner_margin(egui::Margin::symmetric(10, 4))
.fill(footer_bg)
.corner_radius(egui::CornerRadius {
⋮----
sw: if ctx.input(|i| i.viewport().maximized.unwrap_or(false)) {
⋮----
se: if ctx.input(|i| i.viewport().maximized.unwrap_or(false)) {
⋮----
.stroke(egui::Stroke::NONE),
⋮----
.show(ctx, |ui| {
render_footer(
⋮----
current_tip.clone(),
⋮----
let tips_list_copy = text.tips_list.clone();
⋮----
.order(egui::Order::Tooltip)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
⋮----
egui::Frame::popup(ui.style())
.inner_margin(egui::Margin::same(16))
.show(ui, |ui| {
ui.set_max_width(1000.0);
ui.set_max_height(550.0);
ui.horizontal(|ui| {
ui.heading(tips_title);
ui.with_layout(
⋮----
.clicked()
⋮----
ui.separator();
ui.add_space(8.0);
⋮----
.max_height(400.0)
.auto_shrink([false; 2])
⋮----
for (i, tip) in tips_list_copy.iter().enumerate() {
let is_dark_mode = ctx.style().visuals.dark_mode;
⋮----
format_tip_with_bold(i + 1, tip, is_dark_mode);
ui.label(layout_job);
if i < tips_list_copy.len() - 1 {
⋮----
if ctx.input(|i| i.pointer.any_click()) {
if let Some(pos) = ctx.input(|i| i.pointer.interact_pos()) {
if let Some(layer) = ctx.layer_id_at(pos) {
⋮----
if ctx.input(|i| i.key_pressed(egui::Key::Escape)) {
⋮----
self.download_manager.render(ctx, &text);
⋮----
pub(crate) fn render_title_bar(&mut self, ctx: &egui::Context) {
⋮----
let is_dark = ctx.style().visuals.dark_mode;
let is_maximized = ctx.input(|i| i.viewport().maximized.unwrap_or(false));
⋮----
.exact_height(40.0)
⋮----
.inner_margin(if is_maximized {
⋮----
.fill(bar_bg)
⋮----
ui.interact(ui.max_rect(), ui.id().with("drag_bar"), egui::Sense::drag());
if drag_resp.drag_started() {
ui.ctx().send_viewport_cmd(egui::ViewportCommand::StartDrag);
⋮----
ui.with_layout(egui::Layout::left_to_right(egui::Align::Center), |ui| {
ui.spacing_mut().item_spacing.x = 6.0;
⋮----
.on_hover_text(tooltip)
⋮----
self.save_and_sync();
⋮----
let original_lang = self.config.ui_language.clone();
let lang_flag = match self.config.ui_language.as_str() {
⋮----
.width(30.0)
.selected_text(lang_flag)
.show_ui(ui, |ui| {
ui.selectable_value(
⋮----
"en".to_string(),
⋮----
"vi".to_string(),
⋮----
"ko".to_string(),
⋮----
ui.spacing_mut().item_spacing.x = 2.0;
⋮----
Some(14.0),
⋮----
let is_history = matches!(self.view_mode, ViewMode::History);
⋮----
.selectable_label(
⋮----
egui::RichText::new(text.history_btn).size(13.0),
⋮----
ui.add_space(2.0);
⋮----
.add(
⋮----
egui::RichText::new(format!("🎵 {}", text.prompt_dj_btn))
.color(egui::Color32::WHITE)
.size(12.0),
⋮----
.fill(egui::Color32::from_rgb(100, 100, 200))
.corner_radius(6.0),
⋮----
egui::RichText::new(format!("⬇ {}", text.download_feature_btn))
⋮----
.fill(egui::Color32::from_rgb(200, 100, 100))
⋮----
egui::RichText::new(format!("❓ {}", text.help_assistant_btn))
⋮----
.fill(help_bg)
⋮----
.on_hover_text(text.help_assistant_title)
⋮----
let is_global = matches!(self.view_mode, ViewMode::Global);
⋮----
egui::RichText::new(text.global_settings).size(13.0),
⋮----
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
ui.spacing_mut().item_spacing.x = 0.0;
⋮----
let close_resp = ui.allocate_response(btn_size, egui::Sense::click());
if close_resp.clicked() {
ui.ctx().send_viewport_cmd(egui::ViewportCommand::Close);
⋮----
if close_resp.hovered() {
ui.painter().rect_filled(
⋮----
ui.painter(),
⋮----
.shrink2(egui::vec2(12.0, if is_maximized { 12.0 } else { 6.0 })),
⋮----
let max_resp = ui.allocate_response(btn_size, egui::Sense::click());
if max_resp.clicked() {
ui.ctx()
.send_viewport_cmd(egui::ViewportCommand::Maximized(!is_maximized));
⋮----
if max_resp.hovered() {
⋮----
.shrink2(egui::vec2(13.0, if is_maximized { 13.0 } else { 7.0 })),
⋮----
let min_resp = ui.allocate_response(btn_size, egui::Sense::click());
if min_resp.clicked() {
⋮----
.send_viewport_cmd(egui::ViewportCommand::Minimized(true));
⋮----
if min_resp.hovered() {
⋮----
.strong()
.size(13.0)
.color(if is_dark {
⋮----
.add(egui::Label::new(title_text).sense(egui::Sense::click()))
.on_hover_cursor(egui::CursorIcon::PointingHand)
⋮----
ui.ctx().open_url(egui::OpenUrl::new_tab(
⋮----
ui.add_space(6.0);
⋮----
if self.icon_dark.is_none() {
let bytes = include_bytes!("../../../assets/app-icon-small.png");
⋮----
let resized = image.resize(
⋮----
let image_buffer = resized.to_rgba8();
⋮----
[image_buffer.width() as _, image_buffer.height() as _];
let pixels = image_buffer.as_raw();
⋮----
let handle = ctx.load_texture(
⋮----
self.icon_dark = Some(handle);
⋮----
self.icon_dark.as_ref()
⋮----
if self.icon_light.is_none() {
⋮----
include_bytes!("../../../assets/app-icon-small-light.png");
⋮----
self.icon_light = Some(handle);
⋮----
self.icon_light.as_ref()
⋮----
ui.add(egui::Image::new(texture).max_height(20.0));
⋮----
pub(crate) fn render_main_layout(&mut self, ctx: &egui::Context) {
⋮----
let _is_dark = ctx.style().visuals.dark_mode;
⋮----
.fill(ctx.style().visuals.panel_fill)
⋮----
let available_width = ui.available_width();
⋮----
ui.allocate_ui_with_layout(
egui::vec2(left_width, ui.available_height()),
⋮----
.inner_margin(egui::Margin {
⋮----
if render_sidebar(
⋮----
ui.add_space(10.0);
⋮----
egui::vec2((right_width - 20.0).max(0.0), ui.available_height()),
⋮----
let app = self.app_state_ref.lock().unwrap();
app.model_usage_stats.clone()
⋮----
if render_global_settings(
⋮----
app.history.clone()
⋮----
if render_history_panel(
⋮----
if self.last_edited_preset_idx != Some(idx) {
if idx < self.config.presets.len() {
self.snarl = Some(blocks_to_snarl(
⋮----
self.last_edited_preset_idx = Some(idx);
⋮----
if render_preset_editor(
⋮----
let (blocks, connections) = snarl_to_graph(snarl);
⋮----
pub(crate) fn render_window_resize_handles(&self, ctx: &egui::Context) {
⋮----
let inner_rect = ctx.input(|i| i.viewport().inner_rect);
let viewport_rect = inner_rect.unwrap_or_else(|| ctx.viewport_rect());
let size = viewport_rect.size();
if ctx.input(|i| i.viewport().maximized.unwrap_or(false)) {
⋮----
.order(egui::Order::Debug)
.fixed_pos(egui::Pos2::ZERO)
⋮----
let response = ui.interact(rect, ui.id().with(id_suffix), egui::Sense::drag());
if response.hovered() || response.dragged() {
ui.ctx().set_cursor_icon(match dir {
⋮----
if response.drag_started() {
⋮----
.send_viewport_cmd(egui::ViewportCommand::BeginResize(dir));
⋮----
pub(crate) fn render_fade_overlay(&mut self, ctx: &egui::Context) {
⋮----
let elapsed = ctx.input(|i| i.time) - start_time;
⋮----
let rect = ctx.input(|i| {
i.viewport().inner_rect.unwrap_or(egui::Rect::from_min_size(
⋮----
let painter = ctx.layer_painter(egui::LayerId::new(
⋮----
painter.rect_filled(
⋮----
ctx.request_repaint();
⋮----
pub(crate) fn render_drop_overlay(&mut self, ctx: &egui::Context) {
use super::input_handler::is_files_hovered;
⋮----
let delta = ctx.input(|i| i.stable_dt).min(0.1);
let is_hovered = is_files_hovered(ctx);
⋮----
self.drop_overlay_fade = self.drop_overlay_fade.clamp(0.0, 1.0);
⋮----
let screen_rect = ctx.available_rect();
⋮----
let painter = ctx.layer_painter(overlay_layer);
⋮----
painter.rect_filled(screen_rect, 0.0, backdrop_color);
⋮----
let inner_rect = screen_rect.shrink(inset);
let time = ctx.input(|i| i.time);
let pulse = (time * 2.5).sin() as f32 * 0.2_f32 + 0.8_f32;
⋮----
let len = vec.length();
⋮----
let count = (len / (dash_length + gap_length)).ceil() as i32;
⋮----
let end = if (end - p1).length() > len { p2 } else { end };
painter.line_segment([start, end], stroke);
⋮----
draw_dashed_line(inner_rect.left_top(), inner_rect.right_top());
draw_dashed_line(inner_rect.right_top(), inner_rect.right_bottom());
draw_dashed_line(inner_rect.right_bottom(), inner_rect.left_bottom());
draw_dashed_line(inner_rect.left_bottom(), inner_rect.left_top());
let center = screen_rect.center();
⋮----
let bob_offset = (time * 5.0).sin() as f32 * 4.0_f32;
⋮----
painter.rect_stroke(
⋮----
painter.line_segment([arrow_start, arrow_end], arrow_stroke);
⋮----
painter.line_segment(
⋮----
let galley = painter.layout_no_wrap(
text.drop_overlay_text.to_string(),
⋮----
painter.galley(
text_pos - egui::vec2(text_rect.width() * 0.5, 0.0),
⋮----
fn format_tip_with_bold(tip_number: usize, text: &str, is_dark_mode: bool) -> LayoutJob {
⋮----
let number_text = format!("{}. ", tip_number);
⋮----
job.append(&number_text, 0.0, text_format.clone());
⋮----
let mut chars = text.chars().peekable();
⋮----
while let Some(ch) = chars.next() {
if ch == '*' && chars.peek() == Some(&'*') {
chars.next();
if !current_text.is_empty() {
let mut fmt = text_format.clone();
⋮----
job.append(&current_text, 0.0, fmt);
current_text.clear();
⋮----
current_text.push(ch);
</file>

<file path="src/gui/settings_ui/download_manager/run.rs">
use std::fs;
⋮----
use std::path::PathBuf;
use std::sync::atomic::Ordering;
⋮----
use std::thread;
use super::DownloadManager;
⋮----
use std::os::windows::process::CommandExt;
impl DownloadManager {
pub fn check_status(&self) {
let bin = self.bin_dir.clone();
let ffmpeg_s = self.ffmpeg_status.clone();
let ytdlp_s = self.ytdlp_status.clone();
let logs = self.logs.clone();
⋮----
if !bin.exists() {
⋮----
let ytdlp_path = bin.join("yt-dlp.exe");
if ytdlp_path.exists() {
*ytdlp_s.lock().unwrap() = InstallStatus::Installed;
⋮----
*ytdlp_s.lock().unwrap() = InstallStatus::Missing;
log(&logs, "yt-dlp missing");
⋮----
let ffmpeg_path = bin.join("ffmpeg.exe");
if ffmpeg_path.exists() {
*ffmpeg_s.lock().unwrap() = InstallStatus::Installed;
⋮----
*ffmpeg_s.lock().unwrap() = InstallStatus::Missing;
log(&logs, "ffmpeg missing");
⋮----
for entry in entries.flatten() {
let path = entry.path();
if path.extension().map_or(false, |ext| ext == "tmp") {
⋮----
pub fn check_updates(&self) {
if self.is_checking_updates.load(Ordering::Relaxed) {
⋮----
self.is_checking_updates.store(true, Ordering::Relaxed);
⋮----
let ytdlp_status_store = self.ytdlp_update_status.clone();
let ffmpeg_status_store = self.ffmpeg_update_status.clone();
let ytdlp_ver = self.ytdlp_version.clone();
let ffmpeg_ver = self.ffmpeg_version.clone();
⋮----
let ytdlp_install = self.ytdlp_status.clone();
let ffmpeg_install = self.ffmpeg_status.clone();
let checking_flag = self.is_checking_updates.clone();
⋮----
log(&logs, "Checking for updates...");
*ytdlp_status_store.lock().unwrap() = UpdateStatus::Checking;
*ffmpeg_status_store.lock().unwrap() = UpdateStatus::Checking;
⋮----
let s = ytdlp_install.lock().unwrap();
⋮----
*ytdlp_status_store.lock().unwrap() = UpdateStatus::Idle;
⋮----
.arg("--version")
.creation_flags(0x08000000)
.output();
⋮----
let local_ver = String::from_utf8_lossy(&out.stdout).trim().to_string();
*ytdlp_ver.lock().unwrap() = Some(local_ver.clone());
⋮----
.header("User-Agent", "Mozilla/5.0")
.call();
⋮----
.header("User-Agent", "ScreenGoatedToolbox")
.call()
⋮----
if let Ok(json_str) = r.into_body().read_to_string() {
if let Some(pos) = json_str.find("\"tag_name\"") {
⋮----
if let Some(colon) = sub.find(':') {
if let Some(quote1) = sub[colon..].find('"') {
⋮----
if let Some(quote2) = sub[start..].find('"') {
⋮----
log(
⋮----
format!(
⋮----
if remote_ver != local_ver && !remote_ver.is_empty() {
*ytdlp_status_store.lock().unwrap() =
⋮----
remote_ver.to_string(),
⋮----
let s = ffmpeg_install.lock().unwrap();
⋮----
*ffmpeg_status_store.lock().unwrap() = UpdateStatus::Idle;
⋮----
.arg("-version")
⋮----
if let Some(line) = stdout.lines().next() {
let parts: Vec<&str> = line.split_whitespace().collect();
if parts.len() >= 3 && parts[0] == "ffmpeg" && parts[1] == "version" {
⋮----
.chars()
.take_while(|c| c.is_ascii_digit() || *c == '.')
.collect();
*ffmpeg_ver.lock().unwrap() = Some(local_ver.clone());
⋮----
if let Ok(remote_ver) = r.into_body().read_to_string() {
let remote_ver = remote_ver.trim();
⋮----
*ffmpeg_status_store.lock().unwrap() =
UpdateStatus::UpdateAvailable(remote_ver.to_string());
⋮----
checking_flag.store(false, Ordering::Relaxed);
log(&logs, "Update check complete.");
⋮----
pub fn get_dependency_sizes(&self) -> (String, String) {
let ytdlp_path = self.bin_dir.join("yt-dlp.exe");
let ffmpeg_path = self.bin_dir.join("ffmpeg.exe");
⋮----
let size_mb = metadata.len() as f64 / 1024.0 / 1024.0;
format!("{:.1} MB", size_mb)
⋮----
"0 MB".to_string()
⋮----
(size_to_string(ytdlp_path), size_to_string(ffmpeg_path))
⋮----
pub fn delete_dependencies(&self) {
⋮----
*self.ytdlp_status.lock().unwrap() = InstallStatus::Missing;
*self.ffmpeg_status.lock().unwrap() = InstallStatus::Missing;
⋮----
pub fn cancel_download(&self) {
self.cancel_flag.store(true, Ordering::Relaxed);
⋮----
pub fn change_download_folder(&mut self) {
⋮----
cmd.args(&["-Command", "Add-Type -AssemblyName System.Windows.Forms; $f = New-Object System.Windows.Forms.FolderBrowserDialog; $f.ShowDialog() | Out-Null; $f.SelectedPath"]);
⋮----
cmd.creation_flags(0x08000000);
let output = cmd.output();
⋮----
let path = path.trim().to_string();
if !path.is_empty() {
self.custom_download_path = Some(PathBuf::from(path));
self.save_settings();
⋮----
pub fn start_download_ytdlp(&self) {
⋮----
let status = self.ytdlp_status.clone();
let update_status = self.ytdlp_update_status.clone();
⋮----
let cancel = self.cancel_flag.clone();
let bin_clone = bin.clone();
let ytdlp_ver_store = self.ytdlp_version.clone();
⋮----
let mut s = status.lock().unwrap();
if matches!(
⋮----
cancel.store(false, Ordering::Relaxed);
⋮----
log(&logs, format!("Starting download: {}", url));
match download_file(url, &bin.join("yt-dlp.exe"), &status, &cancel) {
⋮----
*status.lock().unwrap() = InstallStatus::Installed;
log(&logs, "yt-dlp installed successfully");
*update_status.lock().unwrap() = UpdateStatus::Idle;
⋮----
let output = std::process::Command::new(bin_clone.join("yt-dlp.exe"))
⋮----
*ytdlp_ver_store.lock().unwrap() = Some(local_ver);
⋮----
*status.lock().unwrap() = InstallStatus::Error(e.clone());
log(&logs, format!("yt-dlp error: {}", e));
⋮----
pub fn start_download_ffmpeg(&self) {
⋮----
let status = self.ffmpeg_status.clone();
let update_status = self.ffmpeg_update_status.clone();
⋮----
let app_bin = bin.clone();
let ffmpeg_ver_store = self.ffmpeg_version.clone();
⋮----
let zip_path = bin.join("ffmpeg.zip");
match download_file(url, &zip_path, &status, &cancel) {
⋮----
log(&logs, "Download complete. Extracting...");
*status.lock().unwrap() = InstallStatus::Extracting;
if cancel.load(Ordering::Relaxed) {
*status.lock().unwrap() = InstallStatus::Error("Cancelled".to_string());
⋮----
match extract_ffmpeg(&zip_path, &bin) {
⋮----
log(&logs, "ffmpeg installed successfully");
⋮----
let output = std::process::Command::new(app_bin.join("ffmpeg.exe"))
⋮----
if parts.len() >= 3
⋮----
*ffmpeg_ver_store.lock().unwrap() = Some(local_ver);
⋮----
log(&logs, format!("Extract error: {}", e));
⋮----
log(&logs, format!("ffmpeg download error: {}", e));
⋮----
pub fn start_analysis(&mut self) {
let url = self.input_url.trim().to_string();
if url.is_empty() {
⋮----
let bin_dir = self.bin_dir.clone();
let cookie_browser = self.cookie_browser.clone();
let formats_clone = self.available_formats.clone();
let is_analyzing = self.is_analyzing.clone();
let error_clone = self.analysis_error.clone();
self.last_url_analyzed = url.clone();
*is_analyzing.lock().unwrap() = true;
*error_clone.lock().unwrap() = None;
formats_clone.lock().unwrap().clear();
⋮----
use super::utils::fetch_video_formats;
⋮----
move || match fetch_video_formats(&url, &bin_dir, cookie_browser) {
⋮----
*formats_clone.lock().unwrap() = formats;
*is_analyzing.lock().unwrap() = false;
⋮----
*error_clone.lock().unwrap() = Some(e);
⋮----
pub fn start_media_download(&self, progress_fmt: String) {
⋮----
let download_type = self.download_type.clone();
let state = self.download_state.clone();
⋮----
let selected_format = self.selected_format.clone();
⋮----
.clone()
.unwrap_or_else(|| dirs::download_dir().unwrap_or(PathBuf::from(".")));
⋮----
let mut s = state.lock().unwrap();
if matches!(*s, DownloadState::Downloading(_, _)) {
⋮----
*s = DownloadState::Downloading(0.0, "Starting...".to_string());
⋮----
log(&logs, format!("Processing URL: {}", url));
let ytdlp_exe = bin_dir.join("yt-dlp.exe");
⋮----
args.push("--encoding".to_string());
args.push("utf-8".to_string());
args.push("--ffmpeg-location".to_string());
args.push(bin_dir.to_string_lossy().to_string());
args.push("--newline".to_string());
⋮----
args.push("--no-playlist".to_string());
⋮----
args.push("--yes-playlist".to_string());
⋮----
args.push("--embed-metadata".to_string());
args.push("--embed-chapters".to_string());
args.push("--embed-thumbnail".to_string());
⋮----
args.push("--sponsorblock-remove".to_string());
args.push("all".to_string());
⋮----
args.push("--write-subs".to_string());
args.push("--write-auto-subs".to_string());
args.push("--sub-langs".to_string());
⋮----
args.push("--embed-subs".to_string());
⋮----
args.push("--cookies-from-browser".to_string());
args.push("chrome".to_string());
⋮----
args.push("firefox".to_string());
⋮----
args.push("edge".to_string());
⋮----
args.push("brave".to_string());
⋮----
args.push("opera".to_string());
⋮----
args.push("vivaldi".to_string());
⋮----
args.push("chromium".to_string());
⋮----
args.push("whale".to_string());
⋮----
args.push("-f".to_string());
⋮----
let height = fmt_str.trim_end_matches('p');
⋮----
format!("bestvideo[height={0}]+bestaudio/best[height={0}]", height);
args.push(selector);
⋮----
args.push("bestvideo+bestaudio/best".to_string());
⋮----
args.push("--merge-output-format".to_string());
args.push("mp4".to_string());
⋮----
args.push("-x".to_string());
args.push("--audio-format".to_string());
args.push("mp3".to_string());
args.push("--audio-quality".to_string());
args.push("0".to_string());
⋮----
args.push("-o".to_string());
let out_tmpl = download_path.join("%(title)s.%(ext)s");
args.push(out_tmpl.to_string_lossy().to_string());
args.push(url);
⋮----
cmd.args(&args);
cmd.stdout(Stdio::piped());
cmd.stderr(Stdio::piped());
⋮----
log(&logs, format!("Running: yt-dlp ..."));
match cmd.spawn() {
⋮----
let stdout = child.stdout.take().expect("Failed to open stdout");
let stderr = child.stderr.take().expect("Failed to open stderr");
let logs_clone = logs.clone();
let state_clone = state.clone();
⋮----
let final_filename_clone = final_filename.clone();
let fmt_str = progress_fmt.clone();
⋮----
for line in reader.lines() {
⋮----
if l.contains("[download]") && l.contains("%") {
if let Some(start) = l.find("%") {
⋮----
if let Some(space) = substr.rfind(' ') {
⋮----
l.split_whitespace().collect();
⋮----
for (i, part) in parts.iter().enumerate() {
if part.contains("%") {
p_val = Some(part.trim_end_matches('%'));
} else if *part == "of" && i + 1 < parts.len() {
⋮----
t_val = Some(val);
⋮----
} else if *part == "at" && i + 1 < parts.len() {
⋮----
s_val = Some(val);
⋮----
} else if *part == "ETA" && i + 1 < parts.len()
⋮----
e_val = Some(val);
⋮----
fmt_str.split("{}").collect();
⋮----
if fmt_segments.len() >= 5 {
status_msg.push_str(fmt_segments[0]);
status_msg.push_str(p_str);
⋮----
status_msg.push_str(fmt_segments[1]);
status_msg.push_str(t);
⋮----
status_msg.push_str("%");
⋮----
status_msg.push_str(fmt_segments[2]);
status_msg.push_str(s);
⋮----
status_msg.push_str(fmt_segments[3]);
status_msg.push_str(e);
status_msg.push_str(fmt_segments[4]);
⋮----
status_msg = format!("{}%", p_str);
⋮----
status_msg = l.clone();
⋮----
if let Ok(mut s) = state_clone.lock() {
⋮----
if l.contains("Merging formats into \"") {
if let Some(start) = l.find("Merging formats into \"") {
⋮----
&l[start + "Merging formats into \"".len()..];
let clean_path = raw_path.trim().trim_end_matches('"');
*final_filename_clone.lock().unwrap() =
Some(PathBuf::from(clean_path));
⋮----
} else if l.contains("Destination: ") {
if final_filename_clone.lock().unwrap().is_none() {
if let Some(start) = l.find("Destination: ") {
let raw_path = &l[start + "Destination: ".len()..];
let clean_path = raw_path.trim();
⋮----
if l.contains("[ExtractAudio] Destination: ") {
if let Some(start) = l.find("[ExtractAudio] Destination: ") {
⋮----
&l[start + "[ExtractAudio] Destination: ".len()..];
⋮----
log(&logs_clone, l);
⋮----
let logs_clone_err = logs.clone();
⋮----
log(&logs_clone_err, format!("ERR: {}", l));
⋮----
let status = child.wait();
let _ = stdout_thread.join();
let _ = stderr_thread.join();
⋮----
if exit_status.success() {
let final_path = final_filename.lock().unwrap().clone();
⋮----
*state.lock().unwrap() = DownloadState::Finished(
⋮----
"Download Completed!".to_string(),
⋮----
log(&logs, "Download Finished Successfully.");
⋮----
*state.lock().unwrap() =
DownloadState::Error(format!("Exit Code: {}", exit_status));
log(&logs, "Download Failed.");
⋮----
*state.lock().unwrap() = DownloadState::Error(e.to_string());
log(&logs, format!("Wait Error: {}", e));
⋮----
log(&logs, format!("Execution Error: {}", e));
</file>

<file path="src/gui/settings_ui/global/downloaded_tools.rs">
use crate::gui::locale::LocaleText;
⋮----
use crate::overlay::realtime_webview::state::REALTIME_STATE;
use eframe::egui;
use std::fs;
use std::path::PathBuf;
use std::sync::atomic::AtomicBool;
use std::sync::Arc;
use std::thread;
pub fn render_downloaded_tools_modal(
⋮----
.open(&mut open)
.collapsible(false)
.resizable(false)
.default_width(500.0)
.anchor(egui::Align2::CENTER_CENTER, egui::vec2(0.0, 0.0))
.show(ctx, |ui| {
ui.add_space(8.0);
ui.group(|ui| {
ui.horizontal(|ui| {
ui.label(egui::RichText::new(text.tool_parakeet).strong());
ui.with_layout(egui::Layout::right_to_left(egui::Align::Center), |ui| {
⋮----
if let Ok(state) = REALTIME_STATE.lock() {
⋮----
ui.label(format!("{:.0}%", progress));
ui.spinner();
} else if is_model_downloaded() {
⋮----
.button(
⋮----
.color(egui::Color32::RED),
⋮----
.clicked()
⋮----
let _ = fs::remove_dir_all(get_parakeet_model_dir());
⋮----
let size = get_dir_size(get_parakeet_model_dir());
ui.label(
⋮----
.replace("{}", &format_size(size)),
⋮----
.color(egui::Color32::from_rgb(34, 139, 34)),
⋮----
if ui.button(text.tool_action_download).clicked() {
⋮----
let _ = download_parakeet_model(stop_signal, false);
⋮----
.color(egui::Color32::GRAY),
⋮----
ui.label(text.tool_desc_parakeet);
⋮----
let status = download_manager.ytdlp_status.lock().unwrap().clone();
⋮----
ui.label(egui::RichText::new(text.tool_ytdlp).strong());
⋮----
let path = download_manager.bin_dir.join("yt-dlp.exe");
⋮----
*download_manager.ytdlp_status.lock().unwrap() =
⋮----
fs::metadata(download_manager.bin_dir.join("yt-dlp.exe"))
⋮----
meta.len()
⋮----
ui.label(format!("{:.0}%", p * 100.0));
⋮----
ui.label(text.download_status_extracting);
⋮----
download_manager.start_download_ytdlp();
⋮----
ui.label(text.tool_desc_ytdlp);
if matches!(status, InstallStatus::Installed) {
ui.with_layout(
⋮----
if let Ok(s) = download_manager.ytdlp_update_status.lock() {
s.clone()
⋮----
.replace("{}", &ver),
⋮----
.color(egui::Color32::from_rgb(255, 165, 0)),
⋮----
ui.label(text.tool_update_checking);
⋮----
.small_button(text.tool_update_check_again)
⋮----
download_manager.check_updates();
⋮----
if ui.small_button(text.tool_update_retry).clicked() {
⋮----
.on_hover_text(e);
⋮----
if ui.small_button(text.tool_update_check_btn).clicked()
⋮----
if let Ok(guard) = download_manager.ytdlp_version.lock() {
⋮----
egui::RichText::new(format!("v{}", ver))
⋮----
let status = download_manager.ffmpeg_status.lock().unwrap().clone();
⋮----
ui.label(egui::RichText::new(text.tool_ffmpeg).strong());
⋮----
let path = download_manager.bin_dir.join("ffmpeg.exe");
⋮----
download_manager.bin_dir.join("ffprobe.exe"),
⋮----
*download_manager.ffmpeg_status.lock().unwrap() =
⋮----
download_manager.start_download_ffmpeg();
⋮----
ui.label(text.tool_desc_ffmpeg);
⋮----
if let Ok(s) = download_manager.ffmpeg_update_status.lock()
⋮----
if let Ok(guard) = download_manager.ffmpeg_version.lock() {
⋮----
fn get_dir_size(path: PathBuf) -> u64 {
⋮----
if let Ok(metadata) = entry.metadata() {
if metadata.is_dir() {
total_size += get_dir_size(entry.path());
⋮----
total_size += metadata.len();
⋮----
fn format_size(bytes: u64) -> String {
⋮----
format!("{:.1} MB", mb)
</file>

<file path="src/gui/settings_ui/sidebar.rs">
use super::ViewMode;
⋮----
use crate::gui::locale::LocaleText;
use eframe::egui;
pub fn get_localized_preset_name(preset_id: &str, lang_code: &str) -> String {
⋮----
"vi" => "Tất tần tật".to_string(),
"ko" => "이것의 모든 것".to_string(),
_ => "101 on this".to_string(),
⋮----
("preset_translate", "vi") => "Dịch vùng".to_string(),
("preset_extract_retranslate", "vi") => "Dịch vùng (CHUẨN)".to_string(),
("preset_translate_auto_paste", "vi") => "Dịch vùng (Tự dán)".to_string(),
("preset_translate_retranslate", "vi") => "Dịch vùng+Dịch lại".to_string(),
("preset_extract_retrans_retrans", "vi") => "D.vùng (CHUẨN)+D.lại".to_string(),
("preset_ocr", "vi") => "Lấy text từ ảnh".to_string(),
("preset_quick_screenshot", "vi") => "Chụp MH nhanh".to_string(),
("preset_quick_screenshot", "ko") => "빠른 스크린샷".to_string(),
("preset_quick_screenshot", _) => "Quick screenshot".to_string(),
("preset_ocr_read", "vi") => "Đọc vùng này".to_string(),
("preset_summarize", "vi") => "Tóm tắt vùng".to_string(),
("preset_desc", "vi") => "Mô tả ảnh".to_string(),
("preset_ask_image", "vi") => "Hỏi về ảnh".to_string(),
("preset_translate_select", "vi") => "Dịch".to_string(),
("preset_translate_arena", "vi") => "Dịch (Arena)".to_string(),
("preset_read_aloud", "vi") => "Đọc to".to_string(),
("preset_trans_retrans_select", "vi") => "Dịch+ Dịch lại".to_string(),
("preset_select_translate_replace", "vi") => "Dịch và Thay".to_string(),
("preset_fix_grammar", "vi") => "Sửa ngữ pháp".to_string(),
("preset_rephrase", "vi") => "Viết lại".to_string(),
("preset_make_formal", "vi") => "Chuyên nghiệp hóa".to_string(),
("preset_explain", "vi") => "Giải thích".to_string(),
("preset_ask_text", "vi") => "Hỏi về text...".to_string(),
("preset_edit_as_follows", "vi") => "Sửa như sau:".to_string(),
("preset_extract_table", "vi") => "Trích bảng".to_string(),
("preset_qr_scanner", "vi") => "Quét mã QR".to_string(),
("preset_trans_retrans_typing", "vi") => "Dịch+Dịch lại (Tự gõ)".to_string(),
("preset_ask_ai", "vi") => "Hỏi AI".to_string(),
("preset_internet_search", "vi") => "Tìm kiếm internet".to_string(),
("preset_make_game", "vi") => "Tạo con game".to_string(),
("preset_transcribe", "vi") => "Lời nói thành văn".to_string(),
("preset_fix_pronunciation", "vi") => "Chỉnh phát âm".to_string(),
("preset_study_language", "vi") => "Học ngoại ngữ".to_string(),
("preset_transcribe_retranslate", "vi") => "Trả lời ng.nc.ngoài 1".to_string(),
("preset_quicker_foreigner_reply", "vi") => "Trả lời ng.nc.ngoài 2".to_string(),
("preset_fact_check", "vi") => "Kiểm chứng thông tin".to_string(),
("preset_omniscient_god", "vi") => "Thần Trí tuệ".to_string(),
("preset_realtime_audio_translate", "vi") => "Dịch cabin".to_string(),
("preset_quick_ai_question", "vi") => "Hỏi nhanh AI".to_string(),
("preset_voice_search", "vi") => "Nói để search".to_string(),
("preset_hang_image", "vi") => "Treo ảnh".to_string(),
("preset_hang_text", "vi") => "Treo text".to_string(),
("preset_quick_note", "vi") => "Note nhanh".to_string(),
("preset_quick_record", "vi") => "Thu âm nhanh".to_string(),
("preset_record_device", "vi") => "Thu âm máy".to_string(),
("preset_continuous_writing_online", "vi") => "Viết liên tục".to_string(),
("preset_transcribe_english_offline", "vi") => "Chép lời TA".to_string(),
("preset_image_master", "vi") => "Ảnh MASTER".to_string(),
("preset_text_select_master", "vi") => "Bôi MASTER".to_string(),
("preset_text_type_master", "vi") => "Gõ MASTER".to_string(),
("preset_audio_mic_master", "vi") => "Mic MASTER".to_string(),
("preset_audio_device_master", "vi") => "Tiếng MASTER".to_string(),
("preset_translate", "ko") => "영역 번역".to_string(),
("preset_extract_retranslate", "ko") => "영역 번역 (정확)".to_string(),
("preset_translate_auto_paste", "ko") => "영역 번역 (자동 붙.)".to_string(),
("preset_translate_retranslate", "ko") => "영역 번역+재번역".to_string(),
("preset_extract_retrans_retrans", "ko") => "영.번역 (정확)+재번역".to_string(),
("preset_ocr", "ko") => "텍스트 추출".to_string(),
("preset_ocr_read", "ko") => "영역 읽기".to_string(),
("preset_summarize", "ko") => "영역 요약".to_string(),
("preset_desc", "ko") => "이미지 설명".to_string(),
("preset_ask_image", "ko") => "이미지 질문".to_string(),
("preset_translate_select", "ko") => "번역 (선택 텍스트)".to_string(),
("preset_translate_arena", "ko") => "번역 (아레나)".to_string(),
("preset_read_aloud", "ko") => "크게 읽기".to_string(),
("preset_trans_retrans_select", "ko") => "번역+재번역 (선택)".to_string(),
("preset_select_translate_replace", "ko") => "선택-번역-교체".to_string(),
("preset_fix_grammar", "ko") => "문법 수정".to_string(),
("preset_rephrase", "ko") => "다시 쓰기".to_string(),
("preset_make_formal", "ko") => "공식적으로".to_string(),
("preset_explain", "ko") => "설명".to_string(),
("preset_ask_text", "ko") => "텍스트 질문...".to_string(),
("preset_edit_as_follows", "ko") => "다음과 같이 수정:".to_string(),
("preset_extract_table", "ko") => "표 추출".to_string(),
("preset_qr_scanner", "ko") => "QR 스캔".to_string(),
("preset_trans_retrans_typing", "ko") => "번역+재번역 (입력)".to_string(),
("preset_ask_ai", "ko") => "AI 질문".to_string(),
("preset_internet_search", "ko") => "인터넷 검색".to_string(),
("preset_make_game", "ko") => "게임 만들기".to_string(),
("preset_transcribe", "ko") => "음성 받아쓰기".to_string(),
("preset_fix_pronunciation", "ko") => "발음 교정".to_string(),
("preset_study_language", "ko") => "언어 학습".to_string(),
("preset_transcribe_retranslate", "ko") => "빠른 외국인 답변 1".to_string(),
("preset_quicker_foreigner_reply", "ko") => "빠른 외국인 답변 2".to_string(),
("preset_fact_check", "ko") => "정보 확인".to_string(),
("preset_omniscient_god", "ko") => "전지전능한 신".to_string(),
("preset_realtime_audio_translate", "ko") => "실시간 음성 번역".to_string(),
("preset_quick_ai_question", "ko") => "빠른 AI 질문".to_string(),
("preset_voice_search", "ko") => "음성 검색".to_string(),
("preset_hang_image", "ko") => "이미지 오버레이".to_string(),
("preset_hang_text", "ko") => "텍스트 오버레이".to_string(),
("preset_quick_note", "ko") => "빠른 메모".to_string(),
("preset_quick_record", "ko") => "빠른 녹음".to_string(),
("preset_record_device", "ko") => "시스템 녹음".to_string(),
("preset_continuous_writing_online", "ko") => "연속 입력".to_string(),
("preset_transcribe_english_offline", "ko") => "영어 받아쓰기".to_string(),
("preset_image_master", "ko") => "이미지 마스터".to_string(),
("preset_text_select_master", "ko") => "선택 마스터".to_string(),
("preset_text_type_master", "ko") => "입력 마스터".to_string(),
("preset_audio_mic_master", "ko") => "마이크 마스터".to_string(),
("preset_audio_device_master", "ko") => "사운드 마스터".to_string(),
("preset_translate", _) => "Translate region".to_string(),
("preset_extract_retranslate", _) => "Trans reg (ACCURATE)".to_string(),
("preset_translate_auto_paste", _) => "Trans reg (Auto paste)".to_string(),
("preset_translate_retranslate", _) => "Trans reg+Retrans".to_string(),
("preset_extract_retrans_retrans", _) => "Trans (ACC)+Retrans".to_string(),
("preset_ocr", _) => "Extract text".to_string(),
("preset_ocr_read", _) => "Read this region".to_string(),
("preset_summarize", _) => "Summarize region".to_string(),
("preset_desc", _) => "Describe image".to_string(),
("preset_ask_image", _) => "Ask about image".to_string(),
("preset_translate_select", _) => "Trans (Select text)".to_string(),
("preset_translate_arena", _) => "Trans (Arena)".to_string(),
("preset_read_aloud", _) => "Read aloud".to_string(),
("preset_trans_retrans_select", _) => "Trans+Retrans (Select)".to_string(),
("preset_select_translate_replace", _) => "Select-Trans-Replace".to_string(),
("preset_fix_grammar", _) => "Fix Grammar".to_string(),
("preset_rephrase", _) => "Rephrase".to_string(),
("preset_make_formal", _) => "Make Formal".to_string(),
("preset_explain", _) => "Explain".to_string(),
("preset_ask_text", _) => "Ask about text...".to_string(),
("preset_edit_as_follows", _) => "Edit as follows:".to_string(),
("preset_extract_table", _) => "Extract Table".to_string(),
("preset_qr_scanner", _) => "QR Scanner".to_string(),
("preset_trans_retrans_typing", _) => "Trans+Retrans (Type)".to_string(),
("preset_ask_ai", _) => "Ask AI".to_string(),
("preset_internet_search", _) => "Internet Search".to_string(),
("preset_make_game", _) => "Make a Game".to_string(),
("preset_transcribe", _) => "Transcribe speech".to_string(),
("preset_fix_pronunciation", _) => "Fix pronunciation".to_string(),
("preset_study_language", _) => "Study language".to_string(),
("preset_transcribe_retranslate", _) => "Quick 4NR reply 1".to_string(),
("preset_quicker_foreigner_reply", _) => "Quick 4NR reply 2".to_string(),
("preset_fact_check", _) => "Fact Check".to_string(),
("preset_omniscient_god", _) => "Omniscient God".to_string(),
("preset_realtime_audio_translate", _) => "Live Translate".to_string(),
("preset_quick_ai_question", _) => "Quick AI Question".to_string(),
("preset_voice_search", _) => "Voice Search".to_string(),
("preset_hang_image", _) => "Image Overlay".to_string(),
("preset_hang_text", _) => "Text Overlay".to_string(),
("preset_quick_note", _) => "Quick Note".to_string(),
("preset_quick_record", _) => "Quick Record".to_string(),
("preset_record_device", _) => "Device Record".to_string(),
("preset_continuous_writing_online", _) => "Continuous Writing".to_string(),
("preset_transcribe_english_offline", _) => "Transcribe English".to_string(),
("preset_image_master", _) => "Image MASTER".to_string(),
("preset_text_select_master", _) => "Select MASTER".to_string(),
("preset_text_type_master", _) => "Type MASTER".to_string(),
("preset_audio_mic_master", _) => "Mic MASTER".to_string(),
("preset_audio_device_master", _) => "Sound MASTER".to_string(),
⋮----
.strip_prefix("preset_")
.unwrap_or(preset_id)
.replace('_', " "),
⋮----
pub fn render_sidebar(
⋮----
let dragging_source_idx: Option<usize> = ui.memory(|mem| mem.data.get_temp(dragging_idx_id));
⋮----
for (i, p) in config.presets.iter().enumerate() {
match p.preset_type.as_str() {
"image" => image_indices.push(i),
"text" => text_indices.push(i),
"audio" | "video" => audio_video_indices.push(i),
_ => image_indices.push(i),
⋮----
let current_view_mode = view_mode.clone();
thread_local! {
⋮----
.iter()
.fold(config.presets.len() as u64, |acc, p| {
acc.wrapping_mul(31).wrapping_add(
p.id.bytes()
.fold(0u64, |h, b| h.wrapping_mul(31).wrapping_add(b as u64)),
⋮----
let grid_id = egui::Id::new("presets_grid").with(preset_hash);
⋮----
.num_columns(6)
.spacing([8.0, 4.0])
.min_col_width(67.0)
.show(ui, |ui| {
let is_dark = ui.visuals().dark_mode;
⋮----
ui.add(
⋮----
.color(egui::Color32::WHITE)
.strong(),
⋮----
.fill(img_bg)
.corner_radius(12.0),
⋮----
.clicked()
.then(|| preset_to_add_type = Some("image"));
ui.label("");
// Text
⋮----
.fill(txt_bg)
⋮----
.then(|| preset_to_add_type = Some("text"));
⋮----
// Audio
⋮----
.fill(aud_bg)
⋮----
.then(|| preset_to_add_type = Some("audio"));
⋮----
ui.end_row();
// ROW 2+: Preset Items
⋮----
.len()
.max(text_indices.len())
.max(audio_video_indices.len());
⋮----
// Column 1&2: Image
if let Some(&idx) = image_indices.get(i) {
render_preset_item_parts(
⋮----
// Column 3&4: Text
if let Some(&idx) = text_indices.get(i) {
⋮----
// Column 5&6: Audio
if let Some(&idx) = audio_video_indices.get(i) {
⋮----
// Update cached grid width for next frame
GRID_WIDTH.with(|w| w.set(grid_response.response.rect.width()));
⋮----
if let Some(preset) = config.presets.get_mut(idx) {
⋮----
let mut new_preset = config.presets[idx].clone();
new_preset.id = format!(
⋮----
let base_name = if config.presets[idx].id.starts_with("preset_") {
get_localized_preset_name(&config.presets[idx].id, &config.ui_language)
⋮----
new_preset.name.clone()
⋮----
let mut new_name = format!("{} Copy", base_name);
⋮----
while config.presets.iter().any(|p| p.name == new_name) {
new_name = format!("{} Copy {}", base_name, counter);
⋮----
new_preset.hotkeys.clear();
config.presets.push(new_preset);
*view_mode = ViewMode::Preset(config.presets.len() - 1);
⋮----
config.presets.swap(idx_a, idx_b);
⋮----
new_preset.preset_type = "text".to_string();
new_preset.name = format!("Text {}", config.presets.len() + 1);
new_preset.text_input_mode = "select".to_string();
if let Some(block) = new_preset.blocks.first_mut() {
block.block_type = "text".to_string();
block.model = "text_accurate_kimi".to_string();
block.prompt = "Translate this text.".to_string();
⋮----
new_preset.preset_type = "audio".to_string();
new_preset.name = format!("Audio {}", config.presets.len() + 1);
new_preset.audio_source = "mic".to_string();
⋮----
block.block_type = "audio".to_string();
block.model = "whisper-fast".to_string();
⋮----
new_preset.name = format!("Image {}", config.presets.len() + 1);
⋮----
config.presets.remove(idx);
⋮----
} else if config.presets.is_empty() {
⋮----
fn render_preset_item_parts(
⋮----
let display_name = if preset.id.starts_with("preset_") {
get_localized_preset_name(&preset.id, lang)
⋮----
preset.name.clone()
⋮----
let is_selected = matches!(current_view_mode, ViewMode::Preset(i) if *i == idx);
let has_hotkey = !preset.hotkeys.is_empty();
let icon_type = match preset.preset_type.as_str() {
⋮----
ui.horizontal(|ui| {
ui.set_min_height(22.0);
ui.spacing_mut().item_spacing.x = 4.0;
⋮----
let rect = ui.available_rect_before_wrap();
⋮----
ui.painter().rect_filled(rect, 4.0, bg_color);
⋮----
ui.add_enabled_ui(false, |ui| {
draw_icon_static(ui, icon_type, Some(14.0));
let _ = ui.selectable_label(is_selected, &display_name);
⋮----
let label_response = ui.selectable_label(is_selected, &display_name);
let response = ui.interact(label_response.rect, label_response.id, egui::Sense::drag());
if label_response.clicked() {
*preset_idx_to_select = Some(idx);
⋮----
if response.drag_started() {
ui.memory_mut(|mem| mem.data.insert_temp(dragging_id, idx));
⋮----
if response.dragged() {
ui.ctx().set_cursor_icon(egui::CursorIcon::Grabbing);
⋮----
if response.drag_stopped() {
ui.memory_mut(|mem| mem.data.remove::<usize>(dragging_id));
⋮----
if source_idx != idx && response.hovered() && ui.input(|i| i.pointer.any_released())
⋮----
if get_group(source_preset) == get_group(preset) {
*preset_swap_request = Some((source_idx, idx));
⋮----
ui.spacing_mut().item_spacing.x = 0.0;
⋮----
if icon_button_sized(ui, Icon::CopySmall, 22.0).clicked() {
*preset_idx_to_clone = Some(idx);
⋮----
if icon_button_sized(ui, star_icon, 22.0).clicked() {
*preset_idx_to_toggle_favorite = Some(idx);
⋮----
if presets.len() > 1 {
if icon_button_sized(ui, Icon::Delete, 22.0).clicked() {
*preset_idx_to_delete = Some(idx);
</file>

<file path="src/overlay/preset_wheel/window.rs">
use crate::config::Preset;
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::core::w;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::UI::Controls::MARGINS;
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
pub fn warmup() {
// Prevent multiple warmup threads from spawning
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
internal_create_window_loop();
⋮----
pub fn show_preset_wheel(
⋮----
// Check if warmed up first
⋮----
if !IS_WARMED_UP.load(Ordering::SeqCst) {
// Try to trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
⋮----
// Wait up to 5 seconds for it to become ready
⋮----
// We use smaller sleep intervals (10ms) with message pumping to keep the UI thread responsive
// Total wait: 500 * 10ms = 5000ms (5 seconds)
⋮----
// Drain message queue to prevent freezing the UI thread (input window)
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
if IS_WARMED_UP.load(Ordering::SeqCst) {
// It's ready! Proceed to show logic (fall through)
⋮----
WHEEL_RESULT.store(-1, Ordering::SeqCst);
WHEEL_ACTIVE.store(true, Ordering::SeqCst);
*SELECTED_PRESET.lock().unwrap() = None;
⋮----
let app = APP.lock().unwrap();
(app.config.presets.clone(), app.config.ui_language.clone())
⋮----
let themed_css = generate_css(is_dark);
⋮----
.iter()
.enumerate()
.filter(|(_, p)| {
⋮----
.map(|(i, p)| (i, p.clone()))
.collect();
if filtered.is_empty() {
WHEEL_ACTIVE.store(false, Ordering::SeqCst);
⋮----
let dismiss_label = match ui_lang.as_str() {
⋮----
let screen_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let screen_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let screen_w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let screen_h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
⋮----
.max(screen_x)
.min(screen_x + screen_w - WHEEL_WIDTH);
⋮----
.max(screen_y)
.min(screen_y + screen_h - WHEEL_HEIGHT);
let items_html = generate_items_html(&filtered, &ui_lang);
*PENDING_ITEMS_HTML.lock().unwrap() = items_html;
*PENDING_DISMISS_LABEL.lock().unwrap() = dismiss_label.to_string();
*PENDING_CSS.lock().unwrap() = themed_css;
*PENDING_POS.lock().unwrap() = (win_x, win_y);
let hwnd_val = WHEEL_HWND.load(Ordering::SeqCst);
let wheel_hwnd = HWND(hwnd_val as *mut _);
if !wheel_hwnd.is_invalid() {
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
let res = WHEEL_RESULT.load(Ordering::SeqCst);
⋮----
if PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
⋮----
Some(res as usize)
⋮----
pub fn dismiss_wheel() {
⋮----
let _ = PostMessageW(Some(wheel_hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
WHEEL_RESULT.store(-2, Ordering::SeqCst);
⋮----
pub fn is_wheel_active() -> bool {
WHEEL_ACTIVE.load(Ordering::SeqCst)
⋮----
fn internal_create_window_loop() {
⋮----
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap_or_default();
⋮----
let overlay_class = w!("SGTWheelOverlayPersistent");
REGISTER_OVERLAY_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(overlay_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let overlay_hwnd = CreateWindowExW(
⋮----
w!("WheelOverlay"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
OVERLAY_HWND.store(overlay_hwnd.0 as isize, Ordering::SeqCst);
let _ = SetLayeredWindowAttributes(overlay_hwnd, COLORREF(0), 1, LWA_ALPHA);
let class_name = w!("SGTPresetWheelPersistent");
REGISTER_WHEEL_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(wheel_wnd_proc),
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("PresetWheel"),
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
let wrapper = HwndWrapper(hwnd);
WHEEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = WHEEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
let template_html = get_wheel_template(true);
⋮----
template_html.clone(),
⋮----
.unwrap_or_else(|| {
format!("data:text/html,{}", urlencoding::encode(&template_html))
⋮----
.with_transparent(true)
.with_background_color((0, 0, 0, 0))
.with_url(&page_url)
.with_bounds(Rect {
⋮----
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
let _ = PostMessageW(
Some(wheel_hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
} else if let Some(idx_str) = body.strip_prefix("select:") {
⋮----
*SELECTED_PRESET.lock().unwrap() = Some(idx);
WHEEL_RESULT.store(idx as i32, Ordering::SeqCst);
⋮----
.build(&wrapper)
⋮----
WHEEL_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
WHEEL_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
IS_WARMING_UP.store(false, Ordering::SeqCst);
IS_WARMED_UP.store(true, Ordering::SeqCst);
⋮----
let _ = DestroyWindow(hwnd);
let _ = DestroyWindow(overlay_hwnd);
⋮----
OVERLAY_HWND.store(0, Ordering::SeqCst);
WHEEL_HWND.store(0, Ordering::SeqCst);
let _ = CoUninitialize();
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
⋮----
*cell.borrow_mut() = None;
⋮----
unsafe extern "system" fn overlay_wnd_proc(
⋮----
LRESULT(0)
⋮----
WM_CLOSE => LRESULT(0),
WM_ERASEBKGND => LRESULT(1),
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe extern "system" fn wheel_wnd_proc(
⋮----
let items_html = PENDING_ITEMS_HTML.lock().unwrap().clone();
let dismiss_label = PENDING_DISMISS_LABEL.lock().unwrap().clone();
let themed_css = PENDING_CSS.lock().unwrap().clone();
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
WHEEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
⋮----
.replace("\\", "\\\\")
.replace("`", "\\`")
.replace("$", "\\$");
let css_script = format!(
⋮----
let _ = webview.evaluate_script(&css_script);
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
let _ = webview.set_bounds(Rect {
⋮----
SetTimer(Some(hwnd), 99, 150, None);
⋮----
let _ = KillTimer(Some(hwnd), 99);
let (target_x, target_y) = *PENDING_POS.lock().unwrap();
let overlay_val = OVERLAY_HWND.load(Ordering::SeqCst);
let overlay = HWND(overlay_val as *mut _);
if !overlay.is_invalid() {
let _ = ShowWindow(overlay, SW_SHOWNOACTIVATE);
⋮----
let _ = InvalidateRect(Some(hwnd), None, true);
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_REAL_SHOW, WPARAM(0), LPARAM(0));
⋮----
let _ = ShowWindow(overlay, SW_HIDE);
⋮----
webview.evaluate_script("document.getElementById('grid').innerHTML = '';");
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
PostQuitMessage(0);
</file>

<file path="src/overlay/process/chain.rs">
use crate::gui::settings_ui::get_localized_preset_name;
⋮----
use crate::overlay::text_input;
use crate::win_types::SendHwnd;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
use super::window::create_processing_window;
pub fn execute_chain_pipeline(
⋮----
let graphics_mode = config.graphics_mode.clone();
let processing_hwnd = unsafe { create_processing_window(rect, graphics_mode) };
⋮----
let _ = SendMessageW(processing_hwnd, WM_TIMER, Some(WPARAM(1)), Some(LPARAM(0)));
⋮----
let conf_clone = config.clone();
let blocks = preset.blocks.clone();
let connections = preset.block_connections.clone();
let preset_id = preset.id.clone();
let processing_hwnd_send = SendHwnd(processing_hwnd);
⋮----
let chain_id = generate_chain_id();
run_chain_step(
⋮----
Some(processing_hwnd_send),
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
if !IsWindow(Some(processing_hwnd)).as_bool() {
⋮----
pub fn execute_chain_pipeline_with_token(
⋮----
preset.id.clone(),
⋮----
pub fn run_chain_step(
⋮----
if cancel_token.load(Ordering::Relaxed) {
⋮----
let _ = PostMessageW(Some(h.0), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
if block_idx >= blocks.len() {
⋮----
let model_id = block.model.clone();
⋮----
.clone()
.map(|m| m.provider)
.unwrap_or("groq".to_string());
let model_full_name = model_conf.map(|m| m.full_name).unwrap_or(model_id.clone());
let mut final_prompt = block.prompt.clone();
⋮----
final_prompt = final_prompt.replace(&format!("{{{}}}", key), value);
⋮----
if final_prompt.contains("{language1}") && !block.language_vars.contains_key("language1") {
final_prompt = final_prompt.replace("{language1}", &block.selected_language);
⋮----
final_prompt = final_prompt.replace("{language}", &block.selected_language);
⋮----
.iter()
.take(block_idx)
.filter(|b| b.show_overlay)
.count();
let bg_color = get_chain_color(visible_count_before);
⋮----
get_next_window_position_for_chain(&chain_id, current_rect)
⋮----
context.clone()
⋮----
let m_id = model_id.clone();
let prov = provider.clone();
let prompt_c = final_prompt.clone();
⋮----
let render_md = block.render_mode.clone();
let parent_clone = parent_hwnd.clone();
⋮----
block.block_type == "input_adapter" && matches!(context, RefineContext::Image(_));
⋮----
use base64::Engine;
let base64_img = base64::engine::general_purpose::STANDARD.encode(img_data);
let mime_type = if img_data.starts_with(&[0xff, 0xd8, 0xff]) {
⋮----
} else if img_data.starts_with(&[0x89, 0x50, 0x4e, 0x47]) {
⋮----
format!(
⋮----
let base64_audio = base64::engine::general_purpose::STANDARD.encode(wav_data);
// Get locally cached font CSS for proper Unicode support
⋮----
RefineContext::None => input_text.clone(),
⋮----
let initial_content_clone = initial_content.clone();
let cancel_token_thread = cancel_token.clone();
let input_hwnd_refocus_thread = input_hwnd_refocus.clone();
⋮----
// NOTE: wry handles COM internally, explicit initialization may interfere
let hwnd = create_result_window(
⋮----
// Assign cancellation token immediately for linking/grouping
// This is critical for input adapters since we don't wait for them in main thread
⋮----
let mut s = WINDOW_STATES.lock().unwrap();
if let Some(st) = s.get_mut(&(hwnd.0 as isize)) {
st.cancellation_token = Some(cancel_token_thread.clone());
⋮----
if let Ok(p_guard) = parent_clone.lock() {
⋮----
link_windows(ph.0, hwnd);
⋮----
// For image blocks: DON'T show window yet - keep it hidden
// It will be shown when first data arrives (in the streaming callback)
// For text blocks: show immediately with refining animation
⋮----
// Use SW_SHOWNA (Show No Activate) to prevent stealing focus from text input
let _ = ShowWindow(hwnd, SW_SHOWNA);
// FORCE REFOCUS: If we have a validation to refocus the input window (continuous mode), do it now!
⋮----
let _ = SetForegroundWindow(h_input.0);
let _ = SetFocus(Some(h_input.0));
⋮----
let _ = tx_hwnd.send(SendHwnd(hwnd));
⋮----
// If it's an image input adapter, set opacity to 255 (full opaque)
// This allows the image itself to be fully visible, while the slider controls the image opacity
⋮----
// Import SetLayeredWindowAttributes locally if needed, or assume it's available via windows crate
use windows::Win32::Foundation::COLORREF;
⋮----
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 255, LWA_ALPHA);
⋮----
while GetMessageW(&mut m, None, 0, 0).into() {
let _ = TranslateMessage(&m);
DispatchMessageW(&m);
if !IsWindow(Some(hwnd)).as_bool() {
⋮----
my_hwnd = rx_hwnd.recv().ok().map(|h| h.0);
⋮----
if let Some(st) = s.get_mut(&(h.0 as isize)) {
st.cancellation_token = Some(cancel_token.clone());
⋮----
if !skip_execution && my_hwnd.is_some() {
⋮----
if let Some(st) = s.get_mut(&(my_hwnd.unwrap().0 as isize)) {
⋮----
st.input_text = input_text.clone();
⋮----
let input_text_for_history = input_text.clone();
⋮----
input_text.clone()
⋮----
update_window_text(h, &input_text);
⋮----
let groq_key = config.api_key.clone();
let gemini_key = config.gemini_api_key.clone();
let use_json = block_idx == 0 && blocks.len() == 1 && blocks[0].block_type == "image";
⋮----
let acc_clone = accumulated.clone();
⋮----
.position(|b| b.block_type != "input_adapter")
.map(|pos| pos == block_idx)
.unwrap_or(false);
let mut current_model_id = model_id.clone();
let mut current_provider = provider.clone();
let mut current_model_full_name = model_full_name.clone();
⋮----
let window_shown_clone = window_shown.clone();
⋮----
let processing_hwnd_clone = processing_hwnd_shared.clone();
⋮----
&& matches!(context, RefineContext::Image(_))
⋮----
if let RefineContext::Image(img_data) = context.clone() {
⋮----
.expect("Failed to load png")
.to_rgba8();
let acc_clone_inner = acc_clone.clone();
⋮----
let window_shown_inner = window_shown_clone.clone();
let proc_hwnd_inner = processing_hwnd_clone.clone();
⋮----
if let Ok(mut lock) = acc_clone.lock() {
lock.clear();
⋮----
translate_image_streaming(
⋮----
final_prompt.clone(),
current_model_full_name.clone(),
current_provider.clone(),
⋮----
Some(img_data),
⋮----
.duration_since(std::time::UNIX_EPOCH)
.map(|d| d.as_millis() as u32)
.unwrap_or(0);
let mut t = acc_clone_inner.lock().unwrap();
if chunk.starts_with(crate::api::WIPE_SIGNAL) {
t.clear();
t.push_str(&chunk[crate::api::WIPE_SIGNAL.len()..]);
⋮----
t.push_str(chunk);
⋮----
let mut shown = window_shown_inner.lock().unwrap();
⋮----
let _ = ShowWindow(h, SW_SHOW);
⋮----
let mut proc_hwnd = proc_hwnd_inner.lock().unwrap();
if let Some(ph) = proc_hwnd.take() {
⋮----
let _ = PostMessageW(
Some(ph.0),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
update_window_text(h, &t);
⋮----
Err(anyhow::anyhow!("Missing image context"))
⋮----
let search_label = Some(get_localized_preset_name(&preset_id, &config.ui_language));
⋮----
translate_text_streaming(
⋮----
input_text.clone(),
⋮----
Ok(val) => break Ok(val),
⋮----
&& crate::overlay::utils::is_retryable_error(&e.to_string())
⋮----
failed_model_ids.push(current_model_id.clone());
⋮----
let lang = config.ui_language.clone();
let retry_msg = match lang.as_str() {
⋮----
format!("(Đang thử lại {}...)", current_model_full_name)
⋮----
"ko" => format!("({} 재시도 중...)", current_model_full_name),
"ja" => format!("({} 再試行中...)", current_model_full_name),
"zh" => format!("(正在重试 {}...)", current_model_full_name),
_ => format!("(Retrying {}...)", current_model_full_name),
⋮----
update_window_text(h, &retry_msg);
⋮----
break Err(e);
⋮----
st.pending_text = Some(txt.clone());
st.full_text = txt.clone();
⋮----
&e.to_string(),
⋮----
Some(&current_model_full_name),
⋮----
let mut shown = window_shown.lock().unwrap();
⋮----
let mut proc_hwnd = processing_hwnd_shared.lock().unwrap();
⋮----
PostMessageW(Some(ph.0), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
st.pending_text = Some(err.clone());
st.full_text = err.clone();
⋮----
let has_content = !result_text.trim().is_empty();
⋮----
let img_data_clone = img_data.clone();
⋮----
let image_copied = is_input_adapter && matches!(context, RefineContext::Image(_));
⋮----
let txt_c = result_text.clone();
let txt_for_badge = result_text.clone();
⋮----
let preset_id_clone = preset_id.clone();
⋮----
let app = crate::APP.lock().unwrap();
⋮----
app.config.presets.iter().find(|p| p.id == preset_id_clone)
⋮----
if active_idx < app.config.presets.len() {
⋮----
let final_text = if !txt_c.trim().is_empty() {
⋮----
format!("{}\n", txt_c)
⋮----
txt_c.clone()
⋮----
if txt_c.trim().is_empty() {
⋮----
if block.auto_speak && !result_text.trim().is_empty() {
let txt_s = result_text.clone();
⋮----
crate::api::tts::TTS_MANAGER.speak(&txt_s, 0);
⋮----
if block.show_overlay && !result_text.trim().is_empty() {
let text_for_history = result_text.clone();
⋮----
let input_text_clone = input_text_for_history.clone();
⋮----
if let Ok(app) = crate::APP.lock() {
app.history.save_text(text_for_history, input_text_clone);
⋮----
if let RefineContext::Image(img_bytes) = context.clone() {
⋮----
let img_buffer = img_dynamic.to_rgba8();
⋮----
app.history.save_image(img_buffer, text_for_history);
⋮----
let should_continue = !result_text.trim().is_empty() || block.block_type == "input_adapter";
⋮----
.filter(|(from, _)| *from == block_idx)
.map(|(_, to)| *to)
.collect();
let next_blocks: Vec<usize> = if connections.is_empty() {
if block_idx + 1 < blocks.len() {
vec![block_idx + 1]
⋮----
vec![]
⋮----
if next_blocks.is_empty() {
⋮----
let next_parent = if my_hwnd.is_some() {
Arc::new(Mutex::new(my_hwnd.map(|h| SendHwnd(h))))
⋮----
let base_rect = if my_hwnd.is_some() {
⋮----
let parallel_branches: Vec<usize> = next_blocks.into_iter().skip(1).collect();
⋮----
let _s_w = unsafe { GetSystemMetrics(SM_CXSCREEN) };
let _s_h = unsafe { GetSystemMetrics(SM_CYSCREEN) };
for (branch_index, next_idx) in parallel_branches.iter().enumerate() {
let result_clone = result_text.clone();
let blocks_clone = blocks.clone();
let conns_clone = connections.clone();
let config_clone = config.clone();
let cancel_clone = cancel_token.clone();
let parent_clone = next_parent.clone();
⋮----
let chain_id_clone = chain_id.clone();
⋮----
let branch_context = next_context.clone();
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
⋮----
blocks.clone(),
</file>

<file path="src/unpack_dlls.rs">
use std::fs;
use std::path::PathBuf;
use windows::Win32::System::LibraryLoader::SetDllDirectoryW;
pub fn unpack_dlls() {
let mut bin_dir = dirs::data_local_dir().unwrap_or_else(|| PathBuf::from("."));
bin_dir.push("screen-goated-toolbox");
bin_dir.push("bin");
⋮----
include_bytes!("embed_dlls/vcruntime140.dll"),
⋮----
include_bytes!("embed_dlls/vcruntime140_1.dll"),
⋮----
("msvcp140.dll", include_bytes!("embed_dlls/msvcp140.dll")),
⋮----
include_bytes!("embed_dlls/msvcp140_1.dll"),
⋮----
("DirectML.dll", include_bytes!("embed_dlls/DirectML.dll")),
⋮----
include_bytes!("embed_dlls/onnxruntime.dll"),
⋮----
let path = bin_dir.join(name);
if !path.exists() {
⋮----
.to_string_lossy()
.encode_utf16()
.chain(std::iter::once(0))
.collect();
let _ = SetDllDirectoryW(windows::core::PCWSTR(path_wide.as_ptr()));
⋮----
let new_path = format!("{};{}", bin_dir.to_string_lossy(), current_path);
</file>

<file path="src/overlay/tray_popup.rs">
use crate::APP;
use std::cell::RefCell;
⋮----
use windows::core::w;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
⋮----
thread_local! {
⋮----
fn get_scaled_dimension(base: i32) -> i32 {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
/// Show the tray popup at cursor position
pub fn show_tray_popup() {
⋮----
pub fn show_tray_popup() {
⋮----
// Fallback to native menu if WebView failed completely
if WEBVIEW_INIT_FAILED.load(Ordering::SeqCst) {
show_native_context_menu();
⋮----
// Check if warmed up and window exists
if !IS_WARMED_UP.load(Ordering::SeqCst) {
// Not ready yet - trigger warmup and show notification
warmup_tray_popup();
let ui_lang = APP.lock().unwrap().config.ui_language.clone();
⋮----
// Spawn thread to wait for warmup completion and auto-show
⋮----
// Poll for 5 seconds (50 * 100ms)
⋮----
// Check if ready
let ready = IS_WARMED_UP.load(Ordering::SeqCst) && POPUP_HWND.load(Ordering::SeqCst) != 0;
⋮----
show_tray_popup();
⋮----
let hwnd_val = POPUP_HWND.load(Ordering::SeqCst);
⋮----
// Should be warmed up but handle missing? Retry warmup
IS_WARMED_UP.store(false, Ordering::SeqCst);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
// Check if window still valid logic...
if !IsWindow(Some(hwnd)).as_bool() {
// Window destroyed
⋮----
POPUP_HWND.store(0, Ordering::SeqCst);
⋮----
// Check if already visible
if IsWindowVisible(hwnd).as_bool() {
hide_tray_popup();
⋮----
// Post message to show
let _ = PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
/// Hide the tray popup (preserves window for reuse)
pub fn hide_tray_popup() {
⋮----
pub fn hide_tray_popup() {
⋮----
// Just hide - don't destroy. Preserves WebView state for instant redisplay.
let _ = KillTimer(Some(hwnd), 888);
let _ = ShowWindow(hwnd, SW_HIDE);
⋮----
pub fn warmup_tray_popup() {
⋮----
let start_time = WARMUP_START_TIME.load(Ordering::SeqCst);
⋮----
IS_WARMING_UP.store(false, Ordering::SeqCst);
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
WARMUP_START_TIME.store(windows::Win32::System::SystemInformation::GetTickCount64(), Ordering::SeqCst);
⋮----
create_popup_window();
⋮----
pub fn is_popup_open() -> bool {
⋮----
unsafe { IsWindowVisible(hwnd).as_bool() }
⋮----
fn generate_popup_html() -> String {
use crate::config::ThemeMode;
let (settings_text, bubble_text, stop_tts_text, quit_text, bubble_checked, is_dark_mode) = if let Ok(app) = APP.lock() {
⋮----
let settings = match lang.as_str() {
⋮----
let bubble = match lang.as_str() {
⋮----
let stop_tts = match lang.as_str() {
⋮----
let quit = match lang.as_str() {
⋮----
let has_tts_pending = crate::api::tts::TTS_MANAGER.has_pending_audio();
⋮----
format!(
⋮----
/// Generate JavaScript to update popup state without reloading HTML
fn generate_popup_update_script() -> String {
⋮----
fn generate_popup_update_script() -> String {
⋮----
let (bubble_checked, is_dark_mode) = if let Ok(app) = APP.lock() {
⋮----
fn create_popup_window() {
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTTrayPopup");
REGISTER_POPUP_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(popup_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let popup_height = get_scaled_dimension(BASE_POPUP_HEIGHT);
let popup_width = get_scaled_dimension(BASE_POPUP_WIDTH);
let hwnd = CreateWindowExW(
⋮----
w!("TrayPopup"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
⋮----
if hwnd.is_invalid() {
⋮----
POPUP_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 0, LWA_ALPHA);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let wrapper = HwndWrapper(hwnd);
let html = generate_popup_html();
POPUP_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = POPUP_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
let page_url = crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| format!("data:text/html,{}", urlencoding::encode(&html)));
⋮----
.with_bounds(Rect {
⋮----
.with_transparent(true)
.with_url(&page_url)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
match body.as_str() {
⋮----
let new_state = if let Ok(mut app) = APP.lock() {
⋮----
POPUP_WEBVIEW.with(|cell| {
if let Some(webview) = cell.borrow().as_ref() {
let js = format!(
⋮----
let _ = webview.evaluate_script(&js);
⋮----
crate::api::tts::TTS_MANAGER.stop();
⋮----
.build(&wrapper)
⋮----
final_webview = Some(wv);
⋮----
*cell.borrow_mut() = Some(wv);
⋮----
IS_WARMED_UP.store(true, Ordering::SeqCst);
⋮----
WARMUP_START_TIME.store(0, Ordering::SeqCst);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
WEBVIEW_INIT_FAILED.store(true, Ordering::SeqCst);
⋮----
*cell.borrow_mut() = None;
⋮----
unsafe extern "system" fn popup_wnd_proc(
⋮----
let _ = GetCursorPos(&mut pt);
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
let popup_x = (pt.x - popup_width / 2).max(0).min(screen_w - popup_width);
let popup_y = (pt.y - popup_height - 10).max(0).min(screen_h - popup_height);
⋮----
let update_script = generate_popup_update_script();
let _ = webview.evaluate_script(&update_script);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
let _ = SetWindowPos(hwnd, None, popup_x, popup_y, popup_width, popup_height, SWP_NOZORDER);
let _ = SetLayeredWindowAttributes(hwnd, COLORREF(0), 255, LWA_ALPHA);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetTimer(Some(hwnd), 888, 100, None);
LRESULT(0)
⋮----
let fg = GetForegroundWindow();
let root = GetAncestor(fg, GA_ROOT);
⋮----
return LRESULT(0);
⋮----
if now > IGNORE_FOCUS_LOSS_UNTIL.load(Ordering::SeqCst) {
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe fn show_native_context_menu() {
⋮----
let (settings_text, bubble_text, stop_tts_text, quit_text, bubble_checked, _is_dark) = if let Ok(app) = APP.lock() {
⋮----
w!("STATIC"),
w!("SGTNativeMenu"),
⋮----
None, None, Some(instance.into()), None
).unwrap_or_default();
⋮----
let hmenu = CreatePopupMenu().unwrap_or_default();
fn add_item(hmenu: HMENU, id: usize, text: &str, checked: bool, disabled: bool) {
⋮----
let _ = AppendMenuW(hmenu, flags, id, PCWSTR(h_text.as_ptr()));
⋮----
add_item(hmenu, 1, settings_text, false, false);
add_item(hmenu, 2, bubble_text, bubble_checked, false);
add_item(hmenu, 3, stop_tts_text, false, !has_tts_pending);
let _ = AppendMenuW(hmenu, MF_SEPARATOR, 0, PCWSTR::null());
add_item(hmenu, 4, quit_text, false, false);
⋮----
let cmd_id = TrackPopupMenu(
⋮----
let _ = DestroyMenu(hmenu);
let _ = DestroyWindow(hwnd);
⋮----
if let Ok(mut app) = APP.lock() {
</file>

<file path="src/gui/app.rs">
mod init;
pub mod input_handler;
mod logic;
mod rendering;
mod types;
mod utils;
pub use types::SettingsApp;
⋮----
use eframe::egui;
⋮----
fn clear_color(&self, _visuals: &egui::Visuals) -> [f32; 4] {
⋮----
fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
⋮----
if !LOGGED_STARTUP.swap(true, std::sync::atomic::Ordering::SeqCst) {
⋮----
if let Some(path) = self.pending_file_path.take() {
⋮----
self.check_updater();
self.update_theme_and_tray(ctx);
self.update_startup(ctx);
self.update_bubble_sync();
self.update_splash(ctx);
self.check_restore_signal(ctx);
self.update_hotkey_recording(ctx);
self.handle_events(ctx);
self.handle_close_request(ctx);
self.update_tips_logic(ctx);
⋮----
self.render_title_bar(ctx);
self.render_footer_and_tips_modal(ctx);
self.render_main_layout(ctx);
self.render_window_resize_handles(ctx);
self.render_fade_overlay(ctx);
⋮----
if splash.paint(ctx, &self.config.theme_mode) {
let is_currently_dark = ctx.style().visuals.dark_mode;
⋮----
self.save_and_sync();
⋮----
self.render_drop_overlay(ctx);
⋮----
fn on_exit(&mut self, _gl: Option<&eframe::glow::Context>) {
</file>

<file path="src/overlay/mod.rs">
pub mod auto_copy_badge;
pub mod broom_assets;
pub mod continuous_mode;
pub mod input_history;
pub mod paint_utils;
pub mod preset_wheel;
pub mod process;
pub mod prompt_dj;
pub mod recording;
pub mod result;
mod selection;
pub mod text_input;
pub mod text_selection;
⋮----
pub fn is_busy() -> bool {
IS_BUSY_WITH_OVERLAY.load(Ordering::SeqCst)
⋮----
pub fn set_is_busy(busy: bool) {
IS_BUSY_WITH_OVERLAY.store(busy, Ordering::SeqCst);
⋮----
pub mod utils;
pub mod favorite_bubble;
pub mod html_components;
pub mod realtime_egui;
pub mod realtime_html;
pub mod realtime_webview;
pub mod tray_popup;
⋮----
pub use text_selection::show_text_selection_tag;
⋮----
pub fn get_shared_webview_data_dir(subdir: Option<&str>) -> std::path::PathBuf {
let mut path = dirs::data_local_dir().unwrap_or_else(|| std::path::PathBuf::from("."));
path.push("SGT");
path.push("webview_data");
⋮----
path.push(s);
⋮----
pub fn clear_webview_permissions() -> bool {
⋮----
if !path.exists() {
⋮----
println!("WebView data cleared successfully at {:?}", path);
⋮----
if e.raw_os_error() == Some(145) {
eprintln!(
⋮----
if delete_directory_contents_recursive(&path) {
if std::fs::remove_dir(&path).is_ok() {
println!("WebView data cleared successfully (per-file) at {:?}", path);
⋮----
fn delete_directory_contents_recursive(path: &std::path::Path) -> bool {
⋮----
for entry in entries.flatten() {
let entry_path = entry.path();
if entry_path.is_dir() {
delete_directory_contents_recursive(&entry_path);
if std::fs::remove_dir(&entry_path).is_ok() {
⋮----
if std::fs::remove_file(&entry_path).is_ok() {
⋮----
pub fn is_dark_mode() -> bool {
⋮----
if let Ok(app) = crate::APP.lock() {
app.config.theme_mode.clone()
</file>

<file path="src/gui/app/init.rs">
use crate::gui::settings_ui::ViewMode;
use crate::gui::utils::get_monitor_names;
⋮----
use auto_launch::AutoLaunch;
use eframe::egui;
use std::sync::atomic::Ordering;
use std::sync::mpsc::channel;
⋮----
impl SettingsApp {
pub fn new(
⋮----
let app_path = std::env::current_exe().unwrap();
let app_path_str = app_path.to_str().unwrap_or("");
⋮----
// Check for current admin state early
let current_admin_state = if cfg!(target_os = "windows") {
⋮----
if run_at_startup_ui && config.authorized_startup_path.is_empty() {
config.authorized_startup_path = app_path_str.to_string();
⋮----
use winreg::RegKey;
⋮----
if let Ok(key) = hkcu.open_subkey_with_flags(
⋮----
if key.get_value::<String, &str>(app_name).is_ok() {
⋮----
if !registry_enabled_in_system && auto.is_enabled().unwrap_or(false) {
⋮----
if config.authorized_startup_path.is_empty() {
⋮----
let is_authorized = if config.authorized_startup_path.is_empty() {
⋮----
let other_exists = std::path::Path::new(&config.authorized_startup_path).exists();
⋮----
let _ = auto.enable();
⋮----
let (tx, rx) = channel();
let tx_tray = tx.clone();
let ctx_tray = ctx.clone();
⋮----
while let Ok(event) = TrayIconEvent::receiver().recv() {
⋮----
let _ = tx_tray.send(UserEvent::Tray(event));
ctx_tray.request_repaint();
⋮----
let ctx_restore = ctx.clone();
⋮----
match OpenEventW(
⋮----
w!("Global\\ScreenGoatedToolboxRestoreEvent"),
⋮----
let result = WaitForSingleObject(event_handle, INFINITE);
⋮----
let class_name = w!("eframe");
let mut hwnd = FindWindowW(class_name, None).unwrap_or_default();
if hwnd.is_invalid() {
let title = w!("Screen Goated Toolbox (SGT by nganlinh4)");
hwnd = FindWindowW(None, title).unwrap_or_default();
⋮----
if !hwnd.is_invalid() {
let _ = ShowWindow(hwnd, SW_RESTORE);
let _ = ShowWindow(hwnd, SW_SHOW);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
⋮----
RESTORE_SIGNAL.store(true, Ordering::SeqCst);
ctx_restore.request_repaint();
let _ = ResetEvent(event_handle);
⋮----
let _ = CloseHandle(event_handle);
⋮----
let tx_menu = tx.clone();
let ctx_menu = ctx.clone();
⋮----
while let Ok(event) = MenuEvent::receiver().recv() {
match event.id.0.as_str() {
⋮----
let hwnd = FindWindowW(class_name, None).unwrap_or_default();
let hwnd = if hwnd.is_invalid() {
⋮----
FindWindowW(None, title).unwrap_or_default()
⋮----
let _ = tx_menu.send(UserEvent::Menu(event.clone()));
ctx_menu.request_repaint();
⋮----
let _ = tx_menu.send(UserEvent::Menu(event));
⋮----
let view_mode = if config.presets.is_empty() {
⋮----
ViewMode::Preset(if config.active_preset_idx < config.presets.len() {
⋮----
let cached_monitors = get_monitor_names();
let (up_tx, up_rx) = channel();
⋮----
let devices_clone = cached_audio_devices.clone();
⋮----
if let Ok(mut lock) = devices_clone.lock() {
⋮----
let initial_ui_language = config.ui_language.clone();
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap()
.as_millis() as u32;
tray_favorite_bubble_item.set_checked(config.show_favorite_bubble);
⋮----
let initial_has_favorites = config.presets.iter().any(|p| p.is_favorite);
⋮----
.with_tooltip("Screen Goated Toolbox (nganlinh4)")
.with_icon(icon)
.build()
⋮----
Ok(t) => Some(t),
⋮----
auto_launcher: Some(auto),
⋮----
updater: Some(Updater::new(up_tx)),
</file>

<file path="src/overlay/auto_copy_badge.rs">
use crate::APP;
use std::cell::RefCell;
use std::collections::VecDeque;
⋮----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
⋮----
use windows::Win32::UI::Controls::MARGINS;
⋮----
pub enum NotificationType {
⋮----
pub struct PendingNotification {
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
fn enqueue_notification(title: String, snippet: String, n_type: NotificationType) {
⋮----
let mut q = PENDING_QUEUE.lock().unwrap();
q.push_back(PendingNotification {
⋮----
ensure_window_and_post(WM_APP_PROCESS_QUEUE);
⋮----
pub fn show_auto_copy_badge_text(text: &str) {
let app = APP.lock().unwrap();
let ui_lang = app.config.ui_language.clone();
⋮----
let title = locale.auto_copied_badge.to_string();
drop(app);
let clean_text = text.replace('\n', " ").replace('\r', "");
let snippet = format!("\"{}\"", clean_text);
enqueue_notification(title, snippet, NotificationType::Success);
⋮----
pub fn show_auto_copy_badge_image() {
⋮----
let snippet = locale.auto_copied_image_badge.to_string();
⋮----
/// Show a loading/info notification with just a title (yellow theme)
pub fn show_notification(title: &str) {
⋮----
pub fn show_notification(title: &str) {
enqueue_notification(title.to_string(), String::new(), NotificationType::Info);
⋮----
/// Show an update available notification (blue theme, longer duration)
pub fn show_update_notification(title: &str) {
⋮----
pub fn show_update_notification(title: &str) {
enqueue_notification(title.to_string(), String::new(), NotificationType::Update);
⋮----
/// Show an error notification (red theme)
pub fn show_error_notification(title: &str) {
⋮----
pub fn show_error_notification(title: &str) {
enqueue_notification(title.to_string(), String::new(), NotificationType::Error);
⋮----
/// Show a detailed notification with title and snippet (custom type)
pub fn show_detailed_notification(title: &str, snippet: &str, n_type: NotificationType) {
⋮----
pub fn show_detailed_notification(title: &str, snippet: &str, n_type: NotificationType) {
enqueue_notification(title.to_string(), snippet.to_string(), n_type);
⋮----
fn ensure_window_and_post(msg: u32) {
// Check if already warmed up
if !IS_WARMED_UP.load(Ordering::SeqCst) {
// Trigger warmup if not started yet
warmup();
// We don't block anymore. The notification is in PENDING_QUEUE.
// internal_create_window_loop will post WM_APP_PROCESS_QUEUE to itself once ready.
⋮----
let hwnd_val = BADGE_HWND.load(Ordering::SeqCst);
let hwnd = HWND(hwnd_val as *mut _);
if hwnd_val != 0 && !hwnd.is_invalid() {
⋮----
let res = PostMessageW(Some(hwnd), msg, WPARAM(0), LPARAM(0));
println!("[Badge] PostMessage Result: {:?}", res);
⋮----
println!("[Badge] Invalid HWND: {:?}", hwnd);
⋮----
pub fn warmup() {
// Prevent multiple warmup threads from spawning (like preset_wheel)
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
internal_create_window_loop();
⋮----
fn get_badge_html() -> String {
⋮----
format!(
⋮----
fn internal_create_window_loop() {
⋮----
// Initialize COM for the thread (Critical for WebView2/Wry)
let coinit = CoInitialize(None);
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGT_AutoCopyBadgeWebView");
REGISTER_BADGE_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(badge_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap_or_default();
⋮----
wc.hbrBackground = HBRUSH(std::ptr::null_mut());
let _ = RegisterClassW(&wc);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT AutoCopy Badge"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
⋮----
if hwnd.is_invalid() {
⋮----
IS_WARMING_UP.store(false, Ordering::SeqCst);
BADGE_HWND.store(0, Ordering::SeqCst);
let _ = CoUninitialize();
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
let wrapper = HwndWrapper(hwnd);
BADGE_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = BADGE_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
let badge_html = get_badge_html();
⋮----
badge_html.clone(),
⋮----
.unwrap_or_else(|| format!("data:text/html,{}", urlencoding::encode(&badge_html)));
⋮----
.with_transparent(true)
.with_bounds(Rect {
⋮----
.with_url(&page_url)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
} else if body.starts_with("error:") {
⋮----
.build(&wrapper)
⋮----
BADGE_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
⋮----
BADGE_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
⋮----
IS_WARMED_UP.store(true, Ordering::SeqCst);
let _ = PostMessageW(Some(hwnd), WM_APP_PROCESS_QUEUE, WPARAM(0), LPARAM(0));
⋮----
let _ = DestroyWindow(hwnd);
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
*cell.borrow_mut() = None;
⋮----
IS_WARMED_UP.store(false, Ordering::SeqCst);
⋮----
unsafe extern "system" fn badge_wnd_proc(
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
while let Some(item) = q.pop_front() {
items.push(item);
⋮----
if !items.is_empty() {
BADGE_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let theme_script = format!("window.setTheme({});", is_dark);
let _ = webview.evaluate_script(&theme_script);
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\'', "\\'");
⋮----
.replace('\'', "\\'")
.replace('\n', " ");
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
LRESULT(0)
⋮----
PostQuitMessage(0);
⋮----
WM_ERASEBKGND => LRESULT(1),
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/selection.rs">
use super::process::start_processing_pipeline;
⋮----
use std::sync::Arc;
⋮----
type MagInitializeFn = unsafe extern "system" fn() -> BOOL;
type MagUninitializeFn = unsafe extern "system" fn() -> BOOL;
type MagSetFullscreenTransformFn = unsafe extern "system" fn(f32, i32, i32) -> BOOL;
static mut MAG_DLL: HMODULE = HMODULE(std::ptr::null_mut());
⋮----
static mut SELECTION_OVERLAY_HWND: SendHwnd = SendHwnd(HWND(std::ptr::null_mut()));
⋮----
static mut SELECTION_HOOK: HHOOK = HHOOK(std::ptr::null_mut());
⋮----
static mut CACHED_BITMAP: SendHbitmap = SendHbitmap(HBITMAP(std::ptr::null_mut()));
⋮----
unsafe fn load_magnification_api() -> bool {
let mag_dll = std::ptr::addr_of!(MAG_DLL).read();
if !mag_dll.is_invalid() {
⋮----
let dll_name = w!("Magnification.dll");
let dll = LoadLibraryW(dll_name);
⋮----
if let Some(init) = GetProcAddress(h, s!("MagInitialize")) {
MAG_INITIALIZE = Some(std::mem::transmute(init));
⋮----
if let Some(uninit) = GetProcAddress(h, s!("MagUninitialize")) {
MAG_UNINITIALIZE = Some(std::mem::transmute(uninit));
⋮----
if let Some(transform) = GetProcAddress(h, s!("MagSetFullscreenTransform")) {
MAG_SET_FULLSCREEN_TRANSFORM = Some(std::mem::transmute(transform));
⋮----
let init_ptr = std::ptr::addr_of!(MAG_INITIALIZE).read();
let trans_ptr = std::ptr::addr_of!(MAG_SET_FULLSCREEN_TRANSFORM).read();
return init_ptr.is_some() && trans_ptr.is_some();
⋮----
unsafe fn extract_crop_from_hbitmap(
⋮----
let hdc_screen = GetDC(None);
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
let old_obj = SelectObject(hdc_mem, capture.hbitmap.into());
let w = (crop_rect.right - crop_rect.left).abs();
let h = (crop_rect.bottom - crop_rect.top).abs();
⋮----
let mut buffer: Vec<u8> = vec![0; (w * h * 4) as usize];
let hdc_temp = CreateCompatibleDC(Some(hdc_screen));
let hbm_temp = CreateCompatibleBitmap(hdc_screen, w, h);
SelectObject(hdc_temp, hbm_temp.into());
let v_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let v_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
let _ = BitBlt(hdc_temp, 0, 0, w, h, Some(hdc_mem), src_x, src_y, SRCCOPY).ok();
GetDIBits(
⋮----
Some(buffer.as_mut_ptr() as *mut _),
⋮----
for chunk in buffer.chunks_exact_mut(4) {
chunk.swap(0, 2);
⋮----
let _ = DeleteObject(hbm_temp.into());
let _ = DeleteDC(hdc_temp);
SelectObject(hdc_mem, old_obj);
let _ = DeleteDC(hdc_mem);
ReleaseDC(None, hdc_screen);
image::ImageBuffer::from_raw(w as u32, h as u32, buffer).unwrap()
⋮----
pub fn is_selection_overlay_active() -> bool {
SELECTION_OVERLAY_ACTIVE.load(Ordering::SeqCst)
⋮----
pub fn show_selection_overlay(preset_idx: usize) {
⋮----
SELECTION_OVERLAY_ACTIVE.store(true, Ordering::SeqCst);
⋮----
HOLD_DETECTED_THIS_SESSION.store(false, Ordering::SeqCst);
CONTINUOUS_ACTIVATED_THIS_SESSION.store(false, Ordering::SeqCst);
⋮----
let is_physically_held = (GetAsyncKeyState(vk as i32) as u16 & 0x8000) != 0;
IS_HOTKEY_HELD.store(is_physically_held, Ordering::SeqCst);
⋮----
IS_HOTKEY_HELD.store(false, Ordering::SeqCst);
⋮----
SELECTION_ABORT_SIGNAL.store(false, Ordering::SeqCst);
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SnippingOverlay");
⋮----
if !GetClassInfoW(Some(instance.into()), class_name, &mut wc).is_ok() {
wc.lpfnWndProc = Some(selection_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_CROSS).unwrap();
⋮----
wc.hbrBackground = CreateSolidBrush(COLORREF(0x00000000));
RegisterClassW(&wc);
⋮----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let hwnd = CreateWindowExW(
⋮----
w!("Snipping"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
SELECTION_OVERLAY_HWND = SendHwnd(hwnd);
let hook = SetWindowsHookExW(
⋮----
Some(selection_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
let is_still_held = (GetAsyncKeyState(TRIGGER_VK_CODE as i32) as u16 & 0x8000) != 0;
⋮----
sync_layered_window_contents(hwnd);
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
let _ = SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
let _ = SetTimer(Some(hwnd), CONTINUOUS_CHECK_TIMER_ID, 50, None);
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
let _ = DispatchMessageW(&msg);
⋮----
if SELECTION_ABORT_SIGNAL.load(Ordering::SeqCst) {
let _ = SendMessageW(hwnd, WM_CLOSE, Some(WPARAM(0)), Some(LPARAM(0)));
⋮----
let _ = WaitMessage();
⋮----
let hook = std::ptr::addr_of!(SELECTION_HOOK).read();
if !hook.is_invalid() {
let _ = UnhookWindowsHookEx(hook);
SELECTION_HOOK = HHOOK(std::ptr::null_mut());
⋮----
SELECTION_OVERLAY_ACTIVE.store(false, Ordering::SeqCst);
⋮----
unsafe extern "system" fn selection_hook_proc(
⋮----
SELECTION_ABORT_SIGNAL.store(true, Ordering::SeqCst);
let hwnd = std::ptr::addr_of!(SELECTION_OVERLAY_HWND).read().0;
if !hwnd.is_invalid() {
let _ = PostMessageW(Some(hwnd), WM_NULL, WPARAM(0), LPARAM(0));
⋮----
return LRESULT(1);
⋮----
if !IS_HOTKEY_HELD.load(Ordering::SeqCst) {
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
unsafe extern "system" fn selection_wnd_proc(
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(START_POS));
⋮----
SetCapture(hwnd);
⋮----
LRESULT(0)
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(LAST_PAN_POS));
⋮----
let _ = SetTimer(Some(hwnd), ZOOM_TIMER_ID, 16, None);
⋮----
let _ = ReleaseCapture();
⋮----
WM_NCHITTEST => LRESULT(HTCLIENT as _),
⋮----
let _ = GetCursorPos(std::ptr::addr_of_mut!(CURR_POS));
⋮----
let _ = GetCursorPos(&mut curr_pan);
⋮----
let _ = GetCursorPos(&mut cursor);
⋮----
ZOOM_LEVEL = (ZOOM_LEVEL + ZOOM_STEP).min(MAX_ZOOM);
⋮----
ZOOM_LEVEL = (ZOOM_LEVEL - ZOOM_STEP).max(MIN_ZOOM);
⋮----
if load_magnification_api() {
⋮----
if init_fn().as_bool() {
⋮----
let _ = GetCursorPos(&mut pt);
⋮----
left: START_POS.x.min(CURR_POS.x),
top: START_POS.y.min(CURR_POS.y),
right: START_POS.x.max(CURR_POS.x),
bottom: START_POS.y.max(CURR_POS.y),
⋮----
let width = (rect.right - rect.left).abs();
let height = (rect.bottom - rect.top).abs();
⋮----
let guard = APP.lock().unwrap();
⋮----
let old_bmp = SelectObject(hdc_mem, capture.hbitmap.into());
let sx = GetSystemMetrics(SM_XVIRTUALSCREEN);
let sy = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
let color = GetPixel(hdc_mem, local_x, local_y);
SelectObject(hdc_mem, old_bmp);
⋮----
let _ = ReleaseDC(None, hdc_screen);
⋮----
Some(format!("#{:02X}{:02X}{:02X}", r, g, b))
⋮----
let _ = transform_fn(1.0, 0, 0);
⋮----
return LRESULT(0);
⋮----
.get(CURRENT_PRESET_IDX)
.map(|p| p.is_master)
.unwrap_or(false)
⋮----
let _ = GetCursorPos(&mut cursor_pos);
ZOOM_ALPHA_OVERRIDE = Some(60);
⋮----
Some(idx)
⋮----
SetTimer(Some(hwnd), FADE_TIMER_ID, 16, None);
⋮----
Some(CURRENT_PRESET_IDX)
⋮----
(unsafe { GetAsyncKeyState(TRIGGER_VK_CODE as i32) } as u16
⋮----
let held_detected = HOLD_DETECTED_THIS_SESSION.load(Ordering::SeqCst);
⋮----
&& !CONTINUOUS_ACTIVATED_THIS_SESSION.load(Ordering::SeqCst)
⋮----
if hotkey_name.is_empty() {
⋮----
hotkey_name = "Hotkey".to_string();
⋮----
if let Ok(app) = APP.lock() {
⋮----
.get(preset_idx)
.map(|p| p.id.clone())
.unwrap_or_default()
⋮----
"Preset".to_string()
⋮----
super::continuous_mode::activate(preset_idx, hotkey_name.clone());
⋮----
CONTINUOUS_ACTIVATED_THIS_SESSION.store(true, Ordering::SeqCst);
⋮----
let mut guard = APP.lock().unwrap();
⋮----
.as_ref()
.expect("Screenshot handle missing");
let config_clone = guard.config.clone();
let preset_clone = guard.config.presets[preset_idx].clone();
let img = extract_crop_from_hbitmap(capture, rect);
⋮----
start_processing_pipeline(cropped_img, rect, config, preset);
⋮----
if diff_zoom.abs() > 0.001 {
⋮----
if dx.abs() > 0.1 || dy.abs() > 0.1 {
⋮----
let screen_w = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let screen_h = GetSystemMetrics(SM_CYVIRTUALSCREEN);
let screen_x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let screen_y = GetSystemMetrics(SM_YVIRTUALSCREEN);
⋮----
.max(screen_x as f32)
.min((screen_x + screen_w) as f32 - view_w);
⋮----
.max(screen_y as f32)
.min((screen_y + screen_h) as f32 - view_h);
let _ = transform_fn(RENDER_ZOOM, off_x as i32, off_y as i32);
⋮----
let _ = KillTimer(Some(hwnd), ZOOM_TIMER_ID);
⋮----
(unsafe { GetAsyncKeyState(TRIGGER_VK_CODE as i32) } as u16 & 0x8000) != 0;
if !is_physically_down && IS_HOTKEY_HELD.load(Ordering::SeqCst) {
⋮----
HOLD_DETECTED_THIS_SESSION.store(true, Ordering::SeqCst);
⋮----
hotkey_name.clone(),
⋮----
let _ = KillTimer(Some(hwnd), FADE_TIMER_ID);
let _ = DestroyWindow(hwnd);
PostQuitMessage(0);
⋮----
.min(TARGET_OPACITY as u16)
⋮----
let _ = BeginPaint(hwnd, &mut ps);
⋮----
let _ = EndPaint(hwnd, &mut ps);
⋮----
WM_ERASEBKGND => LRESULT(1),
⋮----
let _ = uninit_fn();
⋮----
if !std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid() {
let _ = DeleteObject(CACHED_BITMAP.0.into());
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
unsafe fn sync_layered_window_contents(hwnd: HWND) {
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
⋮----
if std::ptr::addr_of!(CACHED_BITMAP).read().is_invalid()
⋮----
let hbm = CreateDIBSection(Some(hdc_screen), &bmi, DIB_RGB_COLORS, &mut bits, None, 0);
⋮----
CACHED_BITMAP = SendHbitmap(h);
⋮----
let mem_dc = CreateCompatibleDC(Some(hdc_screen));
let old_bmp = SelectObject(mem_dc, CACHED_BITMAP.0.into());
⋮----
zoom_alpha.min(CURRENT_ALPHA)
⋮----
pixels_u32.fill(bg_val);
⋮----
let w = (r.right - r.left).abs();
let h = (r.bottom - r.top).abs();
⋮----
let radius = default_radius.min(hw).min(hh);
⋮----
let b_left = (r.left - 10).max(0);
let b_top = (r.top - 10).max(0);
let b_right = (r.right + 10).min(width);
let b_bottom = (r.bottom + 10).min(height);
let rad_int = radius.ceil() as i32;
let top_band_end = (r.top + rad_int).min(b_bottom);
let bottom_band_start = (r.bottom - rad_int).max(top_band_end);
⋮----
if row_base + lb < pixels_u32.len() {
let start = (row_base + lb).min(pixels_u32.len());
let end = (row_base + rb).min(pixels_u32.len());
⋮----
pixels_u32[start..end].fill(0x00000000);
⋮----
if row_base + lb + x < pixels_u32.len() {
⋮----
if row_base + rb - 1 - x < pixels_u32.len() {
⋮----
if idx >= pixels_u32.len() {
⋮----
let dx = (px - cx).abs() - (hw - radius);
let dy = (py - cy).abs() - (hh - radius);
⋮----
(dx * dx + dy * dy).sqrt() - radius
⋮----
dx.max(dy) - radius
⋮----
let alpha_outer = (0.5 - dist).clamp(0.0, 1.0);
let alpha_inner = (0.5 - (dist + border_width)).clamp(0.0, 1.0);
⋮----
x: GetSystemMetrics(SM_XVIRTUALSCREEN),
y: GetSystemMetrics(SM_YVIRTUALSCREEN),
⋮----
let _ = UpdateLayeredWindow(
⋮----
Some(hdc_screen),
Some(&screen_pos),
Some(&wnd_size),
Some(mem_dc),
Some(&src_pos),
COLORREF(0),
Some(&blend),
⋮----
SelectObject(mem_dc, old_bmp);
let _ = DeleteDC(mem_dc);
</file>

<file path="src/overlay/favorite_bubble/panel.rs">
use super::render::update_bubble_visual;
⋮----
use super::utils::HwndWrapper;
use crate::APP;
use std::sync::atomic::Ordering;
use windows::core::w;
⋮----
use windows::Win32::Graphics::Gdi::HBRUSH;
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::UI::Controls::MARGINS;
use windows::Win32::UI::HiDpi::GetDpiForWindow;
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
pub fn show_panel(bubble_hwnd: HWND) {
if IS_EXPANDED.load(Ordering::SeqCst) {
⋮----
let fg = GetForegroundWindow();
if !fg.is_invalid() {
LAST_FOREGROUND_HWND.store(fg.0 as isize, Ordering::SeqCst);
⋮----
let just_created = ensure_panel_created(bubble_hwnd, true);
let panel_val = PANEL_HWND.load(Ordering::SeqCst);
⋮----
let panel_hwnd = HWND(panel_val as *mut std::ffi::c_void);
IS_EXPANDED.store(true, Ordering::SeqCst);
⋮----
let _ = ShowWindow(panel_hwnd, SW_SHOWNOACTIVATE);
⋮----
let _ = PostMessageW(Some(panel_hwnd), WM_REFRESH_PANEL, WPARAM(0), LPARAM(0));
⋮----
} else if let Ok(app) = APP.lock() {
⋮----
refresh_panel_layout_and_content(
⋮----
update_bubble_visual(bubble_hwnd);
⋮----
pub fn update_favorites_panel() {
let bubble_val = BUBBLE_HWND.load(Ordering::SeqCst);
⋮----
let bubble_hwnd = HWND(bubble_val as *mut std::ffi::c_void);
⋮----
let _ = PostMessageW(Some(bubble_hwnd), WM_FORCE_SHOW_PANEL, WPARAM(0), LPARAM(0));
⋮----
pub fn ensure_panel_created(bubble_hwnd: HWND, with_webview: bool) -> bool {
⋮----
let panel_exists = PANEL_HWND.load(Ordering::SeqCst) != 0;
⋮----
create_panel_window_internal(bubble_hwnd);
⋮----
let has_webview = PANEL_WEBVIEW.with(|wv| wv.borrow().is_some());
⋮----
create_panel_webview(panel_hwnd);
⋮----
pub fn close_panel() {
if !IS_EXPANDED.swap(false, Ordering::SeqCst) {
⋮----
let webview_exists = PANEL_WEBVIEW.with(|wv| {
if let Some(webview) = wv.borrow().as_ref() {
let _ = webview.evaluate_script("if(window.closePanel) window.closePanel();");
⋮----
close_panel_internal();
⋮----
fn close_panel_internal() {
⋮----
let _ = ShowWindow(panel_hwnd, SW_HIDE);
⋮----
save_bubble_position();
⋮----
pub fn destroy_panel() {
let panel_val = PANEL_HWND.swap(0, Ordering::SeqCst);
⋮----
PANEL_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
⋮----
let _ = DestroyWindow(panel_hwnd);
⋮----
pub fn move_panel_to_bubble(bubble_x: i32, bubble_y: i32) {
⋮----
let _ = GetWindowRect(panel_hwnd, &mut panel_rect);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let bubble_size = BUBBLE_SIZE.load(Ordering::SeqCst);
⋮----
let _ = SetWindowPos(
⋮----
panel_y.max(10),
⋮----
fn create_panel_window_internal(_bubble_hwnd: HWND) {
⋮----
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTFavoritePanel");
REGISTER_PANEL_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(panel_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
let panel_hwnd = CreateWindowExW(
⋮----
w!("FavPanel"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if !panel_hwnd.is_invalid() {
PANEL_HWND.store(panel_hwnd.0 as isize, Ordering::SeqCst);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let _ = DwmExtendFrameIntoClientArea(panel_hwnd, &margins);
⋮----
unsafe fn refresh_panel_layout_and_content(
⋮----
let _ = GetWindowRect(bubble_hwnd, &mut bubble_rect);
⋮----
.iter()
.filter(|p| p.is_favorite && !p.is_upcoming)
.collect();
let fav_count = favs.len();
⋮----
(PANEL_WIDTH as i32 * 2).max(320)
⋮----
let panel_height = panel_height.max(50);
let dpi = unsafe { GetDpiForWindow(panel_hwnd) };
⋮----
let panel_width_physical = (panel_width as f32 * scale).ceil() as i32;
let panel_height_physical = (panel_height as f32 * scale).ceil() as i32;
⋮----
let actual_panel_y = panel_y.max(10);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
⋮----
let new_css = generate_panel_css(is_dark);
let escaped_css = escape_js(&new_css);
⋮----
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
⋮----
let favorites_html = get_favorite_presets_html(presets, lang, is_dark);
update_panel_content(&favorites_html, num_cols);
⋮----
fn create_panel_webview(panel_hwnd: HWND) {
⋮----
let _ = GetClientRect(panel_hwnd, &mut rect);
⋮----
let html = if let Ok(app) = APP.lock() {
⋮----
generate_panel_html(
⋮----
let wrapper = HwndWrapper(panel_hwnd);
PANEL_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = PANEL_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| format!("data:text/html,{}", urlencoding::encode(&html)));
⋮----
.with_bounds(Rect {
⋮----
.with_url(&page_url)
.with_transparent(true)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
let _ = ReleaseCapture();
SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
close_panel();
⋮----
} else if body.starts_with("trigger:") {
⋮----
IS_EXPANDED.store(false, Ordering::SeqCst);
trigger_preset(idx);
⋮----
} else if body.starts_with("trigger_only:") {
⋮----
} else if body.starts_with("trigger_continuous:") {
⋮----
activate_continuous_from_panel(idx);
⋮----
} else if body.starts_with("trigger_continuous_only:") {
⋮----
} else if body.starts_with("set_keep_open:") {
⋮----
if let Ok(mut app) = APP.lock() {
⋮----
} else if body.starts_with("resize:") {
⋮----
resize_panel_height(h);
⋮----
let new_size = (app.config.favorite_bubble_size + 8).min(80);
⋮----
BUBBLE_SIZE.store(new_size as i32, Ordering::SeqCst);
⋮----
update_favorites_panel();
⋮----
(app.config.favorite_bubble_size.saturating_sub(8)).max(24);
⋮----
.with_background_color((0, 0, 0, 0))
.build(&wrapper)
⋮----
*wv.borrow_mut() = Some(webview);
⋮----
unsafe extern "system" fn panel_wnd_proc(
⋮----
LRESULT(0)
⋮----
WM_KILLFOCUS => LRESULT(0),
⋮----
let bubble_hwnd = HWND(BUBBLE_HWND.load(Ordering::SeqCst) as *mut std::ffi::c_void);
if let Ok(app) = APP.lock() {
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
fn trigger_preset(preset_idx: usize) {
⋮----
let saved_fg = LAST_FOREGROUND_HWND.load(Ordering::SeqCst);
⋮----
let fg_hwnd = HWND(saved_fg as *mut std::ffi::c_void);
if !fg_hwnd.is_invalid() {
let _ = SetForegroundWindow(fg_hwnd);
let _ = SetFocus(Some(fg_hwnd));
⋮----
let class = w!("HotkeyListenerClass");
let title = w!("Listener");
let hwnd = FindWindowW(class, title).unwrap_or_default();
if !hwnd.is_invalid() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_HOTKEY, WPARAM(hotkey_id as usize), LPARAM(0));
⋮----
fn activate_continuous_from_panel(preset_idx: usize) {
⋮----
if let Some(p) = app.config.presets.get(preset_idx) {
(p.preset_type.clone(), p.id.clone())
⋮----
let hotkey_name = "ESC".to_string();
crate::overlay::continuous_mode::set_pending_start(preset_idx, hotkey_name.clone());
⋮----
pub fn save_bubble_position() {
⋮----
let _ = GetWindowRect(bubble_hwnd, &mut rect);
⋮----
app.config.favorite_bubble_position = Some((rect.left, rect.top));
⋮----
fn resize_panel_height(content_height: i32) {
⋮----
let dpi = GetDpiForWindow(panel_hwnd);
⋮----
let new_height_pixels = (content_height as f32 * scale).ceil() as i32 + 100;
⋮----
if (current_height - new_height_pixels).abs() < 4 {
⋮----
HWND(bubble_val as *mut std::ffi::c_void)
⋮----
fn update_panel_content(html: &str, cols: usize) {
⋮----
let escaped = escape_js(html);
</file>

<file path="src/gui/splash.rs">
use eframe::egui;
⋮----
use std::cmp::Ordering;
use std::f32::consts::PI;
⋮----
use std::cell::RefCell;
⋮----
fn smoothstep(edge0: f32, edge1: f32, x: f32) -> f32 {
let t = ((x - edge0) / (edge1 - edge0)).clamp(0.0, 1.0);
⋮----
fn lerp(a: f32, b: f32, t: f32) -> f32 {
⋮----
struct Vec3 {
⋮----
impl Vec3 {
⋮----
fn new(x: f32, y: f32, z: f32) -> Self {
⋮----
fn add(self, v: Vec3) -> Self {
⋮----
fn sub(self, v: Vec3) -> Self {
⋮----
fn mul(self, s: f32) -> Self {
⋮----
fn len(self) -> f32 {
(self.x * self.x + self.y * self.y + self.z * self.z).sqrt()
⋮----
fn normalize(self) -> Self {
let l = self.len();
⋮----
self.mul(1.0 / l)
⋮----
fn lerp(self, target: Vec3, t: f32) -> Self {
⋮----
lerp(self.x, target.x, t),
lerp(self.y, target.y, t),
lerp(self.z, target.z, t),
⋮----
fn rotate_x(self, angle: f32) -> Self {
let (s, c) = angle.sin_cos();
⋮----
fn rotate_y(self, angle: f32) -> Self {
⋮----
fn rotate_z(self, angle: f32) -> Self {
⋮----
struct Cloud {
⋮----
struct Star {
⋮----
struct MoonFeature {
⋮----
struct Voxel {
⋮----
struct SharedAudioState {
⋮----
struct RenderState {
⋮----
struct SplashAudio {
⋮----
impl SplashAudio {
fn new() -> Option<Self> {
⋮----
let device = host.default_output_device()?;
let config = device.default_output_config().ok()?;
⋮----
let sample_rate = u32::from(config.sample_rate()) as f32;
let channels = config.channels() as usize;
⋮----
.build_output_stream(
&config.into(),
⋮----
let mut s_lock = state_clone.lock().unwrap();
⋮----
for x in data.iter_mut() {
⋮----
drop(s_lock);
for frame in data.chunks_mut(channels) {
let attack = (physics_t / 0.05).min(1.0);
let decay = (1.0 - (physics_t - 1.6).max(0.0) / 0.8).max(0.0);
⋮----
let s1 = (r.phase * base_freq * 2.0 * PI / sample_rate).sin();
let s2 = (r.phase * base_freq * 1.5 * 2.0 * PI / sample_rate).sin();
let s3 = (r.phase * base_freq * 2.5 * 2.0 * PI / sample_rate).sin();
⋮----
let raw_noise = ((r.phase * 0.013).sin() * 43758.5453).fract();
⋮----
(r.noise_phase * 0.994 + (raw_noise - 0.5) * 0.012).clamp(-1.0, 1.0);
⋮----
let h1 = (r.phase * f_base * 1.0 * 2.0 * PI / sample_rate).sin();
let h2 = (r.phase * f_base * 2.1 * 2.0 * PI / sample_rate).sin();
let h3 = (r.phase * f_base * 3.5 * 2.0 * PI / sample_rate).sin();
⋮----
let whoosh_freq = 80.0 + p.powf(1.5) * 4500.0;
let attack_w = (p / 0.1).min(1.0);
let decay_w = (1.0 - (p - 0.15).max(0.0) / 0.7).max(0.0);
⋮----
(r.phase * whoosh_freq * 2.0 * PI / sample_rate).sin() * whoosh_vol;
⋮----
let mixed = (voxels + wind + impact + whoosh).clamp(-1.0, 1.0);
for sample in frame.iter_mut() {
⋮----
.ok()?;
stream.play().ok()?;
Some(Self {
⋮----
pub struct SplashScreen {
⋮----
pub enum SplashStatus {
⋮----
impl SplashScreen {
pub fn new(ctx: &egui::Context) -> Self {
let is_dark = ctx.style().visuals.dark_mode;
⋮----
let audio_container_clone = audio_container.clone();
⋮----
if let Ok(mut lock) = audio_container_clone.lock() {
*lock = Some(audio);
⋮----
start_time: ctx.input(|i| i.time),
⋮----
loading_text: "TRANSLATING...".to_string(),
⋮----
slf.init_scene();
⋮----
pub fn reset_timer(&mut self, ctx: &egui::Context) {
self.start_time = ctx.input(|i| i.time);
⋮----
fn init_scene(&mut self) {
⋮----
.duration_since(std::time::UNIX_EPOCH)
.map(|d| d.as_nanos() as u64)
.unwrap_or(987654321u64);
⋮----
rng_state = rng_state.wrapping_mul(6364136223846793005).wrapping_add(1);
⋮----
for (y, row) in map.iter().enumerate() {
for (x, ch) in row.chars().enumerate() {
⋮----
self.voxels.push(Voxel {
⋮----
rot: Vec3::new(rng() * 6.0, rng() * 6.0, rng() * 6.0),
⋮----
color: if rng() > 0.85 { C_WHITE } else { color_theme },
noise_factor: rng(),
⋮----
spawn_letter(&s_map, -120.0, c_secondary);
spawn_letter(&g_map, -35.0, c_primary);
spawn_letter(&t_map, 50.0, c_secondary);
⋮----
let h_y = (rng() * 300.0) - 150.0;
let h_radius = 80.0 + rng() * 60.0;
let h_angle = rng() * PI * 2.0;
let n = rng();
let t_y = rng() * 700.0 - 50.0;
let t_dist = 400.0 + n.powi(2) * 1400.0;
let target = Vec3::new(h_angle.cos() * t_dist, t_y, h_angle.sin() * t_dist);
⋮----
rot: Vec3::new(rng(), rng(), rng()),
⋮----
self.stars.push(Star {
pos: Vec2::new(rng(), rng() * 0.85),
phase: rng() * PI * 2.0,
brightness: 0.3 + rng() * 0.7,
size: if rng() > 0.95 {
1.5 + rng()
⋮----
0.8 + rng() * 0.5
⋮----
puffs.push((Vec2::ZERO, 1.0));
let num_puffs = 5 + (rng() * 4.0) as usize;
⋮----
let angle = rng() * PI * 2.0;
let dist = 15.0 + rng() * 25.0;
let r_mult = 0.4 + rng() * 0.5;
puffs.push((
Vec2::new(angle.cos() * dist, angle.sin() * dist * 0.6),
⋮----
self.clouds.push(Cloud {
pos: Vec2::new(rng() * 1200.0 - 600.0, rng() * 400.0 - 200.0),
velocity: 5.0 + rng() * 15.0,
scale: 1.2 + rng() * 1.5,
opacity: 0.4 + rng() * 0.4,
⋮----
let dist = rng().sqrt() * 0.7;
let pos = Vec2::new(angle.cos() * dist, angle.sin() * dist);
self.moon_features.push(MoonFeature {
⋮----
radius: 0.15 + rng() * 0.25,
⋮----
let dist = rng().powf(0.8);
⋮----
radius: 0.02 + rng() * 0.06,
⋮----
pub fn update(&mut self, ctx: &egui::Context) -> SplashStatus {
self.is_dark = ctx.style().visuals.dark_mode;
let now = ctx.input(|i| i.time);
let dt = ctx.input(|i| i.stable_dt);
if self.exit_start_time.is_none() {
⋮----
if ctx.input(|i| i.pointer.any_click()) {
let is_in_switcher = if let Some(pos) = ctx.input(|i| i.pointer.latest_pos()) {
⋮----
self.exit_start_time = Some(now);
⋮----
let physics_t = t_abs.min(ANIMATION_DURATION);
⋮----
if let Ok(mut lock) = self.audio.lock() {
if let Some(audio) = lock.as_mut() {
if let Ok(mut s) = audio.state.lock() {
⋮----
warp_progress = (dt / EXIT_DURATION).clamp(0.0, 1.0);
⋮----
drop(s);
⋮----
ctx.request_repaint();
let viewport_rect = ctx.input(|i| {
i.viewport()
⋮----
.unwrap_or(Rect::from_min_size(Pos2::ZERO, Vec2::ZERO))
⋮----
let size = if viewport_rect.width() < 100.0 || viewport_rect.height() < 100.0 {
⋮----
viewport_rect.size()
⋮----
if cloud.pos.x > rect.width() / 2.0 + 300.0 {
cloud.pos.x = -rect.width() / 2.0 - 300.0;
⋮----
if let Some(pointer) = ctx.input(|i| i.pointer.hover_pos()) {
let center = rect.center();
⋮----
600.0 + smoothstep(0.0, ANIMATION_DURATION, physics_t) * 100.0 - cam_z_offset;
⋮----
self.loading_text = "TRANSLATING...".to_string();
⋮----
self.loading_text = "OCR...".to_string();
⋮----
self.loading_text = "TRANSCRIBING...".to_string();
⋮----
self.loading_text = "nganlinh4".to_string();
⋮----
self.loading_text = "READY TO ROCK!".to_string();
⋮----
let progress = smoothstep(my_start, my_end, physics_t);
⋮----
let current_h_y = v.helix_y + (physics_t * 2.0 + v.noise_factor * 10.0).sin() * 5.0;
⋮----
let flare = (physics_t - flare_start).powi(2) * 20.0;
⋮----
current_angle.cos() * current_radius,
⋮----
current_angle.sin() * current_radius,
⋮----
target_base = target_base.rotate_y(t_abs * orbit_speed);
target_base.y += (t_abs * 0.5 + v.noise_factor * 10.0).sin() * 20.0;
⋮----
((warp_progress - start_threshold) / move_duration).clamp(0.0, 1.0);
⋮----
let radial = Vec3::new(v.pos.x, v.pos.y, 0.0).normalize();
⋮----
let swirl_vec = radial.rotate_z(curl_angle);
⋮----
target_base = target_base.add(swirl_vec.mul(local_eased * dist_mult));
⋮----
let pos = helix_pos.lerp(target_base, progress);
⋮----
let to_mouse = pos.sub(self.mouse_world_pos);
⋮----
let dist = dist_sq.sqrt();
⋮----
v.velocity = v.velocity.add(to_mouse.normalize().mul(force * 2.0));
⋮----
let displacement = pos.sub(target_base);
let spring_force = displacement.mul(-0.1);
v.velocity = v.velocity.add(spring_force);
v.velocity = v.velocity.mul(0.90);
v.pos = pos.add(v.velocity);
v.rot = v.rot.lerp(Vec3::ZERO, 0.1);
⋮----
let impact = (physics_t - my_end).max(0.0);
let pulse = (impact * 10.0).sin() * (-3.0 * impact).exp() * 0.5;
⋮----
v.scale = lerp(0.8, 1.0, progress);
⋮----
pub fn paint(&self, ctx: &egui::Context, _theme_mode: &crate::config::ThemeMode) -> bool {
⋮----
warp_prog = (dt / EXIT_DURATION).powi(5);
⋮----
.order(egui::Order::Foreground)
.fixed_pos(Pos2::ZERO)
.show(ctx, |ui| {
let resp = ui.allocate_response(
⋮----
egui::Sense::click_and_drag().union(egui::Sense::hover()),
⋮----
if resp.drag_started() {
ui.ctx().send_viewport_cmd(egui::ViewportCommand::StartDrag);
⋮----
let painter = ctx.layer_painter(egui::LayerId::new(
⋮----
let master_alpha = alpha.clamp(0.0, 1.0);
⋮----
(1.0 - exit_dt / 0.3).max(0.0)
⋮----
.order(egui::Order::Tooltip)
.fixed_pos(Pos2::new(14.0, 11.0))
⋮----
let pulse = (now * 2.0).sin().abs() * 0.2 + 0.8;
⋮----
Color32::WHITE.linear_multiply(switcher_alpha)
⋮----
Color32::BLACK.linear_multiply(switcher_alpha)
⋮----
ui.allocate_at_least(Vec2::splat(32.0), egui::Sense::click());
let fill = if resp.hovered() {
btn_bg.linear_multiply(1.5)
⋮----
btn_bg.linear_multiply(pulse as f32)
⋮----
ui.painter().rect_filled(rect, 8.0, fill);
let old_panel_fill = ctx.style().visuals.panel_fill;
⋮----
Color32::from_rgb(109, 174, 235).linear_multiply(switcher_alpha);
ctx.style_mut(|s| s.visuals.panel_fill = cutout_color);
⋮----
paint_icon(ui.painter(), rect.shrink(6.0), icon, icon_color);
ctx.style_mut(|s| s.visuals.panel_fill = old_panel_fill);
if resp.clicked() && switcher_alpha > 0.9 {
⋮----
let t_fade = (t / 0.5).clamp(0.0, 1.0);
⋮----
lerp(start_col.r() as f32, bg_color.r() as f32, t_fade) as u8,
lerp(start_col.g() as f32, bg_color.g() as f32, t_fade) as u8,
lerp(start_col.b() as f32, bg_color.b() as f32, t_fade) as u8,
⋮----
let sky_exit_fade = (1.0 - warp_prog * 4.0).clamp(0.0, 1.0);
⋮----
painter.rect_filled(rect, 12.0, bg_color.linear_multiply(sky_exit_fade));
⋮----
let c_top = C_SKY_DAY_TOP.linear_multiply(sky_exit_fade);
painter.rect_filled(rect, 12.0, c_top);
⋮----
for (i, star) in self.stars.iter().enumerate() {
let sx = rect.left() + (star.pos.x * rect.width()) + star_offset.x;
let sy = rect.top() + (star.pos.y * rect.height()) + star_offset.y;
let rnd = ((i as f32 * 1.618).fract() + (star.pos.x * 10.0).fract()).fract();
⋮----
let p = ((warp_prog - start) / dur).clamp(0.0, 1.0);
⋮----
let twinkle = (star.phase + star_time).sin() * 0.3 + 0.7;
⋮----
(star.brightness * twinkle * master_alpha * local_fade).clamp(0.0, 1.0);
⋮----
painter.circle_filled(
⋮----
C_WHITE.linear_multiply(star_alpha),
⋮----
C_WHITE.linear_multiply(day_star_alpha),
⋮----
let v_idx = mesh.vertices.len() as u32;
mesh.vertices.push(egui::epaint::Vertex {
⋮----
let p1 = sun_pos + Vec2::new(angle.cos() * ray_len, angle.sin() * ray_len);
⋮----
sun_pos + Vec2::new(next_angle.cos() * ray_len, next_angle.sin() * ray_len);
⋮----
mesh.add_triangle(v_idx, v_idx + 1, v_idx + 2);
⋮----
painter.add(mesh);
⋮----
let moon_alpha = master_alpha * (1.0 - warp_prog * 3.0).clamp(0.0, 1.0);
⋮----
let moon_bob = (t * 0.5).sin() * 5.0;
⋮----
C_MOON_GLOW.linear_multiply(0.03 * moon_alpha),
⋮----
C_MOON_GLOW.linear_multiply(0.08 * moon_alpha),
⋮----
C_MOON_BASE.linear_multiply(moon_alpha),
⋮----
let rot_cos = feature_rot.cos();
let rot_sin = feature_rot.sin();
⋮----
let z_depth = (1.0 - dist_sq).sqrt();
⋮----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.8),
⋮----
C_MOON_HIGHLIGHT.linear_multiply(f_alpha * 0.4),
⋮----
C_MOON_SHADOW.linear_multiply(f_alpha * 0.3),
⋮----
painter.circle_stroke(
⋮----
Stroke::new(2.0, C_MOON_HIGHLIGHT.linear_multiply(0.4 * moon_alpha)),
⋮----
let sun_bob = (t * 0.5).sin() * 5.0;
⋮----
C_SUN_GLOW.linear_multiply(0.1 * moon_alpha),
⋮----
C_SUN_GLOW.linear_multiply(0.2 * moon_alpha),
⋮----
C_SUN_BODY.linear_multiply(moon_alpha),
⋮----
Color32::from_rgb(160, 60, 0).linear_multiply(f_alpha * 0.8),
⋮----
C_SUN_FLARE.linear_multiply(f_alpha * 0.3),
⋮----
C_WHITE.linear_multiply(f_alpha * 0.5),
⋮----
Stroke::new(3.0, C_SUN_HIGHLIGHT.linear_multiply(0.5 * moon_alpha)),
⋮----
painter.with_clip_rect(Rect::from_min_max(
⋮----
painter.clone()
⋮----
for (i, cloud) in self.clouds.iter().enumerate() {
⋮----
let rnd = (i as f32 * 0.73).fract();
⋮----
C_CLOUD_CORE.linear_multiply(cloud_alpha * 0.95)
⋮----
C_CLOUD_WHITE.linear_multiply(cloud_alpha * 0.95)
⋮----
cloud_painter.circle_filled(
⋮----
let render_t = t.min(ANIMATION_DURATION + 5.0);
⋮----
let rnd = (i as f32 * 0.9).sin() * 0.5 + 0.5;
⋮----
let perspective = 250.0 / (z_dist - warp_prog * 0.8).max(0.1);
⋮----
if y > rect.bottom() || y < horizon {
⋮----
let w = rect.width() * (2.5 / z_dist);
⋮----
let alpha_grid = (1.0 - (y - horizon) / (rect.bottom() - horizon)).powf(0.5)
⋮----
(C_DAY_REP, 4.0 * (1.0 - (y - horizon) / rect.height()))
⋮----
painter.line_segment(
⋮----
Stroke::new(thickness, grid_col.linear_multiply(alpha_grid)),
⋮----
let physics_t = t.min(ANIMATION_DURATION);
⋮----
let cam_dist = (600.0 + smoothstep(0.0, 8.0, physics_t) * 100.0) - cam_fly_dist;
⋮----
let mut draw_list_ref = self.draw_list.borrow_mut();
draw_list_ref.clear();
⋮----
local_debris_alpha = 1.0 - smoothstep(fade_start, fade_end, physics_t);
⋮----
.rotate_x(global_rot.x)
.rotate_y(global_rot.y)
.rotate_z(global_rot.z);
⋮----
(t * (3.0 + v.noise_factor * 2.0) + v.noise_factor * 50.0).sin() * 0.25 + 0.75;
⋮----
let local_linear = ((warp_prog - start_threshold) / move_duration).clamp(0.0, 1.0);
let fade = (local_linear * 1.5).clamp(0.0, 1.0);
⋮----
let final_col = base_col.linear_multiply(alpha_local);
draw_list.push((
⋮----
draw_list.sort_by(|a, b| b.0.partial_cmp(&a.0).unwrap_or(Ordering::Equal));
for (_, pos, r, col, is_white_voxel, is_debris) in draw_list.iter().copied() {
⋮----
Color32::from_black_alpha(200).linear_multiply(col.a() as f32 / 255.0)
⋮----
Color32::from_rgb(100, 120, 150).linear_multiply(col.a() as f32 / 255.0)
⋮----
Color32::from_rgb(0, 40, 100).linear_multiply(col.a() as f32 / 255.0)
⋮----
p.circle_filled(pos, r, shadow_col);
⋮----
p.circle_filled(pos + body_offset, r * 0.85, col);
⋮----
Color32::WHITE.linear_multiply(0.5)
⋮----
col.linear_multiply(0.5)
⋮----
p.circle_filled(pos + gradient_offset, r * 0.5, glow_col);
⋮----
p.circle_filled(pos, r, col);
⋮----
.linear_multiply(col.a() as f32 / 255.0);
painter.circle_filled(highlight_pos, r * 0.25, highlight_col);
⋮----
Color32::WHITE.linear_multiply(col.a() as f32 / 255.0),
⋮----
let ui_alpha = 1.0 - (warp_prog * 10.0).clamp(0.0, 1.0);
⋮----
let ui_color = ui_text_col.linear_multiply(master_alpha * ui_alpha);
⋮----
C_CYAN.linear_multiply(master_alpha * ui_alpha)
⋮----
C_DAY_TEXT.linear_multiply(master_alpha * ui_alpha)
⋮----
C_WHITE.linear_multiply(master_alpha * ui_alpha)
⋮----
C_MAGENTA.linear_multiply(master_alpha * ui_alpha)
⋮----
C_DAY_REP.linear_multiply(master_alpha * ui_alpha)
⋮----
let title_text = format!("SCREEN GOATED TOOLBOX {}", env!("CARGO_PKG_VERSION"));
⋮----
painter.text(
⋮----
title_font.clone(),
⋮----
painter.rect_filled(bar_rect, 2.0, bar_bg_col);
let prog = (physics_t / (ANIMATION_DURATION - 0.5)).clamp(0.0, 1.0);
⋮----
fill.set_width(bar_rect.width() * prog);
painter.rect_filled(fill, 2.0, magenta_color);
⋮----
let pulse = (t * 5.0).sin().abs() * 0.7 + 0.3;
⋮----
click_col.linear_multiply(pulse),
</file>

<file path="src/overlay/result/markdown_view.rs">
use std::collections::HashMap;
use std::num::NonZeroIsize;
use std::sync::Mutex;
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> Result<WindowHandle<'_>, HandleError> {
⋮----
// hinstance is optional, can be null
⋮----
// Safety: the handle is valid for the lifetime of HwndWrapper
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
/// Warmup removed as per user request
#[allow(dead_code)]
pub fn warmup() {}
/// Get font CSS for markdown view (uses locally cached fonts)
fn get_font_style() -> String {
⋮----
fn get_font_style() -> String {
format!(
⋮----
/// CSS styling for the markdown content
const MARKDOWN_CSS: &str = r#"
⋮----
/// Minimal HTML escaping for text content
fn escape_html_text(text: &str) -> String {
⋮----
fn escape_html_text(text: &str) -> String {
text.replace("&", "&amp;")
.replace("<", "&lt;")
.replace(">", "&gt;")
.replace("\"", "&quot;")
.replace("'", "&#39;")
⋮----
/// Check if content is already HTML (rather than Markdown)
fn is_html_content(content: &str) -> bool {
⋮----
fn is_html_content(content: &str) -> bool {
let trimmed = content.trim();
// Check for HTML doctype or opening html tag
trimmed.starts_with("<!DOCTYPE") ||
trimmed.starts_with("<!doctype") ||
trimmed.starts_with("<html") ||
trimmed.starts_with("<HTML") ||
// Check for common HTML structure patterns
(trimmed.contains("<html") && trimmed.contains("</html>")) ||
(trimmed.contains("<head") && trimmed.contains("</head>")) ||
// Also detect HTML fragments (has script/style but no html wrapper)
is_html_fragment(content)
⋮----
/// Check if content is an HTML fragment (has HTML-like content but no document wrapper)
/// Examples: <div><style>...</style><script>...</script></div>
⋮----
/// Examples: <div><style>...</style><script>...</script></div>
fn is_html_fragment(content: &str) -> bool {
⋮----
fn is_html_fragment(content: &str) -> bool {
let lower = content.to_lowercase();
// Has script or style tags but no html/doctype wrapper
(lower.contains("<script") || lower.contains("<style"))
&& !lower.contains("<!doctype")
&& !lower.contains("<html")
⋮----
/// Wrap an HTML fragment in a proper document structure
/// This ensures WebView2 can properly parse the DOM
⋮----
/// This ensures WebView2 can properly parse the DOM
fn wrap_html_fragment(fragment: &str) -> String {
⋮----
fn wrap_html_fragment(fragment: &str) -> String {
⋮----
/// Inject localStorage/sessionStorage polyfill into HTML for WebView2 compatibility
/// WebView2's with_html() runs in a sandboxed context that denies storage access
⋮----
/// WebView2's with_html() runs in a sandboxed context that denies storage access
fn inject_storage_polyfill(html: &str) -> String {
⋮----
fn inject_storage_polyfill(html: &str) -> String {
let html = if is_html_fragment(html) {
wrap_html_fragment(html)
⋮----
html.to_string()
⋮----
let lower = html.to_lowercase();
if let Some(pos) = lower.find("<head>") {
⋮----
let mut result = html[..insert_pos].to_string();
result.push_str(polyfill);
result.push_str(&html[insert_pos..]);
⋮----
} else if let Some(pos) = lower.find("<head ") {
if let Some(end) = html[pos..].find('>') {
⋮----
format!("{}{}", polyfill, html)
⋮----
} else if let Some(pos) = lower.find("<html>") {
⋮----
} else if let Some(pos) = lower.find("<html ") {
⋮----
fn inject_gridjs(html: &str) -> String {
if !html.contains("<table") {
return html.to_string();
⋮----
let gridjs_head = format!(
⋮----
let gridjs_body = format!(
⋮----
let mut result = html.to_string();
// Inject CSS/JS into <head>
if let Some(pos) = lower.find("</head>") {
result.insert_str(pos, &gridjs_head);
} else if let Some(pos) = lower.find("<body>") {
⋮----
result.insert_str(0, &gridjs_head);
⋮----
// Inject init script into <body>
let lower_updated = result.to_lowercase();
if let Some(pos) = lower_updated.find("</body>") {
result.insert_str(pos, &gridjs_body);
⋮----
result.push_str(&gridjs_body);
⋮----
/// Inject CSS to hide scrollbars while preserving scrolling functionality
fn inject_scrollbar_css(html: &str) -> String {
⋮----
fn inject_scrollbar_css(html: &str) -> String {
⋮----
result.insert_str(pos, css);
⋮----
result.insert_str(0, css);
⋮----
/// Auto-scaling is now handled purely via CSS clamp() in MARKDOWN_CSS
/// This function is kept as a no-op for compatibility
⋮----
/// This function is kept as a no-op for compatibility
fn inject_auto_scaling(html: &str) -> String {
⋮----
fn inject_auto_scaling(html: &str) -> String {
⋮----
/// Get theme CSS variables based on mode
fn get_theme_css(is_dark: bool) -> String {
⋮----
fn get_theme_css(is_dark: bool) -> String {
⋮----
.to_string()
⋮----
/// Convert markdown text to styled HTML, or pass through raw HTML
pub fn markdown_to_html(
⋮----
pub fn markdown_to_html(
⋮----
let theme_css = get_theme_css(is_dark);
⋮----
let combined = if input_text.is_empty() {
preset_prompt.to_string()
⋮----
format!("{}\n\n{}", preset_prompt, input_text)
⋮----
return format!(
⋮----
"" // No extra script
⋮----
// If input is already HTML, inject localStorage polyfill, Grid.js, and hidden scrollbar styles
if is_html_content(markdown) {
let with_storage = inject_storage_polyfill(markdown);
let with_grid = inject_gridjs(&with_storage);
return inject_scrollbar_css(&with_grid);
⋮----
options.insert(Options::ENABLE_TABLES);
options.insert(Options::ENABLE_STRIKETHROUGH);
options.insert(Options::ENABLE_TASKLISTS);
⋮----
// Custom wrapper to enable word-level interaction
// We map text events to HTML events containing wrapped words
⋮----
let wrapped_parser = parser.map(|event| {
⋮----
// Inline code event - return as is
⋮----
// Split text into words and wrap
let mut output = String::with_capacity(text.len() * 2);
let escaped = escape_html_text(&text);
for (i, part) in escaped.split(' ').enumerate() {
⋮----
output.push(' ');
⋮----
if part.trim().is_empty() {
output.push_str(part);
⋮----
output.push_str("<span class=\"word\">");
⋮----
output.push_str("</span>");
⋮----
Event::Html(output.into())
⋮----
// Grid.js Integration
let has_table = html_output.contains("<table");
⋮----
let final_html = format!(
⋮----
inject_auto_scaling(&final_html)
⋮----
/// Create a WebView child window for markdown rendering
/// Must be called from the main thread!
⋮----
/// Must be called from the main thread!
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
⋮----
pub fn create_markdown_webview(parent_hwnd: HWND, markdown_text: &str, is_hovered: bool) -> bool {
⋮----
let states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get(&hwnd_key) {
⋮----
state.preset_prompt.clone(),
state.input_text.clone(),
⋮----
create_markdown_webview_ex(
⋮----
/// Create a WebView child window for markdown rendering (Internal version, call without lock if possible)
pub fn create_markdown_webview_ex(
⋮----
pub fn create_markdown_webview_ex(
⋮----
// Check if we already have a webview
let exists = WEBVIEWS.with(|webviews| webviews.borrow().contains_key(&hwnd_key));
⋮----
return update_markdown_content_ex(
⋮----
// Get parent window rect
⋮----
let _ = GetClientRect(parent_hwnd, &mut rect);
⋮----
let html_content = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
let wrapper = HwndWrapper(parent_hwnd);
// Edge margins: 4px left/right for resize handles, 2px top/bottom
// 52px at bottom for buttons (btn_size 28 + margin 12 * 2) if hovered
⋮----
let content_width = ((rect.right - rect.left) as f64 - margin_x * 2.0).max(50.0);
let content_height = ((rect.bottom - rect.top) as f64 - margin_y - button_area_height).max(0.0); // No min height - allow shrink for button bar
// Create WebView with small margins so resize handles remain accessible
// Use Physical coordinates since GetClientRect returns physical pixels
⋮----
// html_content is already a full HTML document from markdown_to_html
⋮----
// Use store_html_page with safe, minimal retry (max 100ms total block)
⋮----
crate::overlay::html_components::font_manager::store_html_page(full_html.clone())
⋮----
if page_url.is_empty() {
⋮----
crate::overlay::html_components::font_manager::store_html_page(error_html.to_string())
⋮----
page_url = format!("data:text/html,{}", urlencoding::encode(&error_html));
⋮----
// Use SHARED_WEB_CONTEXT instead of creating a new one every time to keep RAM at 80MB
⋮----
// LOCK SCOPE: Serialized build to prevent resource contention
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = SHARED_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
// Initialization check
if ctx_ref.is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx_ref = Some(wry::WebContext::new(Some(shared_data_dir)));
⋮----
let mut builder = WebViewBuilder::new_with_web_context(ctx_ref.as_mut().unwrap())
.with_bounds(Rect {
⋮----
.with_url(&page_url)
.with_transparent(true);
builder = builder.with_navigation_handler(move |url: String| {
⋮----
let mut skip_map = SKIP_NEXT_NAVIGATION.lock().unwrap();
if skip_map.get(&hwnd_key_for_nav).copied().unwrap_or(false) {
skip_map.insert(hwnd_key_for_nav, false);
⋮----
let is_internal = url.contains("wry.localhost")
|| url.contains("localhost")
|| url.contains("127.0.0.1")
|| url.starts_with("data:")
|| url.starts_with("about:");
⋮----
(url.starts_with("http://") || url.starts_with("https://")) && !is_internal;
⋮----
if let Ok(mut states) = super::state::WINDOW_STATES.lock() {
if let Some(state) = states.get_mut(&hwnd_key_for_nav) {
⋮----
crate::overlay::result::button_canvas::update_window_position(HWND(
⋮----
Some(HWND(hwnd_key_for_nav as *mut std::ffi::c_void)),
⋮----
HWND(hwnd_key_for_nav as *mut std::ffi::c_void),
⋮----
builder = builder.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
handle_markdown_ipc(parent_hwnd, body);
if body.starts_with("opacity:") {
if let Ok(opacity_percent) = body["opacity:".len()..].parse::<f32>() {
⋮----
use windows::Win32::Foundation::COLORREF;
⋮----
let _ = SetLayeredWindowAttributes(
⋮----
COLORREF(0),
⋮----
.build_as_child(&wrapper)
⋮----
WEBVIEWS.with(|webviews| {
webviews.borrow_mut().insert(hwnd_key, webview);
⋮----
let mut states = WEBVIEW_STATES.lock().unwrap();
states.insert(hwnd_key, true);
⋮----
pub fn go_back(parent_hwnd: HWND) {
⋮----
let mut states = super::state::WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&hwnd_key) {
⋮----
(true, state.full_text.clone(), state.is_hovered)
⋮----
create_markdown_webview(parent_hwnd, &markdown_text, is_hovered);
⋮----
let _ = windows::Win32::Graphics::Gdi::InvalidateRect(Some(parent_hwnd), None, false);
⋮----
skip_map.insert(hwnd_key, true);
⋮----
if let Some(webview) = webviews.borrow().get(&hwnd_key) {
let _ = webview.evaluate_script("history.back();");
⋮----
pub fn go_forward(parent_hwnd: HWND) {
⋮----
let _ = webview.evaluate_script("history.forward();");
⋮----
pub fn update_markdown_content(parent_hwnd: HWND, markdown_text: &str) -> bool {
⋮----
update_markdown_content_ex(
⋮----
fn content_needs_recreation(html: &str) -> bool {
⋮----
lower.contains("<script")
&& (lower.contains("localstorage")
|| lower.contains("sessionstorage")
|| lower.contains("indexeddb")
|| lower.contains("const ")
|| lower.contains("let ")
|| lower.contains("var "))
⋮----
pub fn update_markdown_content_ex(
⋮----
let html = markdown_to_html(markdown_text, is_refining, preset_prompt, input_text);
if content_needs_recreation(&html) {
destroy_markdown_webview(parent_hwnd);
⋮----
if let Ok(states) = super::state::WINDOW_STATES.lock() {
states.get(&hwnd_key).map(|s| s.is_hovered).unwrap_or(false)
⋮----
return create_markdown_webview_ex(
⋮----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${");
let script = format!(
⋮----
let _ = webview.evaluate_script(&script);
⋮----
pub fn stream_markdown_content(parent_hwnd: HWND, markdown_text: &str) -> bool {
⋮----
stream_markdown_content_ex(
⋮----
pub fn stream_markdown_content_ex(
⋮----
let body_content = if let Some(body_start) = html.find("<body>") {
⋮----
if let Some(body_end) = after_body.find("</body>") {
⋮----
/// Reset the stream content tracker (call when streaming ends)
/// This ensures the next streaming session starts fresh
⋮----
/// This ensures the next streaming session starts fresh
pub fn reset_stream_counter(parent_hwnd: HWND) {
⋮----
pub fn reset_stream_counter(parent_hwnd: HWND) {
⋮----
// Reset stream counters only - font will be reset at start of next session
let _ = webview.evaluate_script(
⋮----
/// Fit font size to window - call after streaming ends or on content update
/// This runs a ONE-TIME font fit calculation (no loops, no observers, safe)
⋮----
/// This runs a ONE-TIME font fit calculation (no loops, no observers, safe)
/// Scales font UP if there's unfilled space, scales DOWN if overflow (but never below 8px)
⋮----
/// Scales font UP if there's unfilled space, scales DOWN if overflow (but never below 8px)
pub fn fit_font_to_window(parent_hwnd: HWND) {
⋮----
pub fn fit_font_to_window(parent_hwnd: HWND) {
⋮----
let _ = webview.evaluate_script(script);
⋮----
/// Trigger Grid.js initialization on any tables in the WebView
/// Call this after streaming ends to convert tables to interactive Grid.js tables
⋮----
/// Call this after streaming ends to convert tables to interactive Grid.js tables
pub fn init_gridjs(parent_hwnd: HWND) {
⋮----
pub fn init_gridjs(parent_hwnd: HWND) {
⋮----
// Trigger the table initialization via the MutationObserver's mechanism
// The observer watches for DOM changes and schedules initGridJs via window.gridJsTimeout
// We can simulate this by triggering a DOM change or directly calling the init logic
⋮----
/// Resize the WebView to match parent window
/// When hovered: leaves 52px at bottom for buttons
⋮----
/// When hovered: leaves 52px at bottom for buttons
/// When not hovered: expands to full height for clean view
⋮----
/// When not hovered: expands to full height for clean view
/// When refine input active: starts 44px from top (40px input + 4px gap)
⋮----
/// When refine input active: starts 44px from top (40px input + 4px gap)
pub fn resize_markdown_webview(parent_hwnd: HWND, _is_hovered: bool) {
⋮----
pub fn resize_markdown_webview(parent_hwnd: HWND, _is_hovered: bool) {
⋮----
let top_offset = 2.0; // 2px edge margin
⋮----
// Always use margin_y, as buttons are now floating on a separate canvas
⋮----
((rect.bottom - rect.top) as f64 - top_offset - button_area_height).max(0.0);
⋮----
let _ = webview.set_bounds(Rect {
⋮----
/// Hide the WebView (toggle back to plain text)
pub fn hide_markdown_webview(parent_hwnd: HWND) {
⋮----
pub fn hide_markdown_webview(parent_hwnd: HWND) {
⋮----
let _ = webview.set_visible(false);
⋮----
/// Show the WebView (toggle to markdown mode)
pub fn show_markdown_webview(parent_hwnd: HWND) {
⋮----
pub fn show_markdown_webview(parent_hwnd: HWND) {
⋮----
let _ = webview.set_visible(true);
⋮----
/// Destroy the WebView when window closes
pub fn destroy_markdown_webview(parent_hwnd: HWND) {
⋮----
pub fn destroy_markdown_webview(parent_hwnd: HWND) {
⋮----
webviews.borrow_mut().remove(&hwnd_key);
⋮----
states.remove(&hwnd_key);
⋮----
/// Check if markdown webview exists for this window
pub fn has_markdown_webview(parent_hwnd: HWND) -> bool {
⋮----
pub fn has_markdown_webview(parent_hwnd: HWND) -> bool {
⋮----
let states = WEBVIEW_STATES.lock().unwrap();
states.get(&hwnd_key).copied().unwrap_or(false)
⋮----
/// Generate a filename using Cerebras' gpt-oss-120b model
fn generate_filename(content: &str) -> String {
⋮----
fn generate_filename(content: &str) -> String {
let default_name = "result.html".to_string();
let cerebras_key = if let Ok(app) = crate::APP.lock() {
app.config.cerebras_api_key.clone()
⋮----
if cerebras_key.is_empty() {
⋮----
let prompt_content = if content.len() > 4000 {
⋮----
let prompt = format!(
⋮----
.post("https://api.cerebras.ai/v1/chat/completions")
.header("Authorization", &format!("Bearer {}", cerebras_key))
.send_json(payload)
⋮----
if let Ok(json) = resp.into_body().read_json::<serde_json::Value>() {
⋮----
.get("choices")
.and_then(|c| c.as_array())
.and_then(|c| c.first())
⋮----
.get("message")
.and_then(|m| m.get("content"))
.and_then(|s| s.as_str())
⋮----
let mut name = content.trim().to_string();
name = name.replace('"', "").replace('\'', "").replace('`', "");
// Remove potential .html extension if the model disobeyed
if name.to_lowercase().ends_with(".html") {
name = name[..name.len() - 5].to_string();
⋮----
if name.to_lowercase().ends_with("-html") {
⋮----
} else if name.to_lowercase().ends_with("_html") {
⋮----
.chars()
.filter(|c| !invalid_chars.contains(c))
.collect();
if name.is_empty() {
⋮----
name.push_str(".html");
⋮----
eprintln!("Failed to generate filename: {}", e);
⋮----
pub fn save_html_file(markdown_text: &str) -> bool {
use std::ffi::OsStr;
use std::os::windows::ffi::OsStrExt;
use windows::core::PCWSTR;
⋮----
use windows::Win32::UI::Shell::Common::COMDLG_FILTERSPEC;
use windows::Win32::UI::Shell::KNOWN_FOLDER_FLAG;
⋮----
let _ = CoInitializeEx(None, COINIT_APARTMENTTHREADED);
let dialog: IFileSaveDialog = match CoCreateInstance(&FileSaveDialog, None, CLSCTX_ALL) {
⋮----
CoUninitialize();
⋮----
.encode_wide()
.chain(std::iter::once(0))
⋮----
pszName: windows::core::PCWSTR(filter_name.as_ptr()),
pszSpec: windows::core::PCWSTR(filter_pattern.as_ptr()),
⋮----
let _ = dialog.SetFileTypes(&file_types);
let _ = dialog.SetFileTypeIndex(1);
⋮----
SHGetKnownFolderPath(&FOLDERID_Downloads, KNOWN_FOLDER_FLAG(0), None)
⋮----
SHCreateItemFromParsingName::<PCWSTR, _, IShellItem>(PCWSTR(downloads_path.0), None)
⋮----
let _ = dialog.SetFolder(&folder_item);
⋮----
let _ = dialog.SetDefaultExtension(windows::core::PCWSTR(default_ext.as_ptr()));
let filename = generate_filename(markdown_text);
⋮----
let _ = dialog.SetFileName(windows::core::PCWSTR(default_name.as_ptr()));
let _ = dialog.SetOptions(FOS_OVERWRITEPROMPT | FOS_STRICTFILETYPES);
if dialog.Show(None).is_err() {
⋮----
let result: windows::Win32::UI::Shell::IShellItem = match dialog.GetResult() {
⋮----
let path: windows::core::PWSTR = match result.GetDisplayName(SIGDN_FILESYSPATH) {
⋮----
let path_str = path.to_string().unwrap_or_default();
windows::Win32::System::Com::CoTaskMemFree(Some(path.0 as *const _));
⋮----
let html_content = markdown_to_html(markdown_text, false, "", "");
// Write to file
⋮----
/// Handle IPC messages from markdown WebView
pub fn handle_markdown_ipc(hwnd: HWND, msg: &str) {
⋮----
pub fn handle_markdown_ipc(hwnd: HWND, msg: &str) {
⋮----
if let Some(action) = json.get("action").and_then(|s| s.as_str()) {
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
let _ = ReleaseCapture();
let _ = PostMessageW(
Some(hwnd),
⋮----
WPARAM(0xF012),
LPARAM(0),
</file>

<file path="Cargo.toml">
[package]
name = "screen-goated-toolbox"
version = "4.5.0"
edition = "2021"

[build-dependencies]
winres = "0.1"
image = { version = "0.25", default-features = false, features = ["png", "bmp"] }

[dependencies]
# Network & Serialization
ureq = { version = "3.1", features = ["json"] }
tungstenite = { version = "0.28", features = ["native-tls"] }
native-tls = "0.2"
url = "2.5"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
anyhow = "1.0"
base64 = "0.22"
self_update = { version = "0.42", features = ["archive-zip", "compression-zip-deflate"] }
zip = "7.0"

# Image Processing (Common formats for drag-and-drop)
image = { version = "0.25", default-features = false, features = ["png", "bmp", "jpeg", "gif", "webp", "tiff"] }

# Time
chrono = { version = "0.4", features = ["serde"] }

# System
dirs = "6.0"
lazy_static = "1.5"
textwrap = "0.16"
open = "5.3"
sys-locale = "0.3"
winreg = "0.55"
auto-launch = "0.5"
urlencoding = "2.1"

# Language Data (Kept as requested)
isolang = { version = "2.4", features = ["serde", "english_names"] }
whatlang = "0.18"

# GUI & Media
eframe = { version = "0.33", default-features = false, features = ["glow"] }
egui-snarl = { path = "libs/egui-snarl", features = ["serde"] }
tray-icon = "0.21.3"
cpal = "0.17"
hound = "3.5"
wasapi = "0.22"
minimp3 = "0.6"
egui_extras = { version = "0.33", features = ["all_loaders"] }
# Audio file decoding (MP3, FLAC, OGG, WAV, AAC, ALAC)
symphonia = { version = "0.5", features = ["mp3", "flac", "ogg", "wav", "aac", "alac", "pcm"] }

# Markdown Rendering
pulldown-cmark = "0.13"
wry = "0.53.5"
raw-window-handle = "0.6"
windows-core = "0.62"
parakeet-rs = { version = "0.2.7", features = ["directml"] }
ort = { version = "2.0.0-rc.10", features = ["directml", "load-dynamic"] }
ringbuf = "0.4.8"
dark-light = "2.0.0"

[dependencies.windows]
version = "0.62"
features = [
    "Win32_Foundation",
    "Win32_UI_WindowsAndMessaging",
    "Win32_UI_Controls",
    "Win32_Graphics_Gdi",
    "Win32_UI_Input_KeyboardAndMouse",
    "Win32_System_LibraryLoader",
    "Win32_Graphics_Dwm",
    "Win32_UI_HiDpi",
    "Win32_System_Threading",
    "Win32_Security",
    "Win32_System_Com",
    "Win32_System_DataExchange",
    "Win32_System_Memory",
    "Win32_Media_Audio",
    "Win32_System_SystemInformation",
    "Win32_UI_Shell",
    "Win32_UI_Shell_Common",
    "Win32_UI_Accessibility",
]

[profile.release]
opt-level = "z"
lto = true
codegen-units = 1
strip = "symbols"  # Keep minimal debug info for AV trust (don't fully strip)
debug = 1          # Include basic debug info - helps Windows Defender trust the exe
panic = "unwind"
</file>

<file path="src/gui/locale.rs">
pub struct LocaleText {
⋮----
pub force_quit: &'static str, // NEW
⋮----
// --- NEW TEXT INPUT FIELDS ---
⋮----
pub continuous_input_label: &'static str, // Checkbox for continuous input mode
⋮----
// --- COMPOUND SEARCH UI ---
⋮----
pub search_searching: &'static str,        // "searching" / "tìm kiếm"
⋮----
pub search_found_sources: &'static str,    // "FOUND {} SOURCES" / "ĐÃ TÌM THẤY {} NGUỒN"
⋮----
pub search_no_title: &'static str,      // "(No title)" / "(Không có tiêu đề)"
⋮----
pub search_analyzed_sources: &'static str, // "Analyzed {} sources" / "Đã phân tích {} nguồn"
⋮----
pub controller_checkbox_label: &'static str, // "Bộ điều khiển" / "Controller" / "컨트롤러"
// --- GLOBAL SETTINGS UI HEADERS ---
⋮----
// --- MODEL THINKING INDICATOR ---
⋮----
// App selection modal
⋮----
// --- TRAY MENU ---
⋮----
// --- FAVORITE BUBBLE ---
⋮----
// --- AUTO COPY BADGE ---
⋮----
// --- REALTIME EGUI SPECIFIC ---
⋮----
// --- HELP ASSISTANT ---
⋮----
// --- PROMPT DJ ---
⋮----
// --- PARAKEET DOWNLOAD MODAL ---
⋮----
// --- OVERLAY BUTTONS TOOLTIPS ---
⋮----
pub download_quality_label_text: &'static str, // NEW
⋮----
pub download_scanning_label: &'static str, // NEW
⋮----
pub download_show_log_btn: &'static str, // NEW
⋮----
// --- CONTINUOUS MODE ---
⋮----
impl LocaleText {
pub fn get(lang_code: &str) -> Self {
⋮----
tips_list: vec![
⋮----
tts_preview_texts: vec![
</file>

<file path="src/overlay/result/button_canvas.rs">
use std::cell::RefCell;
use std::collections::HashMap;
⋮----
use windows::core::w;
⋮----
use windows::Win32::Graphics::Dwm::DwmExtendFrameIntoClientArea;
⋮----
use windows::Win32::System::LibraryLoader::GetModuleHandleW;
use windows::Win32::UI::Controls::MARGINS;
use windows::Win32::UI::HiDpi::GetDpiForSystem;
⋮----
use super::state::WINDOW_STATES;
fn get_dpi_scale() -> f64 {
let dpi = unsafe { GetDpiForSystem() };
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
unsafe impl Send for HwndWrapper {}
unsafe impl Sync for HwndWrapper {}
⋮----
fn window_handle(
⋮----
std::num::NonZeroIsize::new(self.0 .0 as isize).expect("HWND cannot be null"),
⋮----
unsafe { Ok(raw_window_handle::WindowHandle::borrow_raw(handle)) }
⋮----
/// Register a markdown window for button overlay
pub fn register_markdown_window(hwnd: HWND) {
⋮----
pub fn register_markdown_window(hwnd: HWND) {
⋮----
// Initialize on-demand if not warmed up
if !IS_WARMED_UP.load(Ordering::SeqCst) && CANVAS_HWND.load(Ordering::SeqCst) == 0 {
if !IS_INITIALIZING.swap(true, Ordering::SeqCst) {
⋮----
create_canvas_window();
⋮----
// Polling thread to auto-show once ready
⋮----
if IS_WARMED_UP.load(Ordering::SeqCst) && CANVAS_HWND.load(Ordering::SeqCst) != 0 {
update_canvas();
show_canvas();
⋮----
// Get window rect
⋮----
let _ = GetWindowRect(hwnd, &mut r);
⋮----
let mut windows = MARKDOWN_WINDOWS.lock().unwrap();
windows.insert(
⋮----
// Trigger canvas update
⋮----
/// Unregister a markdown window
pub fn unregister_markdown_window(hwnd: HWND) {
⋮----
pub fn unregister_markdown_window(hwnd: HWND) {
⋮----
windows.remove(&hwnd_key);
// If no more markdown windows, hide canvas
if windows.is_empty() {
hide_canvas();
⋮----
/// Update window position (call when window moves/resizes)
pub fn update_window_position(hwnd: HWND) {
⋮----
pub fn update_window_position(hwnd: HWND) {
update_window_position_internal(hwnd, true);
⋮----
fn update_window_position_internal(hwnd: HWND, notify: bool) {
⋮----
if windows.contains_key(&hwnd_key) {
⋮----
/// Update window position directly in the register (skips GetWindowRect, faster for bulk)
pub fn update_window_position_direct(hwnd: HWND, x: i32, y: i32, w: i32, h: i32) {
⋮----
pub fn update_window_position_direct(hwnd: HWND, x: i32, y: i32, w: i32, h: i32) {
⋮----
windows.insert(hwnd_key, (x, y, w, h));
⋮----
/// Send update to set the text in the refine input bar
pub fn send_refine_text_update(hwnd: HWND, text: &str, is_insert: bool) {
⋮----
pub fn send_refine_text_update(hwnd: HWND, text: &str, is_insert: bool) {
⋮----
// Store in pending updates
⋮----
let mut updates = PENDING_REFINE_UPDATES.lock().unwrap();
updates.insert(hwnd_key, text.to_string());
⋮----
// Notify canvas thread
let canvas_hwnd = CANVAS_HWND.load(Ordering::SeqCst);
⋮----
let _ = PostMessageW(
Some(HWND(canvas_hwnd as *mut _)),
⋮----
WPARAM(hwnd_key as usize),
LPARAM(if is_insert { 1 } else { 0 }),
⋮----
/// Set drag mode (temporarily disable region clipping to prevent UI cutoff)
pub fn set_drag_mode(active: bool) {
⋮----
pub fn set_drag_mode(active: bool) {
⋮----
let hwnd = HWND(canvas_hwnd as *mut std::ffi::c_void);
⋮----
// ENTER DRAG MODE: Remove region (full window visible/interactive)
IS_DRAGGING_EXTERNAL.store(true, Ordering::SeqCst);
⋮----
let _ = SetWindowRgn(hwnd, None, true);
⋮----
// EXIT DRAG MODE: Restore regions
IS_DRAGGING_EXTERNAL.store(false, Ordering::SeqCst);
update_canvas(); // Trigger recalculation of regions
⋮----
/// Update canvas with current window positions
pub fn update_canvas() {
⋮----
pub fn update_canvas() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_UPDATE_WINDOWS, WPARAM(0), LPARAM(0));
⋮----
/// Show the canvas
fn show_canvas() {
⋮----
fn show_canvas() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_SHOW_CANVAS, WPARAM(0), LPARAM(0));
⋮----
/// Hide the canvas
fn hide_canvas() {
⋮----
fn hide_canvas() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE_CANVAS, WPARAM(0), LPARAM(0));
⋮----
// Track last applied theme to avoid redundant injections
⋮----
fn get_canvas_theme_css(is_dark: bool) -> &'static str {
⋮----
fn generate_canvas_html() -> String {
⋮----
let lang = crate::APP.lock().unwrap().config.ui_language.clone();
⋮----
.to_string();
⋮----
LAST_THEME_IS_DARK.store(is_dark, Ordering::SeqCst);
let theme_css = get_canvas_theme_css(is_dark);
⋮----
crate::overlay::html_components::icons::get_icon_svg(name).to_string()
⋮----
format!(
⋮----
.replace("#L10N_JSON#", &l10n_json)
.replace("#ICON_SVGS_JSON#", &icon_svgs_json)
⋮----
/// Create the fullscreen transparent canvas window
fn create_canvas_window() {
⋮----
fn create_canvas_window() {
⋮----
// Initialize COM for WebView on this thread
let _ = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap_or_default();
let class_name = w!("SGTButtonCanvas");
REGISTER_CANVAS_CLASS.call_once(|| {
⋮----
lpfnWndProc: Some(canvas_wnd_proc),
hInstance: instance.into(),
⋮----
hCursor: LoadCursorW(None, IDC_ARROW).unwrap_or_default(),
hbrBackground: HBRUSH(std::ptr::null_mut()),
⋮----
RegisterClassW(&wc);
⋮----
// Get screen dimensions
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
// Create fullscreen transparent window
// WS_EX_TOPMOST keeps it above result windows
// WS_EX_TOOLWINDOW hides from taskbar
// WS_EX_NOACTIVATE prevents focus stealing
// WS_EX_TRANSPARENT removed to allow hit-testing (we handle passthrough via WM_NCHITTEST)
// WS_EX_LAYERED removed - interfering with WebView2 creation when WS_EX_TRANSPARENT is missing?
let hwnd = CreateWindowExW(
⋮----
w!("ButtonCanvas"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
⋮----
CANVAS_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
// CRITICAL: DwmExtendFrameIntoClientArea with -1 margins enables
// transparent background while keeping WebView content visible
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
// Initialize window region to empty (fully click-through)
let empty_rgn = CreateRectRgn(0, 0, 0, 0);
let _ = SetWindowRgn(hwnd, Some(empty_rgn), true);
// Initialize WebContext
CANVAS_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
// Consolidate all minor overlays to 'common' to share one browser process and keep RAM at ~80MB
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let html = generate_canvas_html();
let wrapper = HwndWrapper(hwnd);
⋮----
// LOCK SCOPE: Only one WebView builds at a time to prevent "Not enough quota"
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = CANVAS_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
// Store HTML in font server
⋮----
crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| {
format!("data:text/html,{}", urlencoding::encode(&html))
⋮----
.with_bounds(Rect {
⋮----
.with_transparent(true)
.with_visible(false)
.with_focused(false)
.with_url(&page_url)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
handle_ipc_message(msg.body());
⋮----
.build_as_child(&wrapper)
⋮----
CANVAS_WEBVIEW.with(|cell| {
*cell.borrow_mut() = Some(wv);
⋮----
IS_WARMED_UP.store(true, Ordering::SeqCst);
⋮----
// CRITICAL: Destroy the window so it doesn't block the screen invisibly
⋮----
let _ = DestroyWindow(hwnd);
CANVAS_HWND.store(0, Ordering::SeqCst);
CoUninitialize();
⋮----
// Message loop
⋮----
while GetMessageW(&mut msg, None, 0, 0).into() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
// Cleanup
IS_WARMED_UP.store(false, Ordering::SeqCst);
IS_INITIALIZING.store(false, Ordering::SeqCst);
⋮----
*cell.borrow_mut() = None;
⋮----
/// Handle IPC messages from the canvas WebView
fn handle_ipc_message(body: &str) {
⋮----
fn handle_ipc_message(body: &str) {
⋮----
let action = json.get("action").and_then(|v| v.as_str()).unwrap_or("");
// Handle clickable regions update (global, not per-window)
⋮----
if let Some(regions) = json.get("regions").and_then(|v| v.as_array()) {
let canvas_hwnd = HWND(CANVAS_HWND.load(Ordering::SeqCst) as *mut std::ffi::c_void);
if canvas_hwnd.0.is_null() {
⋮----
// If currently dragging external window, IGNORE region updates
// We want the window to remain unclipped (full screen) during drag for smoothness
if IS_DRAGGING_EXTERNAL.load(Ordering::SeqCst) {
⋮----
let combined_rgn = CreateRectRgn(0, 0, 0, 0);
// JavaScript sends logical (CSS) coordinates, but SetWindowRgn expects physical
let scale = get_dpi_scale();
⋮----
// Parse logical coordinates from JavaScript
let logical_x = r.get("x").and_then(|v| v.as_f64()).unwrap_or(0.0);
let logical_y = r.get("y").and_then(|v| v.as_f64()).unwrap_or(0.0);
let logical_w = r.get("w").and_then(|v| v.as_f64()).unwrap_or(0.0);
let logical_h = r.get("h").and_then(|v| v.as_f64()).unwrap_or(0.0);
// Scale to physical coordinates
⋮----
let rgn = CreateRectRgn(x, y, x + w, y + h);
⋮----
CombineRgn(Some(combined_rgn), Some(combined_rgn), Some(rgn), RGN_OR);
let _ = DeleteObject(rgn.into()); // Delete localized region after combining
⋮----
// Apply the region to the window
// System owns combined_rgn after this call
let _ = SetWindowRgn(canvas_hwnd, Some(combined_rgn), true);
⋮----
let hwnd_str = json.get("hwnd").and_then(|v| v.as_str()).unwrap_or("0");
let hwnd_val: isize = hwnd_str.parse().unwrap_or(0);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
// Ensure canvas window is foreground for keyboard focus (Ctrl+A etc) - REMOVED to prevent focus stealing from games
// Only specific actions like 'edit' might need focus, handled locally in their logic if needed.
⋮----
Some(hwnd),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
// Close window
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
// Right-click: close linked windows (via group)
⋮----
let _ = PostMessageW(Some(h), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
// Middle-click = close all
⋮----
// Initiate manual Rust-side drag (more robust than system drag)
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetCapture;
use windows::Win32::UI::WindowsAndMessaging::GetCursorPos;
⋮----
if GetCursorPos(&mut pt).is_ok() {
use std::sync::atomic::Ordering;
ACTIVE_DRAG_TARGET.store(hwnd.0 as isize, Ordering::SeqCst);
DRAG_IS_GROUP.store(false, Ordering::SeqCst);
let mut last = LAST_DRAG_POS.lock().unwrap();
⋮----
let mut start = START_DRAG_POS.lock().unwrap();
⋮----
let canvas_val = CANVAS_HWND.load(Ordering::SeqCst);
⋮----
let canvas_hwnd = HWND(canvas_val as *mut std::ffi::c_void);
let _ = SetCapture(canvas_hwnd);
// Hide all buttons immediately
⋮----
// Initiate mass drag for linked windows (Right-click drag)
⋮----
DRAG_IS_GROUP.store(true, Ordering::SeqCst);
// Collect the entire group once at start
⋮----
let mut snapshot = ACTIVE_DRAG_SNAPSHOT.lock().unwrap();
*snapshot = group.into_iter().map(|(h, _)| h.0 as isize).collect();
⋮----
// Initiate mass drag for ALL windows (Middle-click drag)
⋮----
// Collect ALL registered markdown windows
let windows = MARKDOWN_WINDOWS.lock().unwrap();
⋮----
*snapshot = windows.keys().cloned().collect();
⋮----
if let Some(value) = json.get("value").and_then(|v| v.as_f64()) {
⋮----
// Update state so it persists across button canvas refreshes
⋮----
let mut states = WINDOW_STATES.lock().unwrap();
if let Some(state) = states.get_mut(&(hwnd.0 as isize)) {
⋮----
let _ = SetLayeredWindowAttributes(
⋮----
// Legacy JS-driven drag (unused now but kept for compatibility)
⋮----
(json.get("dx").and_then(|v| v.as_f64()).unwrap_or(0.0) * scale).round() as i32;
⋮----
(json.get("dy").and_then(|v| v.as_f64()).unwrap_or(0.0) * scale).round() as i32;
⋮----
let text = json.get("text").and_then(|v| v.as_str()).unwrap_or("");
⋮----
let current = json.get("text").and_then(|v| v.as_str()).unwrap_or("");
⋮----
// Send back to JS
send_refine_text_update(hwnd, &text, false);
⋮----
// Trigger transcription preset
⋮----
let app = crate::APP.lock().unwrap();
⋮----
.iter()
.position(|p| p.id == "preset_transcribe")
⋮----
let canvas_hwnd = HWND(canvas_val as *mut _);
let _ = SetForegroundWindow(canvas_hwnd);
⋮----
/// Send updated window data to the canvas
fn send_windows_update() {
⋮----
fn send_windows_update() {
// Check if theme has changed and inject new CSS if needed
⋮----
let last_dark = LAST_THEME_IS_DARK.load(Ordering::SeqCst);
⋮----
let new_css = get_canvas_theme_css(is_dark);
// Escape content safely for JS string
let content_escaped = new_css.replace('`', "\\`").replace('\\', "\\\\");
let script = format!(
⋮----
if let Some(webview) = cell.borrow().as_ref() {
let _ = webview.evaluate_script(&script);
⋮----
let states = WINDOW_STATES.lock().unwrap();
⋮----
// Check for any active native interaction (Resizing/Moving)
let any_interacting = states.values().any(|s| {
matches!(
⋮----
// If ANY drag (custom or native) or resize is active, hide ALL buttons
let dragging_target = ACTIVE_DRAG_TARGET.load(std::sync::atomic::Ordering::SeqCst);
⋮----
// Send empty data -> Hides all
let json = serde_json::to_string(&data).unwrap_or_default();
⋮----
let script = format!("window.updateWindows({});", json);
⋮----
for (&hwnd_key, &(x, y, w, h)) in windows.iter() {
let state = states.get(&hwnd_key);
⋮----
data.insert(
hwnd_key.to_string(),
⋮----
let script = format!("window.updateWindows({});", windows_data);
⋮----
unsafe extern "system" fn canvas_wnd_proc(
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOPMOST),
⋮----
send_windows_update();
LRESULT(0)
⋮----
let foreground = GetForegroundWindow();
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
⋮----
let _ = webview.set_visible(true);
⋮----
if !foreground.0.is_null() && IsWindow(Some(foreground)).as_bool() {
let _ = SetForegroundWindow(foreground);
⋮----
let _ = SetTimer(Some(hwnd), CURSOR_POLL_TIMER_ID, 100, None);
⋮----
let _ = webview.set_visible(false);
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = KillTimer(Some(hwnd), CURSOR_POLL_TIMER_ID);
⋮----
updates.remove(&hwnd_key)
⋮----
.replace('\\', "\\\\")
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\r', "");
⋮----
LRESULT(windows::Win32::UI::WindowsAndMessaging::MA_NOACTIVATE as isize)
⋮----
let target_val = ACTIVE_DRAG_TARGET.load(Ordering::SeqCst);
⋮----
if DRAG_IS_GROUP.load(Ordering::SeqCst) {
let snapshot = ACTIVE_DRAG_SNAPSHOT.lock().unwrap();
let mut updates = Vec::with_capacity(snapshot.len());
⋮----
if let Ok(mut hdwp) = BeginDeferWindowPos(snapshot.len() as i32) {
for &h_val in snapshot.iter() {
let h = HWND(h_val as *mut std::ffi::c_void);
⋮----
if GetWindowRect(h, &mut r).is_ok() {
⋮----
hdwp = DeferWindowPos(
⋮----
.unwrap_or(hdwp);
updates.push((h_val, (nx, ny, nw, nh)));
⋮----
let _ = EndDeferWindowPos(hdwp);
⋮----
if !updates.is_empty() {
⋮----
if windows.contains_key(&key) {
windows.insert(key, rect);
⋮----
let target_hwnd = HWND(target_val as *mut std::ffi::c_void);
⋮----
return LRESULT(0);
⋮----
DefWindowProcW(hwnd, msg, wparam, lparam)
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::ReleaseCapture;
ACTIVE_DRAG_TARGET.store(0, Ordering::SeqCst);
⋮----
let _ = ReleaseCapture();
⋮----
let _ = GetCursorPos(&mut pt);
let start = START_DRAG_POS.lock().unwrap();
let dist_sq = ((pt.x - start.x).pow(2) + (pt.y - start.y).pow(2)) as f64;
if dist_sq.sqrt() < 5.0 {
⋮----
let _ = PostMessageW(Some(target_hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
format!("window.updateCursorPosition({}, {});", logical_x, logical_y);
⋮----
if ACTIVE_DRAG_TARGET.load(Ordering::SeqCst) == 0 {
⋮----
let _ = webview.set_bounds(Rect {
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/overlay/text_selection.rs">
use crate::APP;
⋮----
use crate::overlay::realtime_webview::state::HwndWrapper;
struct TextSelectionState {
⋮----
unsafe impl Send for TextSelectionState {}
⋮----
hook_handle: HHOOK(std::ptr::null_mut()),
⋮----
thread_local! {
⋮----
pub fn is_active() -> bool {
let hwnd_val = TAG_HWND.load(Ordering::SeqCst);
⋮----
unsafe { IsWindowVisible(HWND(hwnd_val as *mut std::ffi::c_void)).as_bool() }
⋮----
pub fn is_processing() -> bool {
let state = SELECTION_STATE.lock().unwrap();
⋮----
struct ProcessingGuard;
impl Drop for ProcessingGuard {
fn drop(&mut self) {
let mut state = SELECTION_STATE.lock().unwrap();
⋮----
pub fn try_instant_process(preset_idx: usize) -> bool {
⋮----
.duration_since(std::time::UNIX_EPOCH)
.unwrap_or_default()
.as_millis() as u64;
let last_time = LAST_INSTANT_PROCESS_TIME.load(Ordering::SeqCst);
⋮----
LAST_INSTANT_PROCESS_TIME.store(now, Ordering::SeqCst);
⋮----
let original_clipboard = get_clipboard_text();
if OpenClipboard(Some(HWND::default())).is_ok() {
let _ = EmptyClipboard();
let _ = CloseClipboard();
⋮----
wVk: VIRTUAL_KEY(vk),
⋮----
SendInput(&[input], std::mem::size_of::<INPUT>() as i32);
⋮----
send_input_event(VK_CONTROL.0, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYBD_EVENT_FLAGS(0));
⋮----
send_input_event(0x43, KEYEVENTF_KEYUP);
⋮----
send_input_event(VK_CONTROL.0, KEYEVENTF_KEYUP);
⋮----
clipboard_text = get_clipboard_text();
if !clipboard_text.is_empty() {
⋮----
if clipboard_text.trim().is_empty() {
if !original_clipboard.is_empty() {
⋮----
cancel_selection();
⋮----
if hotkey_name.is_empty() {
⋮----
hotkey_name = "Hotkey".to_string();
⋮----
if let Ok(app) = APP.lock() {
⋮----
.get(preset_idx)
.map(|p| p.id.clone())
⋮----
"Preset".to_string()
⋮----
crate::overlay::continuous_mode::activate(preset_idx, hotkey_name.clone());
⋮----
let _ = show_text_selection_tag(current_idx);
⋮----
process_selected_text(final_preset_idx, clipboard_text);
⋮----
pub fn cancel_selection() {
TAG_ABORT_SIGNAL.store(true, Ordering::SeqCst);
⋮----
let _ = PostMessageW(
Some(HWND(hwnd_val as *mut std::ffi::c_void)),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
pub fn warmup() {
if IS_WARMED_UP.load(Ordering::SeqCst) {
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
internal_create_tag_thread();
⋮----
pub fn is_warming_up() -> bool {
IS_WARMING_UP.load(Ordering::SeqCst)
⋮----
pub fn show_text_selection_tag(preset_idx: usize) {
if !IS_WARMED_UP.load(Ordering::SeqCst) {
PENDING_SHOW_ON_WARMUP.store(true, Ordering::SeqCst);
warmup();
⋮----
TAG_ABORT_SIGNAL.store(false, Ordering::SeqCst);
⋮----
CONTINUOUS_ACTIVATED_THIS_SESSION.store(false, Ordering::SeqCst);
HOLD_DETECTED_THIS_SESSION.store(false, Ordering::SeqCst);
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::GetAsyncKeyState;
⋮----
let is_physically_held = (GetAsyncKeyState(vk as i32) as u16 & 0x8000) != 0;
IS_HOTKEY_HELD.store(is_physically_held, Ordering::SeqCst);
⋮----
IS_HOTKEY_HELD.store(false, Ordering::SeqCst);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
⋮----
let _ = GetCursorPos(&mut pt);
⋮----
let _ = MoveWindow(hwnd, target_x, target_y, 200, 120, false);
let _ = PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
fn reset_ui_state(initial_text: &str) {
⋮----
if let Some(wv) = state.webview.as_ref() {
let reset_js = format!("updateState(false, '{}')", initial_text);
let _ = wv.evaluate_script(&reset_js);
⋮----
unsafe extern "system" fn tag_wnd_proc(
⋮----
let _ = KillTimer(Some(hwnd), 1);
⋮----
let _ = wv.evaluate_script("playEntry();");
⋮----
let _ = ShowWindow(hwnd, SW_SHOWNOACTIVATE);
LRESULT(0)
⋮----
let _ = wv.evaluate_script("playExit();");
⋮----
SetTimer(Some(hwnd), 1, 150, None);
⋮----
let initial_text = INITIAL_TEXT_GLOBAL.lock().unwrap();
reset_ui_state(&initial_text);
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
⋮----
PostQuitMessage(0);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
Err(_) => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
fn internal_create_tag_thread() {
⋮----
let _coinit = CoInitialize(None);
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextTag_Web_Persistent");
REGISTER_TAG_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(tag_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
let _ = RegisterClassExW(&wc);
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("SGT Tag"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
IS_WARMING_UP.store(false, Ordering::SeqCst);
⋮----
let app = APP.lock().unwrap();
⋮----
app.config.ui_language.clone(),
⋮----
let initial_text = match lang.as_str() {
⋮----
*INITIAL_TEXT_GLOBAL.lock().unwrap() = initial_text.to_string();
let html_content = get_html(initial_text);
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
SELECTION_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
*ctx.borrow_mut() = Some(wry::WebContext::new(Some(shared_data_dir)));
⋮----
crate::overlay::html_components::font_manager::store_html_page(html_content.clone())
.unwrap_or_else(|| {
format!("data:text/html,{}", urlencoding::encode(&html_content))
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
let build_res = SELECTION_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
.with_bounds(wry::Rect {
⋮----
.with_url(&page_url)
.with_transparent(true)
.build_as_child(&HwndWrapper(hwnd))
⋮----
final_webview = Some(wv);
⋮----
let init_script = format!("updateTheme({});", initial_is_dark);
let _ = webview.evaluate_script(&init_script);
SELECTION_STATE.lock().unwrap().webview = Some(webview);
⋮----
let _ = DestroyWindow(hwnd);
⋮----
let _ = CoUninitialize();
⋮----
TAG_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
IS_WARMED_UP.store(true, Ordering::SeqCst);
⋮----
if PENDING_SHOW_ON_WARMUP.swap(false, Ordering::SeqCst) {
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
⋮----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
(GetAsyncKeyState(TRIGGER_VK_CODE as i32) as u16 & 0x8000) != 0;
if !is_physically_down && IS_HOTKEY_HELD.load(Ordering::SeqCst) {
⋮----
if GetMessageW(&mut msg, None, 0, 0).as_bool() {
⋮----
let is_actually_visible = IsWindowVisible(hwnd).as_bool();
⋮----
if state.hook_handle.is_invalid() {
let hook = SetWindowsHookExW(
⋮----
Some(keyboard_hook_proc),
Some(GetModuleHandleW(None).unwrap().into()),
⋮----
wv.evaluate_script(&format!("updateTheme({});", current_is_dark));
⋮----
&& !state.hook_handle.is_invalid()
⋮----
let _ = UnhookWindowsHookEx(state.hook_handle);
⋮----
if TAG_ABORT_SIGNAL.load(Ordering::SeqCst) {
⋮----
if let Some(wv) = SELECTION_STATE.lock().unwrap().webview.as_ref() {
let _ = wv.evaluate_script(&format!("updateTheme({});", current_is_dark));
⋮----
let session_activated = CONTINUOUS_ACTIVATED_THIS_SESSION.load(Ordering::SeqCst);
⋮----
HOLD_DETECTED_THIS_SESSION.store(true, Ordering::SeqCst);
⋮----
if HOLD_DETECTED_THIS_SESSION.load(Ordering::SeqCst) {
⋮----
let p_idx = SELECTION_STATE.lock().unwrap().preset_idx;
⋮----
.get(p_idx)
⋮----
crate::overlay::continuous_mode::activate(p_idx, hotkey_name.clone());
⋮----
CONTINUOUS_ACTIVATED_THIS_SESSION.store(true, Ordering::SeqCst);
⋮----
let lbutton_down = (GetAsyncKeyState(VK_LBUTTON.0 as i32) as u16 & 0x8000) != 0;
⋮----
let hwnd_under_mouse = WindowFromPoint(pt);
⋮----
GetWindowThreadProcessId(hwnd_under_mouse, Some(&mut pid));
⋮----
MOUSE_START_X.store(pt.x, Ordering::SeqCst);
MOUSE_START_Y.store(pt.y, Ordering::SeqCst);
⋮----
let start_x = MOUSE_START_X.load(Ordering::SeqCst);
let start_y = MOUSE_START_Y.load(Ordering::SeqCst);
let dx = (pt.x - start_x).abs();
let dy = (pt.y - start_y).abs();
⋮----
match lang.as_str() {
⋮----
Some(format!(
⋮----
if let Some(webview) = SELECTION_STATE.lock().unwrap().webview.as_ref() {
let _ = webview.evaluate_script(&js);
⋮----
let hwnd_copy = HWND(hwnd_val as *mut std::ffi::c_void);
if TAG_ABORT_SIGNAL.load(Ordering::Relaxed) {
⋮----
if !clipboard_text.trim().is_empty()
&& !TAG_ABORT_SIGNAL.load(Ordering::Relaxed)
⋮----
PostMessageW(Some(hwnd_copy), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
CONTINUOUS_ACTIVATED_THIS_SESSION.load(Ordering::SeqCst);
⋮----
IS_HOTKEY_HELD.load(Ordering::SeqCst)
⋮----
hotkey_name.clone(),
⋮----
process_selected_text(p_idx, clipboard_text);
⋮----
if !state.hook_handle.is_invalid() {
⋮----
unsafe fn get_clipboard_text() -> String {
⋮----
if let Ok(h_data) = GetClipboardData(13u32) {
⋮----
let ptr = GlobalLock(h_global);
if !ptr.is_null() {
let size = GlobalSize(h_global);
⋮----
if let Some(end) = wide_slice.iter().position(|&c| c == 0) {
⋮----
let _ = GlobalUnlock(h_global);
⋮----
fn process_selected_text(preset_idx: usize, clipboard_text: String) {
⋮----
(p.is_master, p.text_input_mode.clone())
⋮----
let _ = GetCursorPos(&mut cursor_pos);
⋮----
crate::overlay::preset_wheel::show_preset_wheel("text", Some("select"), cursor_pos);
⋮----
let mut app = APP.lock().unwrap();
⋮----
app.config.clone(),
app.config.presets[final_preset_idx].clone(),
GetSystemMetrics(SM_CXSCREEN),
GetSystemMetrics(SM_CYSCREEN),
⋮----
preset.text_input_mode = "select".to_string();
⋮----
.first()
.map(|h| h.name.clone())
⋮----
unsafe extern "system" fn keyboard_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
return LRESULT(1);
⋮----
if !IS_HOTKEY_HELD.load(Ordering::SeqCst) {
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
fn get_html(initial_text: &str) -> String {
⋮----
format!(
</file>

<file path="src/overlay/text_input.rs">
use crate::gui::locale::LocaleText;
⋮----
use std::cell::RefCell;
use std::num::NonZeroIsize;
⋮----
use windows::Win32::UI::Controls::MARGINS;
use windows::Win32::UI::HiDpi::GetDpiForSystem;
⋮----
thread_local! {
⋮----
struct HwndWrapper(HWND);
impl HasWindowHandle for HwndWrapper {
fn window_handle(&self) -> std::result::Result<WindowHandle<'_>, HandleError> {
⋮----
Ok(unsafe { WindowHandle::borrow_raw(raw) })
⋮----
Err(HandleError::Unavailable)
⋮----
/// CSS for the modern text input editor
fn get_editor_css(is_dark: bool) -> String {
⋮----
fn get_editor_css(is_dark: bool) -> String {
⋮----
format!(
⋮----
/// Generate HTML for the text input webview
fn get_editor_html(placeholder: &str, is_dark: bool) -> String {
⋮----
fn get_editor_html(placeholder: &str, is_dark: bool) -> String {
let css = get_editor_css(is_dark);
⋮----
.replace('\\', "\\\\")
.replace('"', "\\\"")
.replace('\n', "\\n");
⋮----
let lang = crate::overlay::text_input::CFG_LANG.lock().unwrap().clone();
⋮----
locale.text_input_footer_submit.to_string(),
locale.text_input_footer_newline.to_string(),
locale.text_input_footer_cancel.to_string(),
⋮----
let sub = crate::overlay::text_input::CFG_CANCEL.lock().unwrap();
if sub.is_empty() {
"Esc".to_string()
⋮----
format!("Esc / {}", sub)
⋮----
let t = crate::overlay::text_input::CFG_TITLE.lock().unwrap();
if t.is_empty() {
⋮----
locale.text_input_placeholder.to_string()
⋮----
t.clone()
⋮----
pub fn is_active() -> bool {
let hwnd_val = INPUT_HWND.load(Ordering::SeqCst);
⋮----
let hwnd = HWND(hwnd_val as *mut std::ffi::c_void);
if !IsWindowVisible(hwnd).as_bool() {
⋮----
if GetWindowRect(hwnd, &mut rect).is_ok() {
⋮----
pub fn cancel_input() {
⋮----
let _ = PostMessageW(Some(hwnd), WM_APP_HIDE, WPARAM(0), LPARAM(0));
⋮----
pub fn set_editor_text(text: &str) {
*PENDING_TEXT.lock().unwrap() = Some(text.to_string());
⋮----
let _ = PostMessageW(
Some(HWND(hwnd_val as *mut std::ffi::c_void)),
⋮----
WPARAM(0),
LPARAM(0),
⋮----
fn apply_pending_text() {
let text = PENDING_TEXT.lock().unwrap().take();
⋮----
if let Some(stripped) = text.strip_prefix("__REPLACE_ALL__") {
(true, stripped.to_string())
⋮----
.replace('`', "\\`")
.replace("${", "\\${")
.replace('\n', "\\n")
.replace('\r', "");
TEXT_INPUT_WEBVIEW.with(|webview| {
if let Some(wv) = webview.borrow().as_ref() {
⋮----
// Replace all text (for history navigation)
⋮----
// Insert at cursor position (for paste/transcription)
⋮----
let _ = wv.evaluate_script(&script);
⋮----
println!("[Badge] Starting WebView initialization...");
⋮----
/// Clear the webview editor content and refocus (for continuous input mode)
pub fn clear_editor_text() {
⋮----
pub fn clear_editor_text() {
⋮----
let _ = wv.evaluate_script(script);
⋮----
/// Update the UI text (header) and trigger a repaint
pub fn update_ui_text(header_text: String) {
⋮----
pub fn update_ui_text(header_text: String) {
*CFG_TITLE.lock().unwrap() = header_text.clone();
⋮----
let _ = SetWindowTextW(hwnd, &HSTRING::from(header_text));
let _ = PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(1), LPARAM(0));
⋮----
/// Bring the text input window to foreground and focus the editor
/// Call this after closing modal windows like the preset wheel
⋮----
/// Call this after closing modal windows like the preset wheel
pub fn refocus_editor() {
⋮----
pub fn refocus_editor() {
⋮----
use windows::Win32::UI::Input::KeyboardAndMouse::SetFocus;
⋮----
// Aggressive focus: try multiple methods
let _ = BringWindowToTop(hwnd);
let _ = SetForegroundWindow(hwnd);
let _ = SetFocus(Some(hwnd));
// Focus the webview editor immediately
⋮----
// First focus the WebView itself (native focus)
let _ = wv.focus();
// Then focus the textarea inside via JavaScript
let _ = wv.evaluate_script("document.getElementById('editor').focus();");
⋮----
// Schedule another focus attempt after 200ms via timer ID 3
// This will be handled in WM_TIMER in the same thread
let _ = SetTimer(Some(hwnd), 3, 200, None);
⋮----
/// Get the current window rect of the text input window (if active)
pub fn get_window_rect() -> Option<RECT> {
⋮----
pub fn get_window_rect() -> Option<RECT> {
⋮----
if GetWindowRect(HWND(hwnd_val as *mut std::ffi::c_void), &mut rect).is_ok() {
return Some(rect);
⋮----
/// Start the persistent hidden window (called from main)
pub fn warmup() {
⋮----
pub fn warmup() {
// Thread-safe atomic check-and-set to prevent multiple warmup threads
if IS_WARMED_UP.load(Ordering::SeqCst) {
⋮----
.compare_exchange(false, true, Ordering::SeqCst, Ordering::SeqCst)
.is_err()
⋮----
internal_create_window_loop();
⋮----
pub fn show(
⋮----
// Re-entrancy guard: if we are already in the process of showing/waiting, ignore subsequent calls
// This prevents key-mashing from spawning multiple wait loops or confused states
⋮----
// Ensure we clear the flag when we return
struct Guard;
impl Drop for Guard {
fn drop(&mut self) {
IS_SHOWING.store(false, Ordering::SeqCst);
⋮----
// Clone lang for locale notification before moving/consuming it
let lang_for_locale = ui_language.clone();
// Update shared state FIRST so it's ready when window shows up
*CFG_TITLE.lock().unwrap() = prompt_guide;
*CFG_LANG.lock().unwrap() = ui_language;
*CFG_CANCEL.lock().unwrap() = cancel_hotkey_name;
*CFG_CONTINUOUS.lock().unwrap() = continuous_mode;
*CFG_CALLBACK.lock().unwrap() = Some(Box::new(on_submit));
*SUBMITTED_TEXT.lock().unwrap() = None;
*SHOULD_CLOSE.lock().unwrap() = false;
*SHOULD_CLEAR_ONLY.lock().unwrap() = false;
// Check if warmed up
if !IS_WARMED_UP.load(Ordering::SeqCst) {
// Trigger warmup for recovery
warmup();
// Show localized message that feature is not ready yet
⋮----
// Blocking wait with message pump
// We wait up to 20 seconds. If it fails, we simply return (preventing premature broken window)
⋮----
while PeekMessageW(&mut msg, None, 0, 0, PM_REMOVE).as_bool() {
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
// If still not warmed up after wait, give up
⋮----
// ALWAYS show logic (Toggle logic handled by caller if needed)
// Fixes issue where dynamic prompt mode fails to appear if window state is desync
let _ = PostMessageW(Some(hwnd), WM_APP_SHOW, WPARAM(0), LPARAM(0));
⋮----
fn internal_create_window_loop() {
⋮----
let coinit = CoInitialize(None); // Required for WebView
⋮----
let instance = GetModuleHandleW(None).unwrap();
let class_name = w!("SGT_TextInputWry");
REGISTER_INPUT_CLASS.call_once(|| {
⋮----
wc.lpfnWndProc = Some(input_wnd_proc);
wc.hInstance = instance.into();
wc.hCursor = LoadCursorW(None, IDC_ARROW).unwrap();
⋮----
wc.hbrBackground = HBRUSH(GetStockObject(NULL_BRUSH).0);
let _ = RegisterClassW(&wc);
⋮----
let screen_w = GetSystemMetrics(SM_CXSCREEN);
⋮----
let dpi = GetDpiForSystem();
⋮----
let mut win_w = ((880.0 * scale) - 300.0).round() as i32;
⋮----
win_w = (win_w as f64 * 0.85).round() as i32;
⋮----
let win_h = (253.0 * scale).round() as i32;
⋮----
let hwnd = CreateWindowExW(
⋮----
w!("Text Input"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
⋮----
if hwnd.is_invalid() {
⋮----
IS_WARMED_UP.store(false, Ordering::SeqCst);
IS_WARMING_UP.store(false, Ordering::SeqCst);
let _ = CoUninitialize();
⋮----
INPUT_HWND.store(hwnd.0 as isize, Ordering::SeqCst);
⋮----
let _ = DwmSetWindowAttribute(
⋮----
let _ = DwmExtendFrameIntoClientArea(hwnd, &margins);
⋮----
if init_webview(hwnd, win_w, win_h).is_ok() {
⋮----
let _ = DestroyWindow(hwnd);
⋮----
IS_WARMED_UP.store(true, Ordering::SeqCst);
⋮----
while GetMessageW(&mut msg, None, 0, 0).as_bool() {
⋮----
let _ = DispatchMessageW(&msg);
⋮----
TEXT_INPUT_WEBVIEW.with(|wv| {
*wv.borrow_mut() = None;
⋮----
INPUT_HWND.store(0, Ordering::SeqCst);
⋮----
unsafe fn init_webview(hwnd: HWND, w: i32, h: i32) -> std::result::Result<(), ()> {
⋮----
let is_dark = if let Ok(app) = crate::APP.lock() {
⋮----
let html = get_editor_html(placeholder, is_dark);
let wrapper = HwndWrapper(hwnd);
TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
if ctx.borrow().is_none() {
let shared_data_dir = crate::overlay::get_shared_webview_data_dir(Some("common"));
*ctx.borrow_mut() = Some(WebContext::new(Some(shared_data_dir)));
⋮----
let _init_lock = crate::overlay::GLOBAL_WEBVIEW_MUTEX.lock().unwrap();
⋮----
let build_res = TEXT_INPUT_WEB_CONTEXT.with(|ctx| {
let mut ctx_ref = ctx.borrow_mut();
let builder = if let Some(web_ctx) = ctx_ref.as_mut() {
⋮----
let builder = builder.with_transparent(true);
⋮----
crate::overlay::html_components::font_manager::store_html_page(html.clone())
.unwrap_or_else(|| format!("data:text/html,{}", urlencoding::encode(&html)));
⋮----
.with_background_color((0, 0, 0, 0))
.with_bounds(Rect {
⋮----
.with_url(&page_url)
.with_transparent(true)
.with_ipc_handler(move |msg: wry::http::Request<String>| {
let body = msg.body();
if body.starts_with("submit:") {
let text = body.strip_prefix("submit:").unwrap_or("").to_string();
if !text.trim().is_empty() {
// Save to history before submitting
⋮----
*SUBMITTED_TEXT.lock().unwrap() = Some(text);
*SHOULD_CLOSE.lock().unwrap() = true;
⋮----
} else if body.starts_with("history_up:") {
let current = body.strip_prefix("history_up:").unwrap_or("");
⋮----
*PENDING_TEXT.lock().unwrap() =
Some(format!("__REPLACE_ALL__{}", text));
⋮----
} else if body.starts_with("history_down:") {
let current = body.strip_prefix("history_down:").unwrap_or("");
⋮----
let app = crate::APP.lock().unwrap();
⋮----
.iter()
.position(|p| p.id == "preset_transcribe")
⋮----
let _ = ReleaseCapture();
let _ = SendMessageW(
⋮----
Some(WPARAM(HTCAPTION as usize)),
Some(LPARAM(0)),
⋮----
cancel_input();
⋮----
.build_as_child(&wrapper)
⋮----
println!("[TextInput] WebView initialization SUCCESSFUL");
⋮----
*wv.borrow_mut() = Some(webview);
⋮----
Ok(())
⋮----
Err(())
⋮----
unsafe extern "system" fn input_wnd_proc(
⋮----
let _ = GetCursorPos(&mut cursor);
let hmonitor = MonitorFromPoint(cursor, MONITOR_DEFAULTTONEAREST);
⋮----
let _ = GetMonitorInfoW(hmonitor, &mut mi);
⋮----
let _ = GetWindowRect(hwnd, &mut rect);
⋮----
let _ = SetWindowPos(
⋮----
Some(HWND_TOP),
⋮----
.lock()
.unwrap()
.clone();
let title = if t.is_empty() {
⋮----
let hotkey = crate::overlay::text_input::CFG_CANCEL.lock().unwrap();
let ch = if hotkey.is_empty() {
⋮----
format!("Esc / {}", hotkey)
⋮----
locale.text_input_placeholder.to_string(),
⋮----
let _ = SetWindowTextW(hwnd, &HSTRING::from(&title));
⋮----
let css_escaped = css.replace("`", "\\`");
let footer_html = format!("{}  |  {}  |  {} {}", submit, newline, cancel_hint, cancel);
let placeholder_escaped = placeholder.replace("'", "\\'");
let script = format!(
⋮----
let _ = wv.evaluate_script("playEntry();");
⋮----
SetTimer(Some(hwnd), 2, 50, None);
LRESULT(0)
⋮----
apply_pending_text();
⋮----
let _ = wv.evaluate_script("playExit();");
⋮----
SetTimer(Some(hwnd), 4, 150, None);
⋮----
let _ = ShowWindow(hwnd, SW_HIDE);
let _ = KillTimer(Some(hwnd), 1);
let _ = KillTimer(Some(hwnd), 2);
let _ = KillTimer(Some(hwnd), 3);
⋮----
PostQuitMessage(0);
⋮----
WM_ERASEBKGND => LRESULT(1),
⋮----
let should_close = *SHOULD_CLOSE.lock().unwrap();
⋮----
let submitted = SUBMITTED_TEXT.lock().unwrap().take();
⋮----
let continuous = *CFG_CONTINUOUS.lock().unwrap();
⋮----
let cb_lock = CFG_CALLBACK.lock().unwrap();
if let Some(cb) = cb_lock.as_ref() {
cb(text, hwnd);
⋮----
clear_editor_text();
refocus_editor();
⋮----
let _ = KillTimer(Some(hwnd), 4);
⋮----
let mut should_close = SHOULD_CLOSE.lock().unwrap();
⋮----
let _ = PostMessageW(Some(hwnd), WM_CLOSE, WPARAM(0), LPARAM(0));
⋮----
let _ = GetClientRect(hwnd, &mut rect);
⋮----
if (x - close_x).abs() < 15 && (y - close_y).abs() < 15 {
⋮----
return LRESULT(0);
⋮----
SendMessageW(hwnd, WM_SYSCOMMAND, Some(WPARAM(0xF012)), Some(LPARAM(0)));
⋮----
if let Some(webview) = wv.borrow().as_ref() {
let _ = webview.set_bounds(Rect {
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
</file>

<file path="src/main.rs">
mod api;
mod assets;
mod config;
mod debug_log;
pub mod gui;
mod history;
mod icon_gen;
mod model_config;
mod overlay;
mod registry_integration;
mod updater;
pub mod win_types;
⋮----
use gui::locale::LocaleText;
use history::HistoryManager;
use lazy_static::lazy_static;
use std::collections::HashMap;
use std::panic;
⋮----
use windows::Win32::System::Com::CoInitialize;
⋮----
lazy_static! {
⋮----
pub struct GdiCapture {
⋮----
unsafe impl Send for GdiCapture {}
unsafe impl Sync for GdiCapture {}
impl Drop for GdiCapture {
fn drop(&mut self) {
⋮----
if !self.hbitmap.is_invalid() {
let _ = DeleteObject(self.hbitmap.into());
⋮----
pub struct AppState {
⋮----
fn enable_dark_mode_for_app() {
use windows::core::w;
⋮----
if let Ok(uxtheme) = LoadLibraryW(w!("uxtheme.dll")) {
⋮----
if let Some(set_preferred_app_mode) = GetProcAddress(uxtheme, proc_name) {
⋮----
func(ALLOW_DARK);
⋮----
fn cleanup_temporary_files() {
⋮----
for entry in entries.flatten() {
let name = entry.file_name();
let name_str = name.to_string_lossy();
if name_str.starts_with("sgt_restart_") && name_str.ends_with(".bat") {
let _ = std::fs::remove_file(entry.path());
⋮----
.unwrap_or_else(|| std::path::PathBuf::from("."))
.join("screen-goated-toolbox")
.join("bin");
if bin_dir.exists() {
⋮----
let path = entry.path();
if path.extension().map_or(false, |ext| ext == "tmp") {
⋮----
if let Some(exe_dir) = exe_path.parent() {
let temp_download = exe_dir.join("temp_download");
if temp_download.exists() {
⋮----
mod unpack_dlls;
fn main() -> eframe::Result<()> {
⋮----
cleanup_temporary_files();
⋮----
let _ = CoInitialize(None);
if let Ok(hidpi) = LoadLibraryW(w!("user32.dll")) {
if let Some(set_context) = GetProcAddress(
⋮----
PCSTR::from_raw("SetProcessDpiAwarenessContext\0".as_ptr()),
⋮----
let _ = func(-4);
⋮----
enable_dark_mode_for_app();
⋮----
let staging_path = exe_dir.join("update_pending.exe");
let backup_path = exe_path.with_extension("exe.old");
if staging_path.exists() {
⋮----
if std::fs::rename(&staging_path, &exe_path).is_ok() {
⋮----
let current_exe_name = exe_path.file_name().and_then(|n| n.to_str()).unwrap_or("");
⋮----
for entry in entries.filter_map(|e| e.ok()) {
let file_name = entry.file_name();
let name_str = file_name.to_string_lossy();
// Delete old ScreenGoatedToolbox_v*.exe files (keep only current)
if (name_str.starts_with("ScreenGoatedToolbox_v") && name_str.ends_with(".exe"))
&& name_str.as_ref() != current_exe_name
⋮----
if name_str.ends_with(".exe.old") {
⋮----
let location = if let Some(location) = panic_info.location() {
format!("File: {}\nLine: {}", location.file(), location.line())
⋮----
"Unknown location".to_string()
⋮----
let payload = if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
s.to_string()
} else if let Some(s) = panic_info.payload().downcast_ref::<String>() {
s.clone()
⋮----
"Unknown panic payload".to_string()
⋮----
let error_msg = format!(
⋮----
let wide_msg: Vec<u16> = error_msg.encode_utf16().chain(std::iter::once(0)).collect();
⋮----
.encode_utf16()
.chain(std::iter::once(0))
.collect();
⋮----
MessageBoxW(
⋮----
PCWSTR(wide_msg.as_ptr()),
PCWSTR(wide_title.as_ptr()),
⋮----
let _ = RESTORE_EVENT.as_ref();
⋮----
let instance = CreateMutexW(
⋮----
w!("Global\\ScreenGoatedToolboxSingleInstanceMutex"),
⋮----
if GetLastError() == ERROR_ALREADY_EXISTS {
let args: Vec<String> = std::env::args().collect();
for arg in args.iter().skip(1) {
if arg.starts_with("--") {
⋮----
if path.exists() && path.is_file() {
let temp_file = std::env::temp_dir().join("sgt_pending_file.txt");
⋮----
use std::io::Write;
let _ = write!(f, "{}", path.to_string_lossy());
⋮----
if let Some(event) = RESTORE_EVENT.as_ref() {
let _ = SetEvent(event.0);
⋮----
let _ = CloseHandle(handle);
return Ok(());
⋮----
Some(handle)
⋮----
run_hotkey_listener();
⋮----
if args.iter().any(|arg| arg == "--restarted") {
⋮----
pending_file_path = Some(path);
⋮----
let mut config = APP.lock().unwrap();
⋮----
wait_for_popup_close();
⋮----
let initial_config = APP.lock().unwrap().config.clone();
⋮----
let has_favorites = initial_config.presets.iter().any(|p| p.is_favorite);
⋮----
let _ = tray_menu.append(&tray_favorite_bubble_item);
let _ = tray_menu.append(&tray_settings_item);
let _ = tray_menu.append(&tray_quit_item);
⋮----
.with_inner_size([WINDOW_WIDTH, WINDOW_HEIGHT])
.with_resizable(true)
.with_visible(false)
.with_transparent(true)
.with_decorations(false);
⋮----
viewport_builder = viewport_builder.with_icon(std::sync::Arc::new(icon_data));
⋮----
*gui::GUI_CONTEXT.lock().unwrap() = Some(cc.egui_ctx.clone());
⋮----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::dark());
⋮----
cc.egui_ctx.set_visuals(eframe::egui::Visuals::light());
⋮----
Ok(Box::new(gui::SettingsApp::new(
⋮----
APP.clone(),
⋮----
cc.egui_ctx.clone(),
⋮----
fn register_all_hotkeys(hwnd: HWND) {
let mut app = APP.lock().unwrap();
⋮----
for (p_idx, preset) in presets.iter().enumerate() {
for (h_idx, hotkey) in preset.hotkeys.iter().enumerate() {
if [0x04, 0x05, 0x06].contains(&hotkey.code) {
⋮----
let _ = RegisterHotKey(
Some(hwnd),
⋮----
HOT_KEY_MODIFIERS(hotkey.modifiers),
⋮----
registered_ids.push(id);
⋮----
fn unregister_all_hotkeys(hwnd: HWND) {
let app = APP.lock().unwrap();
⋮----
let _ = UnregisterHotKey(Some(hwnd), id);
⋮----
unsafe extern "system" fn mouse_hook_proc(code: i32, wparam: WPARAM, lparam: LPARAM) -> LRESULT {
⋮----
WM_MBUTTONDOWN => Some(0x04),
⋮----
Some(0x05)
⋮----
Some(0x06)
⋮----
if (GetAsyncKeyState(VK_MENU.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_CONTROL.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_SHIFT.0 as i32) as u16 & 0x8000) != 0 {
⋮----
if (GetAsyncKeyState(VK_LWIN.0 as i32) as u16 & 0x8000) != 0
|| (GetAsyncKeyState(VK_RWIN.0 as i32) as u16 & 0x8000) != 0
⋮----
if let Ok(app) = APP.lock() {
for (p_idx, preset) in app.config.presets.iter().enumerate() {
⋮----
found_id = Some((p_idx as i32 * 1000) + (h_idx as i32) + 1);
⋮----
if found_id.is_some() {
⋮----
if let Ok(hwnd_target) = LISTENER_HWND.lock() {
if !hwnd_target.0.is_invalid() {
let _ = PostMessageW(
Some(hwnd_target.0),
⋮----
WPARAM(id as usize),
LPARAM(0),
⋮----
return LRESULT(1);
⋮----
CallNextHookEx(None, code, wparam, lparam)
⋮----
fn run_hotkey_listener() {
⋮----
let instance = match GetModuleHandleW(None) {
⋮----
eprintln!("Error: Failed to get module handle for hotkey listener");
⋮----
let class_name = w!("HotkeyListenerClass");
⋮----
lpfnWndProc: Some(hotkey_proc),
hInstance: instance.into(),
⋮----
let _ = RegisterClassW(&wc);
let hwnd = CreateWindowExW(
⋮----
w!("Listener"),
⋮----
Some(instance.into()),
⋮----
.unwrap_or_default();
if hwnd.is_invalid() {
eprintln!("Error: Failed to create hotkey listener window");
⋮----
if let Ok(mut guard) = LISTENER_HWND.lock() {
*guard = SendHwnd(hwnd);
⋮----
if WaitForSingleObject(event.0, INFINITE) == WAIT_OBJECT_0 {
⋮----
Some(HWND(listener_hwnd_val as *mut _)),
⋮----
WPARAM(0),
⋮----
let _ = ResetEvent(event.0);
⋮----
SetWindowsHookExW(WH_MOUSE_LL, Some(mouse_hook_proc), Some(instance.into()), 0)
⋮----
if let Ok(mut hook_guard) = MOUSE_HOOK.lock() {
*hook_guard = SendHhook(hhook);
⋮----
eprintln!("Warning: Failed to install low-level mouse hook");
⋮----
register_all_hotkeys(hwnd);
⋮----
if GetMessageW(&mut msg, None, 0, 0).as_bool() {
⋮----
unregister_all_hotkeys(hwnd);
⋮----
if let Ok(mut app) = APP.lock() {
⋮----
let _ = TranslateMessage(&msg);
DispatchMessageW(&msg);
⋮----
unsafe extern "system" fn hotkey_proc(
⋮----
if temp_file.exists() {
⋮----
let path = std::path::PathBuf::from(content.trim());
if path.exists() {
⋮----
let path_clone = path.clone();
⋮----
LRESULT(0)
⋮----
if now.duration_since(t).as_millis() < 150 {
⋮----
LAST_HOTKEY_TIMESTAMP = Some(now);
⋮----
return LRESULT(0);
⋮----
if preset_idx < app.config.presets.len() {
⋮----
let p_type = p.preset_type.clone();
let t_mode = p.text_input_mode.clone();
⋮----
let hk_name = if hk_idx < p.hotkeys.len() {
⋮----
hk.name.clone(),
⋮----
hk.name.clone()
⋮----
"image".to_string(),
"select".to_string(),
⋮----
app.last_active_window = target_window.map(crate::win_types::SendHwnd);
⋮----
.load(std::sync::atomic::Ordering::SeqCst);
⋮----
let config = app.config.clone();
let preset = config.presets[preset_idx].clone();
let screen_w = GetSystemMetrics(SM_CXSCREEN);
let screen_h = GetSystemMetrics(SM_CYSCREEN);
⋮----
let hotkey_name_clone = hotkey_name.clone();
⋮----
let app_clone = APP.clone();
⋮----
match capture_screen_fast() {
⋮----
if let Ok(mut app) = app_clone.lock() {
app.screenshot_handle = Some(capture);
⋮----
eprintln!("Capture Error: {}", e);
⋮----
_ => DefWindowProcW(hwnd, msg, wparam, lparam),
⋮----
fn capture_screen_fast() -> anyhow::Result<GdiCapture> {
⋮----
let x = GetSystemMetrics(SM_XVIRTUALSCREEN);
let y = GetSystemMetrics(SM_YVIRTUALSCREEN);
let width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
let height = GetSystemMetrics(SM_CYVIRTUALSCREEN);
⋮----
return Err(anyhow::anyhow!(
⋮----
let hdc_screen = GetDC(None);
if hdc_screen.is_invalid() {
⋮----
let hdc_mem = CreateCompatibleDC(Some(hdc_screen));
if hdc_mem.is_invalid() {
let _ = ReleaseDC(None, hdc_screen);
⋮----
let hbitmap = CreateCompatibleBitmap(hdc_screen, width, height);
if hbitmap.is_invalid() {
let _ = DeleteDC(hdc_mem);
⋮----
SelectObject(hdc_mem, hbitmap.into());
BitBlt(
⋮----
Some(hdc_screen),
⋮----
ReleaseDC(None, hdc_screen);
Ok(GdiCapture {
</file>

</files>
